<!doctype html>



  


<html class="theme-next muse use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="前端 女程序员 blog  JS" />





  <link rel="alternate" href="/atom.xml" title="关凯丽的博客" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1" />






<meta name="description" content="HTML常见的行内元素与块级元素都有哪些，分别举例 ，并说一说区别5%
行内元素(inline)：a b span input select strong samll
块级元素(block)：p div ul ol li dl dt dd h1 table form center
行内块级元素(inline-block):img
常见的空元素：
1&amp;lt;br/&amp;gt; &amp;lt;hr/&amp;gt;">
<meta property="og:type" content="article">
<meta property="og:title" content="ms">
<meta property="og:url" content="http://carryguan.com/2016/06/27/ms/index.html">
<meta property="og:site_name" content="关凯丽的博客">
<meta property="og:description" content="HTML常见的行内元素与块级元素都有哪些，分别举例 ，并说一说区别5%
行内元素(inline)：a b span input select strong samll
块级元素(block)：p div ul ol li dl dt dd h1 table form center
行内块级元素(inline-block):img
常见的空元素：
1&amp;lt;br/&amp;gt; &amp;lt;hr/&amp;gt;">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/2377897-2fc97e71155223a0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/2377897-502ce3aaecc4b38b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/2377897-0a9d9c4eb7fc996e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/2377897-394530a71e54ed9f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/2377897-e655b83124da94d9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/2377897-c6dff4f74e7f2eb3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/2377897-f47a188d60bd97a4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/2377897-8e3d9af0d6d264b0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/2377897-5e416993bde1fdb7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/2377897-394530a71e54ed9f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/2377897-e655b83124da94d9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/2377897-d9abdd592a00f11f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/2377897-b81be614658808c3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/2377897-d51bad8105ff7116.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/2377897-665a15e11ea92788.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/2377897-2e14787d1c2eae05.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/2377897-f0c90cfaba1aabac.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:updated_time" content="2017-08-17T02:35:52.392Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="ms">
<meta name="twitter:description" content="HTML常见的行内元素与块级元素都有哪些，分别举例 ，并说一说区别5%
行内元素(inline)：a b span input select strong samll
块级元素(block)：p div ul ol li dl dt dd h1 table form center
行内块级元素(inline-block):img
常见的空元素：
1&amp;lt;br/&amp;gt; &amp;lt;hr/&amp;gt;">
<meta name="twitter:image" content="http://upload-images.jianshu.io/upload_images/2377897-2fc97e71155223a0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Muse',
    sidebar: {"position":"right","display":"always"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 13817414,
      author: '博主'
    }
  };
</script>




  <link rel="canonical" href="http://carryguan.com/2016/06/27/ms/"/>

  <title> ms | 关凯丽的博客 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  



  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?baa6059274e7d35050154321a77db806";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>








  
  
    
  

  <div class="container one-collumn sidebar-position-right page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">关凯丽的博客</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">前端打杂</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about-me" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="#" class="st-search-show-outputs">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <form class="site-search-form">
  <input type="text" id="st-search-input" class="st-search-input st-default-search-input" />
</form>

<script type="text/javascript">
  (function(w,d,t,u,n,s,e){w['SwiftypeObject']=n;w[n]=w[n]||function(){
    (w[n].q=w[n].q||[]).push(arguments);};s=d.createElement(t);
    e=d.getElementsByTagName(t)[0];s.async=1;s.src=u;e.parentNode.insertBefore(s,e);
  })(window,document,'script','//s.swiftypecdn.com/install/v2/st.js','_st');

  _st('install', '9swbp66zbunTR5mG6RnR','2.0.0');
</script>



    </div>
  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                ms
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-06-27T13:28:25+08:00" content="2016-06-27">
              2016-06-27
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/06/27/ms/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/06/27/ms/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h1><h2 id="常见的行内元素与块级元素都有哪些，分别举例-，并说一说区别5"><a href="#常见的行内元素与块级元素都有哪些，分别举例-，并说一说区别5" class="headerlink" title="常见的行内元素与块级元素都有哪些，分别举例 ，并说一说区别5%"></a>常见的行内元素与块级元素都有哪些，分别举例 ，并说一说区别5%</h2><ul>
<li>行内元素(inline)：a b span input select strong samll</li>
<li>块级元素(block)：p div ul ol li dl dt dd h1 table form center</li>
<li>行内块级元素(inline-block):img</li>
<li><p>常见的空元素：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;br/&gt; &lt;hr/&gt;  &lt;link/&gt; &lt;meta/&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>行内元素与块级元素的区别：</p>
<ul>
<li>行内元素一行占好多个，块级元素独占一行</li>
<li>设置宽度width ,height 无效，可以通过line-height来设置。</li>
<li>设置左右margin/padding有效，上下margin/padding无效</li>
</ul>
</li>
</ul>
<hr>
<h2 id="居中的常见方法-水平，竖直-5"><a href="#居中的常见方法-水平，竖直-5" class="headerlink" title="居中的常见方法(水平，竖直) 5%"></a>居中的常见方法(水平，竖直) 5%</h2><h3 id="1-水平居中的-margin：0-auto"><a href="#1-水平居中的-margin：0-auto" class="headerlink" title="1.水平居中的 margin：0 auto;"></a>1.水平居中的 margin：0 auto;</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">.box&#123;</span><br><span class="line">    width: 300px;</span><br><span class="line">    height: 300px;</span><br><span class="line">    border: 3px solid red;</span><br><span class="line">&#125;</span><br><span class="line">img&#123;</span><br><span class="line">    display: block;</span><br><span class="line">    width: 100px;</span><br><span class="line">    height: 100px;</span><br><span class="line">    margin: 0 auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-水平居中-text-align：center；"><a href="#2-水平居中-text-align：center；" class="headerlink" title="2.水平居中 text-align：center；"></a>2.水平居中 text-align：center；</h3><p>子元素的display：inline-block；类似一样在不受float影响下进行<br>是在父元素上添加效果让它进行水平居中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">.box&#123;</span><br><span class="line">    width: 300px;</span><br><span class="line">    height: 300px;</span><br><span class="line">    border: 3px solid red;</span><br><span class="line">    text-align: center;</span><br><span class="line">&#125;</span><br><span class="line">img&#123;</span><br><span class="line">    display: inline-block;</span><br><span class="line">    width: 100px;</span><br><span class="line">    height: 100px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="水平垂直居中（一）-定位-要垂直居中的宽高-需要定位的元素的margin减去宽高的一半"><a href="#水平垂直居中（一）-定位-要垂直居中的宽高-需要定位的元素的margin减去宽高的一半" class="headerlink" title="水平垂直居中（一） 定位 要垂直居中的宽高 需要定位的元素的margin减去宽高的一半"></a>水平垂直居中（一） 定位 要垂直居中的宽高 需要定位的元素的margin减去宽高的一半</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">img&#123;</span><br><span class="line">    width: 100px;</span><br><span class="line">    height: 150px;</span><br><span class="line">    position: absolute;</span><br><span class="line">    top: 50%;</span><br><span class="line">    left: 50%;</span><br><span class="line">    margin-top: -75px;</span><br><span class="line">    margin-left: -50px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="水平垂直居中（二）定位和margin-auto，不用受到宽高的限制"><a href="#水平垂直居中（二）定位和margin-auto，不用受到宽高的限制" class="headerlink" title="水平垂直居中（二）定位和margin:auto，不用受到宽高的限制,"></a>水平垂直居中（二）定位和margin:auto，不用受到宽高的限制,</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">img&#123;</span><br><span class="line">       width: 100px;</span><br><span class="line">       height: 150px;</span><br><span class="line">       position: absolute;</span><br><span class="line">       top: 0;</span><br><span class="line">       left: 0;</span><br><span class="line">       right: 0;</span><br><span class="line">       bottom: 0;</span><br><span class="line">       margin: auto;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h3 id="水平垂直居中（三）绝对定位和transfrom"><a href="#水平垂直居中（三）绝对定位和transfrom" class="headerlink" title="水平垂直居中（三）绝对定位和transfrom"></a>水平垂直居中（三）绝对定位和transfrom</h3><p>不需要知道居中元素的宽高<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">img&#123;</span><br><span class="line">        position: absolute;</span><br><span class="line">        top: 50%;</span><br><span class="line">        left: 50%;</span><br><span class="line">        transform: translate(-50%,-50%);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="水平垂直居中（四）diplay：table-cell"><a href="#水平垂直居中（四）diplay：table-cell" class="headerlink" title="水平垂直居中（四）diplay：table-cell"></a>水平垂直居中（四）diplay：table-cell</h3><p>其实这个就是把其变成表格样式，再利用表格的样式来进行居中，很方便<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">box&#123;</span><br><span class="line">            width: 300px;</span><br><span class="line">            height: 300px;</span><br><span class="line">            background:#e9dfc7; </span><br><span class="line">            border:1px solid red;</span><br><span class="line"></span><br><span class="line">            display: table-cell;</span><br><span class="line">            vertical-align: middle;</span><br><span class="line">            text-align: center;</span><br><span class="line">        &#125;</span><br><span class="line">        img&#123;</span><br><span class="line">            width: 100px;</span><br><span class="line">            height: 150px;</span><br><span class="line">            /*margin: 0 auto;*/  这个也行</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="水平垂直居中（五）flexBox居中"><a href="#水平垂直居中（五）flexBox居中" class="headerlink" title="水平垂直居中（五）flexBox居中"></a>水平垂直居中（五）flexBox居中</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">.box&#123;</span><br><span class="line">            width: 300px;</span><br><span class="line">            height: 300px;</span><br><span class="line">            background:#e9dfc7; </span><br><span class="line">            border:1px solid red;</span><br><span class="line">            display: flex;</span><br><span class="line">            justify-content: center;</span><br><span class="line">            align-items:center;</span><br><span class="line">        &#125;</span><br><span class="line">        img&#123;</span><br><span class="line">            width: 150px;</span><br><span class="line">            height: 100px;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p><a href="http://www.jianshu.com/p/a7552ce07c88" target="_blank" rel="external">http://www.jianshu.com/p/a7552ce07c88</a></p>
<hr>
<h2 id="说一下为什么要清除浮动以及常见的清除浮动的方法-4"><a href="#说一下为什么要清除浮动以及常见的清除浮动的方法-4" class="headerlink" title="说一下为什么要清除浮动以及常见的清除浮动的方法 4%"></a>说一下为什么要清除浮动以及常见的清除浮动的方法 4%</h2><p>当一个内层元素是浮动的时候，如果没有关闭浮动时，其父元素也就不会再包含这个浮动的内层元素，因为此时浮动元素已经脱离了文档流。也就是为什么外层不能被撑开了！<br>（2）：边框不能撑开 （3）：margin ,padding设置值不能正确显示（1）：背景不能显示</p>
<h3 id="方法一：添加新的元素-、应用-clear：both"><a href="#方法一：添加新的元素-、应用-clear：both" class="headerlink" title="方法一：添加新的元素 、应用 clear：both"></a>方法一：添加新的元素 、应用 clear：both</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">div class=&quot;outer&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;div1&quot;&gt;1&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;div2&quot;&gt;2&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;div3&quot;&gt;3&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;clear&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">.clear&#123;clear:both; height: 0; line-height: 0; font-size: 0&#125;</span><br></pre></td></tr></table></figure>
<h3 id="方法二：父级div定义-overflow-auto（hidden也可以，就是对seo不太友好）"><a href="#方法二：父级div定义-overflow-auto（hidden也可以，就是对seo不太友好）" class="headerlink" title="方法二：父级div定义 overflow: auto（hidden也可以，就是对seo不太友好）"></a>方法二：父级div定义 overflow: auto（hidden也可以，就是对seo不太友好）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">父亲 </span><br><span class="line">.over-flow&#123;</span><br><span class="line">    overflow: auto; zoom: 1; //zoom: 1; 是在处理兼容性问题</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="方法三：-据说是最高大上的方法-after-方法：（注意：作用于浮动元素的父亲）"><a href="#方法三：-据说是最高大上的方法-after-方法：（注意：作用于浮动元素的父亲）" class="headerlink" title="方法三： 据说是最高大上的方法  :after 方法：（注意：作用于浮动元素的父亲）"></a>方法三： 据说是最高大上的方法  :after 方法：（注意：作用于浮动元素的父亲）</h3><p>其实现原理类似于clear:both方法，<br>只是区别在于:clear在html插入一个div.clear标签，<br>而outer利用其伪类clear:after在元素内部增加一个类似于div.clear的效果。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">.outer &#123;zoom:1;&#125;    /*==for IE6/7 Maxthon2==*/</span><br><span class="line"></span><br><span class="line">.outer :after &#123;</span><br><span class="line">clear:both;</span><br><span class="line">content:&apos;.&apos;; //值也可为空</span><br><span class="line">display:block;</span><br><span class="line">width: 0;</span><br><span class="line">height: 0;</span><br><span class="line">visibility:hidden;</span><br><span class="line">&#125;   /*==for FF/chrome/opera/IE8==*/</span><br></pre></td></tr></table></figure></p>
<p><a href="https://my.oschina.net/leipeng/blog/221125" target="_blank" rel="external">https://my.oschina.net/leipeng/blog/221125</a><br><a href="http://www.jianshu.com/p/5138706046b1" target="_blank" rel="external">http://www.jianshu.com/p/5138706046b1</a></p>
<hr>
<h2 id="介绍一下标准的CSS的盒子模型？低版本IE的盒子模型有什么不同的？"><a href="#介绍一下标准的CSS的盒子模型？低版本IE的盒子模型有什么不同的？" class="headerlink" title="介绍一下标准的CSS的盒子模型？低版本IE的盒子模型有什么不同的？"></a>介绍一下标准的CSS的盒子模型？低版本IE的盒子模型有什么不同的？</h2><p>每个HTML元素都是长方形盒子。<br>  （1）有两种， IE 盒子模型、W3C 盒子模型；<br>  （2）盒模型： 内容(content)、填充(padding)、边界(margin)、 边框(border)；<br>  （3）区  别： IE的content部分把 border 和 padding计算了进去;<br><img src="http://upload-images.jianshu.io/upload_images/2377897-2fc97e71155223a0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/2377897-502ce3aaecc4b38b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<hr>
<h2 id="position-的几种值-，详细说明一下每种的区别-3"><a href="#position-的几种值-，详细说明一下每种的区别-3" class="headerlink" title="position 的几种值 ，详细说明一下每种的区别 3%"></a>position 的几种值 ，详细说明一下每种的区别 3%</h2><ul>
<li>static    默认。位置设置为 static 的元素，它始终会处于页面流给予的位置（static 元素会忽略任何 top、bottom、left 或 right 声明）。</li>
<li>relative    位置被设置为 relative 的元素，可将其移至相对于其正常位置的地方，因此 “left:20” 会将元素移至元素正常位置左边 20 个像素的位置。</li>
<li>absolute    位置设置为 absolute 的元素，可定位于相对于包含它的元素的指定坐标。此元素的位置可通过 “left”、”top”、”right” 以及 “bottom” 属性来规定。</li>
<li>fixed    位置被设置为 fixed 的元素，可定位于相对于浏览器窗口的指定坐标。此元素的位置可通过 “left”、”top”、”right” 以及”bottom” 属性来规定。不论窗口滚动与否，元素都会留在那个位置。工作于 IE7（strict 模式）。</li>
</ul>
<hr>
<h2 id="如果position设置成absolute属性该元素的display属性会变成什么"><a href="#如果position设置成absolute属性该元素的display属性会变成什么" class="headerlink" title="如果position设置成absolute属性该元素的display属性会变成什么"></a>如果position设置成absolute属性该元素的display属性会变成什么</h2><ul>
<li>position: absolute,float会隐式的改变display类型， 不论之前是什么类型的元素（ display: none除外），<ul>
<li>只要设置了position: absolute或float， 都会让元素以display: inline - block的方式显示， 可以设置长宽，</li>
</ul>
</li>
<li>就算是显示的设置display: inline或display: block， 仍然无效。</li>
</ul>
<hr>
<h2 id="display-有几个值-3"><a href="#display-有几个值-3" class="headerlink" title="display 有几个值  3%"></a>display 有几个值  3%</h2><p>每个元素都有display属性，确定该元素的类型，<br>每个元素都有默认的display值，<br>如div的display默认值为“block”，则为“块级”元素；<br>span默认display属性值为“inline”，是“行内”元素。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2377897-0a9d9c4eb7fc996e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<hr>
<h2 id="伪类-伪元素"><a href="#伪类-伪元素" class="headerlink" title="伪类 伪元素"></a>伪类 伪元素</h2><p>伪类是给元素模拟添加类 ，来实现某种效果（：）<br>常见伪类：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2377897-394530a71e54ed9f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<p>伪元素是模拟添加个元素来实现效果（::）(css3出现后做的区分)<br>常见伪元素：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2377897-e655b83124da94d9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<p><a href="http://web.jobbole.com/86181/" target="_blank" rel="external">http://web.jobbole.com/86181/</a></p>
<hr>
<h2 id="CSS3新增伪类有那些？"><a href="#CSS3新增伪类有那些？" class="headerlink" title="CSS3新增伪类有那些？"></a>CSS3新增伪类有那些？</h2><pre><code>举例：
  p:first-of-type    选择属于其父元素的首个 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。
  p:last-of-type    选择属于其父元素的最后 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。
  p:only-of-type    选择属于其父元素唯一的 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。
  p:only-child        选择属于其父元素的唯一子元素的每个 &lt;p&gt; 元素。
  p:nth-child(2)    选择属于其父元素的第二个子元素的每个 &lt;p&gt; 元素。

 inptut
    :enabled          
   :disabled         控制表单控件的禁用状态。
  :checked        单选框或复选框被选中。
</code></pre><hr>
<h2 id="CSS选择器有哪些？哪些属性可以继承？"><a href="#CSS选择器有哪些？哪些属性可以继承？" class="headerlink" title="CSS选择器有哪些？哪些属性可以继承？"></a>CSS选择器有哪些？哪些属性可以继承？</h2><pre><code> 1.id选择器（ # myid）
2.类选择器（.myclassname）
3.标签选择器（div, h1, p）
4.相邻选择器（h1 + p）
5.子选择器（ul &gt; li）
6.后代选择器（li a）
7.通配符选择器（ * ）
8.属性选择器（a[rel = &quot;external&quot;]）
9.伪类选择器（a:hover, li:nth-child）
</code></pre><ul>
<li><p>可继承的样式： font-size font-family color, UL LI DL DD DT;</p>
</li>
<li><p>不可继承的样式：border padding margin width height ;</p>
</li>
</ul>
<hr>
<h2 id="CSS优先级算法如何计算？"><a href="#CSS优先级算法如何计算？" class="headerlink" title="CSS优先级算法如何计算？"></a>CSS优先级算法如何计算？</h2><ul>
<li>优先级就近原则，同权重情况下样式定义最近者为准;</li>
<li>载入样式以最后载入的定位为准;<h3 id="同权重"><a href="#同权重" class="headerlink" title="同权重"></a>同权重</h3><ul>
<li>1、 位于 &lt; head / &gt; 标签里的 &lt; style / &gt; 中所定义的CSS拥有最高级的优先权。　　</li>
<li>2、 第二级的优先属性由位于 &lt; style / &gt; 标签中的 @import 引入样式表所定义。　　</li>
<li>3、 第三级的优先属性由 &lt; link / &gt; 标签所引入的样式表定义。</li>
<li>4、 第四级的优先属性由 &lt; link / &gt; 标签所引入的样式表内的 @import 导入样式表定义。　　</li>
<li>5、 第五级优先的样式有用户设定。　　 最低级的优先权由浏览器默认。 </li>
</ul>
</li>
</ul>
<p>权重的进制是256</p>
<h3 id="属性选择器的权重问题"><a href="#属性选择器的权重问题" class="headerlink" title="属性选择器的权重问题:"></a>属性选择器的权重问题:</h3><pre><code>// !important ---------&gt;   无穷
// 行间样式-------------&gt;   1000
// id------------------&gt;   100
// class|属性|伪类------&gt;   10
// 标签|伪元素 ---------&gt;    1
// 通配符---------------&gt;   0
</code></pre><hr>
<h2 id="页面导入样式时，使用link和-import有什么区别？"><a href="#页面导入样式时，使用link和-import有什么区别？" class="headerlink" title="页面导入样式时，使用link和@import有什么区别？"></a>页面导入样式时，使用link和@import有什么区别？</h2><p>1 : 属于link属于xml 标签，除了加载css以外，还能定义rss和rel等 。@import是css提供的，只能用于加载css<br>2 :页面加载页面在加载时候，link同时被加载；而@import引用的css等页面加载完毕再加载<br>3：兼容性@import是CSS2.1 提出的，只在IE5以上才能被识别，而link是XHTML标签，无兼容问题;<br>4：link方式的样式权重高于@import的权重。<br>5：使用dom控制样式时的差别。当使用javascript控制dom去改变样式的时候，只能使用link标签，因为@import不是dom可以控制的。<br>6：. 最后一个很有意思， @import url有最大次数的限制， IE6最多引入31次， firefox并没有发现<br>7： @import的优点： 多个样式表导入一个样式表中， 页面只需要引入一个即可</p>
<hr>
<h2 id="引入css的几种方式-2"><a href="#引入css的几种方式-2" class="headerlink" title="引入css的几种方式 2%"></a>引入css的几种方式 2%</h2><h3 id="1-行内样式"><a href="#1-行内样式" class="headerlink" title="1.行内样式"></a>1.行内样式</h3><p>最直接最简单的一种，直接对HTML标签使用style=””，例如：</p>
<p style="color:#F00; "></p>

<p>缺点：HTML页面不纯净，文件体积大，不利于蜘蛛爬行，后期维护不方便。</p>
<h3 id="2-内嵌样式"><a href="#2-内嵌样式" class="headerlink" title="2.内嵌样式"></a>2.内嵌样式</h3><p>内嵌样式就是将CSS代码写在<head></head>之间，并且用<style></style>进行声明，例如：</p>
<style type="text/css">

body,div,a,img,p{margin:0; padding:0;}

</style>

<p>优缺点：页面使用公共CSS代码，也是每个页面都要定义的，如果一个网站有很多页面，每个文件都会变大，后期维护难度也大，如果文件很少，CSS代码也不多，这种样式还是很不错的。</p>
<h3 id="3-链接样式"><a href="#3-链接样式" class="headerlink" title="3.链接样式"></a>3.链接样式</h3><p>链接样式是使用频率最高，最实用的样式，只需要在<head></head>之间加上<link…>就可以了，如下：</link…></p>
<link type="text/css" rel="stylesheet" href="style.css">

<p>优缺点：实现了页面框架代码与表现CSS代码的完全分离，使得前期制作和后期维护都十分方便</p>
<h3 id="4-导入样式（不建议使用）"><a href="#4-导入样式（不建议使用）" class="headerlink" title="4.导入样式（不建议使用）"></a>4.导入样式（不建议使用）</h3><p>导入样式和链接样式比较相似，采用@import样式导入CSS样式表，在HTML初始化时，会被导入到HTML或者CSS文件中，成为文件的一部分，类似第二种内嵌样式。</p>
<ul>
<li>@import在html中使用，如下：</li>
</ul>
<style type="text/css">
@import url(style.css);
</style>

<ul>
<li>@import在CSS中使用，如下：</li>
</ul>
<p>@import url(style.css);</p>
<h3 id="四种CSS引入方式的优先级"><a href="#四种CSS引入方式的优先级" class="headerlink" title="四种CSS引入方式的优先级"></a>四种CSS引入方式的优先级</h3><p>1.就近原则<br>2.理论上：行内&gt;内嵌&gt;链接&gt;导入<br>3.实际上：内嵌、链接、导入在同一个文件头部，谁离相应的代码近，谁的优先级高</p>
<hr>
<h2 id="锚点-1"><a href="#锚点-1" class="headerlink" title="锚点 1%"></a>锚点 1%</h2><p>html 锚点 到底是干吗的？<br>通俗简单地说，比如一篇很长的文章，你想按分段精确来看，那就可以用到锚点了<br>代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href=&quot;#001&quot;&gt;跳到001&lt;/a&gt;</span><br><span class="line">...文字省略</span><br><span class="line">&lt;a name=&quot;001&quot; id=&quot;001&quot; &gt;&lt;/a&gt;</span><br><span class="line">...文字省略</span><br></pre></td></tr></table></figure></p>
<p>(兼容到ie8)<br>其实锚点只需name就可以可，加id是为了让它兼容性更好.<br>href的值要跟name \ i d 一致，前面必须加”#”，以上代码在ie6/7,ff中都可以兼容，但在ie8中就不行。<br>因为我们锚点的<a></a>值为空，为不影响美观我们加个空格就行了,</p>
<p>另一问题，想显示某页面(如：123.html)的某锚点内容呢？ </p>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">代码如下</span><br><span class="line">&lt;a href=&quot;123.html#001&quot;&gt;跳到001&lt;/a&gt;</span><br><span class="line">...文字省略</span><br><span class="line">&lt;a name=&quot;001&quot; id=&quot;001&quot; &gt; &lt;/a&gt;</span><br><span class="line">...文字省略</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="两栏布局"><a href="#两栏布局" class="headerlink" title="两栏布局"></a>两栏布局</h2><h3 id="1-左定宽高-浮动，-右边设置margin-left"><a href="#1-左定宽高-浮动，-右边设置margin-left" class="headerlink" title="1:左定宽高 浮动， 右边设置margin - left"></a>1:左定宽高 浮动， 右边设置margin - left</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">.left &#123;</span><br><span class="line">    width: 100 px;</span><br><span class="line">    height: 100 px;</span><br><span class="line">    background - color: red;</span><br><span class="line">    float: left;</span><br><span class="line">&#125;</span><br><span class="line">.right &#123;</span><br><span class="line">    height: 100 px;</span><br><span class="line">    background - color: green;</span><br><span class="line">    margin - left: 100 px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-定位-：左边定宽高-设置定位position-absolute-left-0"><a href="#2-定位-：左边定宽高-设置定位position-absolute-left-0" class="headerlink" title="2:定位 ：左边定宽高 ,设置定位position absolute, left 0 ;"></a>2:定位 ：左边定宽高 ,设置定位position absolute, left 0 ;</h3><pre><code>.left {
    width: 100 px;
    height: 100 px;
    background - color: red;
    position: absolute;
    left: 0;
}
.right {
    height: 100 px;
    background - color: green;
    right: 0;
}
</code></pre><hr>
<h2 id="实现三列布局"><a href="#实现三列布局" class="headerlink" title="实现三列布局"></a>实现三列布局</h2><p>有两种实现方式</p>
<ol>
<li>左右两侧的div先用absolute定位， 再给中间的div加margin - left和margin - right（ 值分别是两个div的宽度）<ol>
<li>用flaot替换上面的absolute就行<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">.left &#123;</span><br><span class="line">    float: left;</span><br><span class="line">    width: 100 px;</span><br><span class="line">    height: 100 px;</span><br><span class="line">    background - color: orange;</span><br><span class="line">&#125;</span><br><span class="line">.right &#123;</span><br><span class="line">    float: right;</span><br><span class="line">    width: 100 px;</span><br><span class="line">    height: 100 px;</span><br><span class="line">    background - color: red;</span><br><span class="line">&#125;</span><br><span class="line">.mid &#123;</span><br><span class="line">    height: 100 px;</span><br><span class="line">    margin - left: 100 px;</span><br><span class="line">    margin - right: 100 px;</span><br><span class="line">    background - color: blue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ol>
<p>要注意的是， div.mid记得写在后面， 如果写在最前面的话， 因为div是block块级元素会独占一行，<br>        这样就会把右侧的div给挤到下一行了。 当然我们给.left和.right都加上top: 0 px;<br>        之后， 这个问题也就不用考虑了。</p>
<hr>
<h2 id="BFC的通俗理解："><a href="#BFC的通俗理解：" class="headerlink" title="BFC的通俗理解："></a>BFC的通俗理解：</h2><ul>
<li>Block Formatting Context（ 块级格式化上下文） 是W3C CSS 2.1 规范中的一个概念， 它决定了元素如何对其内容进行定位， 以及与其他元素的关系和相互作用。 简单来讲， 我们可以把它理解为， 我们在进行盒模型布局的时候， 如果一个元素符合了成为BFC的条件，<ul>
<li>该元素成为一个隔离了的独立容器， 元素内部元素会垂直的沿着其父元素的边框排列， 和外部元素互不影响。 比如浮动元素会触发BFC，<br>浮动元素内部的子元素主要受到该浮动元素的影响， 而两个浮动元素之间是互不影响的。</li>
<li>在CSS3 中， BFC 叫做Flow Root。 在早期的ie中也有类似的概念haslayout IE6、 7 的很多布局产生的bug（ 如3px间隙、 绝对定位的继承宽度）都可以通过触发hasLayout修复， 比较推荐的方法为zoom: 1 与height: 1 % ，不会破坏已有的样式， 相信大家对它并不陌生。</li>
<li>同样的以往集中在float、 绝对定位、 margin collaspe中的很多困惑， 在理解了bfc后， 都能够被我们一一解除。<h2 id="BFC规范中的定义："><a href="#BFC规范中的定义：" class="headerlink" title="BFC规范中的定义："></a>BFC规范中的定义：</h2>w3c规范对BFC的解释：</li>
<li>浮动元素和绝对定位元素， 不是块级盒子的块容器（ 如 inline - blocks, table - cells, 和 table - captions）， 以及设置了overflow属性（ 除了visible）的块级盒子， 都会为他们的内容创建新的BFC（ 块级格式上下文）。</li>
<li>在BFC中， 盒子从顶端开始垂直地 一个接一个地排列， 两个盒子之间的垂直的间隙是由他们的margin 值所决定的。 在一个BFC中， 两个相邻的块级盒子的</li>
<li>垂直外边距会产生折叠。 在BFC中， 每一个盒子的左外边缘（ margin - left） 会触碰到容器的左边缘(border - left)（ 对于从右到左的格式来说， 则触碰到右边缘）。</li>
</ul>
</li>
</ul>
<pre><code>    触发BFC的方法：

float 元素
position（ absolute， fixed）
display(table - cell， table - caption， inline - block)
overflow 除了visible 以外的值（ hidden， auto， scroll）
fieldset元素
早期IE的hasLayout会触发一个新的block formatting context
</code></pre><h3 id="BFC的特性"><a href="#BFC的特性" class="headerlink" title="BFC的特性"></a>BFC的特性</h3><ul>
<li>边缘不和浮动元素重叠</li>
<li>不存在collapsing margins问题</li>
<li>第一个特性特别有用， 因为元素触发了BFC的话， 就不会被float元素覆盖， 当子元素全部浮动的时候也能够正确地包含了<ul>
<li>第二个margin不会叠加的特性， 可以理解为两个处于普通流的盒子， 会有margin叠加的问题， 是因为他们属于相同的BFC， 当他自身创建了一个新的BFC时， 这个问题就不存在了<h3 id="BFC的常见应用"><a href="#BFC的常见应用" class="headerlink" title="BFC的常见应用"></a>BFC的常见应用</h3><ol>
<li>通过边缘不和浮动元素重叠的特性， 实现两栏结构。</li>
<li>清除元素内部浮动</li>
<li>解决合并外边距的问题</li>
</ol>
</li>
</ul>
</li>
</ul>
<hr>
<h2 id="常见的浏览器端的存储技术都有哪些，以及他们的优缺点和使用场景？"><a href="#常见的浏览器端的存储技术都有哪些，以及他们的优缺点和使用场景？" class="headerlink" title="常见的浏览器端的存储技术都有哪些，以及他们的优缺点和使用场景？"></a>常见的浏览器端的存储技术都有哪些，以及他们的优缺点和使用场景？</h2><p>有时需要将网页中的一些数据保存在浏览器端，这样做的好处是，当下次访问页面时，不需要再次向服务器请求数据，直接就可以从本地读取数据。目前常用的有以下几种方法：</p>
<h3 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a><strong>cookie</strong></h3><p>cookie会随着每次HTTP请求头信息一起发送，无形中增加了网络流量，另外，cookie能存储的数据容量有限，根据浏览器类型不同而不同，IE6大约只能存储2K，cookie数据大小不能超过4k</p>
<h3 id="Flash-ShareObject"><a href="#Flash-ShareObject" class="headerlink" title="Flash ShareObject"></a><strong>Flash ShareObject</strong></h3><p>这种方式能能解决上面提到的cookie存储的两个弊端，而且能够跨浏览器，应该说是目前最好的本地存储方案。不过，需要在页面中插入一个Flash，当浏览器没有安装Flash控件时就不能用了。所幸的是，没有安装Flash的用户极少。<br>缺点：需要安装Flash插件。</p>
<h3 id="sessionStorage"><a href="#sessionStorage" class="headerlink" title="sessionStorage"></a><strong>sessionStorage</strong></h3><p>使用于Firefox2+的火狐浏览器，用这种方式存储的数据仅窗口级别有效，同一个窗口（或者Tab）页面刷新或者跳转，都能获取到本地存储的数据，当新开窗口或者页面时，原来的数据就失效了。<br>缺点：IE不支持、不能实现数据的持久保存。</p>
<h3 id="localStorage"><a href="#localStorage" class="headerlink" title="localStorage"></a><strong>localStorage</strong></h3><p>localStorage是Web Storage互联网存储规范中的一部分，现在在Firefox 3.5、Safari 4和IE8中得到支持。<br>缺点：低版本浏览器不支持。</p>
<p>提示：localStorage储存的值都是字符串类型，使用时要注意。另外，可以在浏览器调试器中的Resources的localStorage中看到储存的信息。</p>
<blockquote>
<p>//存储信息   （存储的信息名称，要存储的字符串）<br>localStorage.setItem(“CC_email_list”,input_eamil[i])<br>//读取信息   （要读取的信息名称）<br>localStorage.getItem(“CC_email_list”)<br>//清除信息    （要清除的信息名称）<br>localStorage.removeItem(“CC_email_list”);</p>
</blockquote>
<h3 id="globalStorage"><a href="#globalStorage" class="headerlink" title="globalStorage"></a><strong>globalStorage</strong></h3><p>使用于Firefox2+的火狐浏览器，类似于IE的userData。<br>1 //赋值 2 globalStorage[location.hostname][‘name’] = ‘tugai’; 3 //读取 4 globalStorage[location.hostname][‘name’]; 5 //删除 6 globalStorage[location.hostname].removeItem(‘name’);</p>
<h3 id="Google-Gear"><a href="#Google-Gear" class="headerlink" title="Google Gear"></a><strong>Google Gear</strong></h3><p>Google开发出的一种本地存储技术。<br>缺点：需要安装Gear组件。</p>
<h3 id="userData"><a href="#userData" class="headerlink" title="userData"></a><strong>userData</strong></h3><p>IE浏览器可以使用userData来存储数据，容量可达到640K，这种方案是很可靠的，不需要安装额外的插件。缺点：它仅在IE下有效。<br>缺点：IE不支持。</p>
<p>结论：Flash shareobject是不错的选择，如果你不想在页面上嵌入Flash，可以结合使用userData(IE6+)和globalStorage(Firefox2+)和localStorage(chrome3+)实现跨浏览器。</p>
<hr>
<h2 id="请描述一下-cookies，sessionStorage-和-localStorage-的区别？"><a href="#请描述一下-cookies，sessionStorage-和-localStorage-的区别？" class="headerlink" title="请描述一下 cookies，sessionStorage 和 localStorage 的区别？"></a>请描述一下 cookies，sessionStorage 和 localStorage 的区别？</h2><pre><code>cookie是网站为了标示用户身份而储存在用户本地终端（Client Side）上的数据（通常经过加密）。
cookie数据始终在同源的http请求中携带（即使不需要），记会在浏览器和服务器间来回传递。
sessionStorage和localStorage不会自动把数据发给服务器，仅在本地保存。
</code></pre><h3 id="存储大小："><a href="#存储大小：" class="headerlink" title="存储大小："></a>存储大小：</h3><pre><code>cookie数据大小不能超过4k。
sessionStorage和localStorage 虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大。
</code></pre><h3 id="有期时间："><a href="#有期时间：" class="headerlink" title="有期时间："></a>有期时间：</h3><pre><code>localStorage    存储持久数据，浏览器关闭后数据不丢失除非主动删除数据；
sessionStorage  数据在当前浏览器窗口关闭后自动删除。
cookie          设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭
</code></pre><hr>
<h2 id="html-获取页面，浏览器，屏幕宽高"><a href="#html-获取页面，浏览器，屏幕宽高" class="headerlink" title="html 获取页面，浏览器，屏幕宽高"></a>html 获取页面，浏览器，屏幕宽高</h2><p>一个页面的展示，从外到内的容器为：屏幕-&gt;浏览器-&gt;页面本身。<br>HTML元素展现在页面内-&gt;页面展现在浏览器内-&gt;而浏览器展现在屏幕内。<br>通过Js的一些对象可以获取这些容器的高度、宽度。<br>1：总</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2377897-c6dff4f74e7f2eb3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<p>2:屏幕<br><img src="http://upload-images.jianshu.io/upload_images/2377897-f47a188d60bd97a4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"><br>3:浏览器</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2377897-8e3d9af0d6d264b0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/2377897-5e416993bde1fdb7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<p>5:可视区<br>定义：可视区域是指能显示网页内容区域的宽高。<br>拉动控制台的时候网页可视区域的宽高也会随之改变。<br>可视区宽高跟内容宽高没关系。</p>
<p>如果内容超过可视区域的高度或者宽度就出现滚动条。要获取可视区域的宽高每个浏览器的获取方法不一样</p>
<p><a href="http://www.cnblogs.com/polk6/p/5051935.html" target="_blank" rel="external">参照</a></p>
<hr>
<h2 id="Doctype"><a href="#Doctype" class="headerlink" title="Doctype"></a>Doctype</h2><p>1.Doctype作用<br>位置：&lt;!DOCTYPE&gt;声明位于html第一行<br>作用： 告知浏览器用什么标准解析html文档<br>            &lt;!DOCTYPE&gt;不存在，或者格式不正确，会导致文档以兼容模 (怪异模式)式出现</p>
<p>语法：<br>      HTML 顶级元素 可用性 “注册//组织//类型 标签//定义 语言””URL”<br>&lt;!DOCTYPE HTML PUBLIC “-//W3C//DTD HTML 4.0//EN”&gt;<br>&lt;!DOCTYPE HTML PUBLIC “-//W3C//DTD HTML 4.0 Strict//EN”&gt;</p>
<p>其中，DTD的是W3C所发布的一个文档类型定义，简单的说，就是告诉浏览器你的这个HTML，是根据那个标准写的，解析的时候用哪个标准解析。</p>
<p><a href="http://www.qdfuns.com/notes/21146/12ba5b538dd5974b1bee88f77c71b0a0.html" target="_blank" rel="external">http://www.qdfuns.com/notes/21146/12ba5b538dd5974b1bee88f77c71b0a0.html</a></p>
<hr>
<p>##为什么HTML5就只要写&lt;!DOCTYPE HTML&gt;?<br>HTML 4.01 中的 doctype 需要对 DTD 进行引用，因为 HTML 4.01 基于 SGML。 HTML 5 不基于 SGML，因此不需要对 DTD 进行引用，但是需要 doctype 来规范浏览器的行为。<br>其中，SGML是标准通用标记语言,简单的说，就是比HTML,XML更老的标准，这两者都是由SGML发展而来的。BUT，HTML5不是的。</p>
<hr>
<h2 id="标准模式与兼容模式（怪异模式）各有什么区别"><a href="#标准模式与兼容模式（怪异模式）各有什么区别" class="headerlink" title="标准模式与兼容模式（怪异模式）各有什么区别?"></a>标准模式与兼容模式（怪异模式）各有什么区别?</h2><p>A：在标准模式中，浏览器根据规范呈现页面；在混杂模式中，页面以一种比较宽松向后兼容的方式显示。简单的说，就是尽可能的显示能显示的东西给用户看。（但是会有些样式失效）</p>
<p>1：width不同<br>在严格模式中 ：width是内容宽度 ，元素真正的宽度 = width+（padding+border+margin）2<br>在兼容模式中 ：width则是元素的实际宽度 ，内容宽度 = width - ( padding2+border2)</p>
<p>2.兼容模式下可设置百分比的高度和行内元素的高宽<br>    在Standards模式下，给span等行内元素设置wdith和height都不会生效，而在兼容模式下，则会生效。<br>    在standards模式下，一个元素的高度是由其包含的内容来决定的，如果父元素没有设置高度，子元素设置一个百分比的高度是无效的。</p>
<p>3.用margin:0 auto设置水平居中在IE下会失效<br>    使用margin:0 auto在standards模式下可以使元素水平居中，但在兼容模式下却会失效（用text-align属性解决）<br>    body{text-align:center};#content{text-align:left}</p>
<p>4.兼容模式下Table中的字体属性不能继承上层的设置，white-space:pre会失效，设置图片的padding会失效</p>
<hr>
<h2 id="介绍一下你对浏览器内核的理解？"><a href="#介绍一下你对浏览器内核的理解？" class="headerlink" title="介绍一下你对浏览器内核的理解？"></a>介绍一下你对浏览器内核的理解？</h2><p>主要分成两部分：渲染引擎(layout engineer或Rendering Engine)和JS引擎。<br>  渲染引擎：负责取得网页的内容（HTML、XML、图像等等）、整理讯息（例如加入CSS等），以及计算网页的显示方式，然后会输出至显示器或打印机。浏览器的内核的不同对于网页的语法解释会有不同，所以渲染的效果也不相同。所有网页浏览器、电子邮件客户端以及其它需要编辑、显示网络内容的应用程序都需要内核。</p>
<p>JS引擎则：解析和执行javascript来实现网页的动态效果。</p>
<hr>
<p>常见的浏览器内核有哪些？<br> Trident内核：IE,MaxThon,TT,The World,360,搜狗浏览器等。[又称MSHTML]<br>  Gecko内核：Netscape6及以上版本，FF,MozillaSuite/SeaMonkey等<br>  Presto内核：Opera7及以上。      [Opera内核原为：Presto，现为：Blink;]<br>  Webkit内核：Safari,Chrome等。   [ Chrome的：Blink（WebKit的分支）]</p>
<hr>
<h2 id="HTML、XML、XHTML-有什么区别？"><a href="#HTML、XML、XHTML-有什么区别？" class="headerlink" title="HTML、XML、XHTML 有什么区别？"></a>HTML、XML、XHTML 有什么区别？</h2><p>HTML是被设计用来显示数据的，重点是:显示数据以及如何显示数据更好上面。<br>XML是被设计用来描述数据的，重点是:什么是数据，如何存放数据。<br>XHTML基于HTML的基础上进行了扩展和规范，让XHTML更加严格，主要目的是促进HTML向XML过渡。</p>
<p>HTML的弊端：<br>编码不规范，结构混乱臃肿，需要智能的终端才能很好的显示；<br>表现和结构混乱，不利于开发和维护；<br>不能使用于更多的网络设备中，比如手机；<br>为了让HTML逐渐过渡到XML阶段，w3c又定制了XHTML标准。</p>
<p>而XML的弊端也不少：<br>在数据中寻找信息非常难<br>大数据量效率低<br>使用XML传输数据时没有数据库系统那样的信息管理功能<br>因此XML因为自身严苛限制等因素逐渐被HTML5取代。</p>
<hr>
<h2 id="怎样理解-HTML-语义化？"><a href="#怎样理解-HTML-语义化？" class="headerlink" title="怎样理解 HTML 语义化？"></a>怎样理解 HTML 语义化？</h2><p>HTML语义化能提高网页语义的清晰度，方便爬虫工具识别网站内容，爬虫工具在识别网站内容时不会受到网站样式的影响，只会关注网站内容本身<br>HTML的语义化能够提高团队对网站的维护和改进效率<br>改善网页的可访问性，遇到视觉障碍用户时屏幕阅读器能够更好的系别网页内容</p>
<hr>
<h2 id="怎样理解内容与样式分离的原则"><a href="#怎样理解内容与样式分离的原则" class="headerlink" title="怎样理解内容与样式分离的原则"></a>怎样理解内容与样式分离的原则</h2><p>在 Web 开发中，所谓内容与样式分离，就是让内容的归 HTML, 样式归 CSS, 不要混着用。<br>样式单独抽离出来,代码会得到精简和重用，后期的维护会变得非常简单。我只用写一个 class 的样式，就可以同时更改多个有相同 class 的元素的样式；只用一个 css 文件，就可以同时链接到多个 HTML 页面上。</p>
<hr>
<h2 id="title与h1的区别、b与strong的区别、i与em的区别？"><a href="#title与h1的区别、b与strong的区别、i与em的区别？" class="headerlink" title="title与h1的区别、b与strong的区别、i与em的区别？"></a>title与h1的区别、b与strong的区别、i与em的区别？</h2><p> title属性没有明确意义只表示是个标题，H1则表示层次明确的标题，对页面信息的抓取也有很大的影响；</p>
<p>  strong是标明重点内容，有语气加强的含义，使用阅读设备阅读网络时：<strong>会重读，而<b>是展示强调内容。</b></strong></p>
<p>  i内容展示为斜体，em表示强调的文本；</p>
<p>  Physical Style Elements – 自然样式标签<br>  b, i, u, s, pre<br>  Semantic Style Elements – 语义样式标签<br>  strong, em, ins, del, code<br>  应该准确使用语义样式标签, 但不能滥用, 如果不能确定时首选使用自然样式标签。</p>
<hr>
<h2 id="页面可见性（Page-Visibility-API）-可以有哪些用途？"><a href="#页面可见性（Page-Visibility-API）-可以有哪些用途？" class="headerlink" title="页面可见性（Page Visibility API） 可以有哪些用途？"></a>页面可见性（Page Visibility API） 可以有哪些用途？</h2><p>  通过 visibilityState 的值检测页面当前是否可见，以及打开网页的时间等;<br>  在页面被切换到其他后台进程的时候，自动暂停音乐或视频的播放；</p>
<hr>
<h2 id="iframe有那些缺点？"><a href="#iframe有那些缺点？" class="headerlink" title="iframe有那些缺点？"></a>iframe有那些缺点？</h2><ul>
<li>iframe会阻塞主页面的Onload事件；</li>
<li><p>搜索引擎的检索程序无法解读这种页面，不利于SEO;</p>
</li>
<li><p>iframe和主页面共享连接池，而浏览器对相同域的连接有限制，所以会影响页面的并行加载。</p>
<p>使用iframe之前需要考虑这两个缺点。如果需要使用iframe，最好是通过javascript<br>动态给iframe添加src属性值，这样可以绕开以上两个问题。</p>
</li>
</ul>
<hr>
<h2 id="为什么要初始化CSS样式。"><a href="#为什么要初始化CSS样式。" class="headerlink" title="为什么要初始化CSS样式。"></a>为什么要初始化CSS样式。</h2><ul>
<li><p>因为浏览器的兼容问题，不同浏览器对有些标签的默认值是不同的，如果没对CSS初始化往往会出现浏览器之间的页面显示差异。</p>
<ul>
<li>当然，初始化样式会对SEO有一定的影响，但鱼和熊掌不可兼得，但力求影响最小的情况下初始化。<br>淘宝的样式初始化代码：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">body, h1, h2, h3, h4, h5, h6, hr, p, blockquote, dl, dt, dd, ul, ol, li, pre, form, fieldset, legend, button, input, textarea, th, td &#123; margin:0; padding:0; &#125;</span><br><span class="line">body, button, input, select, textarea &#123; font:12px/1.5tahoma, arial, \5b8b\4f53; &#125;</span><br><span class="line">h1, h2, h3, h4, h5, h6&#123; font-size:100%; &#125;</span><br><span class="line">address, cite, dfn, em, var &#123; font-style:normal; &#125;</span><br><span class="line">code, kbd, pre, samp &#123; font-family:couriernew, courier, monospace; &#125;</span><br><span class="line">small&#123; font-size:12px; &#125;</span><br><span class="line">ul, ol &#123; list-style:none; &#125;</span><br><span class="line">a &#123; text-decoration:none; &#125;</span><br><span class="line">a:hover &#123; text-decoration:underline; &#125;</span><br><span class="line">sup &#123; vertical-align:text-top; &#125;</span><br><span class="line">sub&#123; vertical-align:text-bottom; &#125;</span><br><span class="line">legend &#123; color:#000; &#125;</span><br><span class="line">fieldset, img &#123; border:0; &#125;</span><br><span class="line">button, input, select, textarea &#123; font-size:100%; &#125;</span><br><span class="line">table &#123; border-collapse:collapse; border-spacing:0; &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h2 id="用纯CSS创建一个三角形的原理是什么？"><a href="#用纯CSS创建一个三角形的原理是什么？" class="headerlink" title="用纯CSS创建一个三角形的原理是什么？"></a>用纯CSS创建一个三角形的原理是什么？</h2><p> 把上、左、右三条边隐藏掉（颜色设为 transparent）</p>
<blockquote>
<p> #demo {<br>    width: 0;<br>    height: 0;<br>    border-width: 20px;<br>    border-style: solid;<br>    border-color: transparent transparent red transparent;<br>  }</p>
<hr>
<h2 id="经常遇到的浏览器的兼容性有哪些？原因，解决方法是什么，常用hack的技巧-？"><a href="#经常遇到的浏览器的兼容性有哪些？原因，解决方法是什么，常用hack的技巧-？" class="headerlink" title="经常遇到的浏览器的兼容性有哪些？原因，解决方法是什么，常用hack的技巧 ？"></a>经常遇到的浏览器的兼容性有哪些？原因，解决方法是什么，常用hack的技巧 ？</h2><ul>
<li>png24位的图片在iE6浏览器上出现背景，解决方案是做成PNG8.</li>
</ul>
</blockquote>
<ul>
<li><p>浏览器默认的margin和padding不同。解决方案是加一个全局的*{margin:0;padding:0;}来统一。</p>
</li>
<li><p>IE6双边距bug:块属性标签float后，又有横行的margin情况下，在ie6显示margin比设置的大。</p>
<p>浮动ie产生的双倍距离 #box{ float:left; width:10px; margin:0 0 0 100px;}</p>
<p>这种情况之下IE会产生20px的距离，解决方案是在float的标签样式控制中加入 ——<em>display:inline;将其转化为行内属性。(</em>这个符号只有ie6会识别)</p>
<p>渐进识别的方式，从总体中逐渐排除局部。</p>
<p>首先，巧妙的使用“\9”这一标记，将IE游览器从所有情况中分离出来。<br>接着，再次使用“+”将IE8和IE7、IE6分离开来，这样IE8已经独立识别。</p>
<p>css</p>
<pre><code>.bb{
    background-color:red;/*所有识别*/
    background-color:#00deff\9; /*IE6、7、8识别*/
    +background-color:#a200ff;/*IE6、7识别*/
    _background-color:#1e0bd1;/*IE6识别*/
}
</code></pre></li>
</ul>
<ul>
<li><p>IE下,可以使用获取常规属性的方法来获取自定义属性,<br>也可以使用getAttribute()获取自定义属性;<br>Firefox下,只能使用getAttribute()获取自定义属性。<br>解决方法:统一通过getAttribute()获取自定义属性。</p>
</li>
<li><p>IE下,even对象有x,y属性,但是没有pageX,pageY属性;<br>Firefox下,event对象有pageX,pageY属性,但是没有x,y属性。</p>
</li>
<li><p>解决方法：（条件注释）缺点是在IE浏览器下可能会增加额外的HTTP请求数。</p>
</li>
<li><p>Chrome 中文界面下默认会将小于 12px 的文本强制按照 12px 显示,<br>可通过加入 CSS 属性 -webkit-text-size-adjust: none; 解决。</p>
<p>超链接访问过后hover样式就不出现了 被点击访问过的超链接样式不在具有hover和active了解决方法是改变CSS属性的排列顺序:<br>L-V-H-A :  a:link {} a:visited {} a:hover {} a:active {}</p>
</li>
</ul>
<hr>
<h2 id="什么是外边距合并？"><a href="#什么是外边距合并？" class="headerlink" title="什么是外边距合并？"></a>什么是外边距合并？</h2><p>外边距合并指的是，当两个垂直外边距相遇时，它们将形成一个外边距。<br>  合并后的外边距的高度等于两个发生合并的外边距的高度中的较大者。<br>  w3school介绍网址： <a href="http://www.w3school.com.cn/css/css_margin_collapsing.asp" target="_blank" rel="external">http://www.w3school.com.cn/css/css_margin_collapsing.asp</a></p>
<hr>
<h2 id="zoom-1的清除浮动原理"><a href="#zoom-1的清除浮动原理" class="headerlink" title="zoom:1的清除浮动原理?"></a>zoom:1的清除浮动原理?</h2><p>清除浮动，触发hasLayout；<br>  Zoom属性是IE浏览器的专有属性，它可以设置或检索对象的缩放比例。解决ie下比较奇葩的bug。<br>  譬如外边距（margin）的重叠，浮动清除，触发ie的haslayout属性等。</p>
<p>  来龙去脉大概如下：<br>  当设置了zoom的值之后，所设置的元素就会就会扩大或者缩小，高度宽度就会重新计算了，这里一旦改变zoom值时其实也会发生重新渲染，运用这个原理，也就解决了ie下子元素浮动时候父元素不随着自动扩大的问题。</p>
<p>  Zoom属是IE浏览器的专有属性，火狐和老版本的webkit核心的浏览器都不支持这个属性。然而，zoom现在已经被逐步标准化，出现在 CSS 3.0 规范草案中。</p>
<p>  目前非ie由于不支持这个属性，它们又是通过什么属性来实现元素的缩放呢？<br>  可以通过css3里面的动画属性scale进行缩放。 </p>
<hr>
<h2 id="如何居中div？"><a href="#如何居中div？" class="headerlink" title="如何居中div？"></a>如何居中div？</h2><p>水平居中：给div设置一个宽度，然后添加margin:0 auto属性</p>
<p> div{<br>     width:200px;<br>     margin:0 auto;<br>  }<br>让绝对定位的div居中</p>
<p> div {<br>     position: absolute;<br>     width: 300px;<br>     height: 300px;<br>     margin: auto;<br>     top: 0;<br>     left: 0;<br>     bottom: 0;<br>     right: 0;<br>     background-color: pink;    /<em> 方便看效果 </em>/<br> }<br>水平垂直居中一</p>
<p> 确定容器的宽高 宽500 高 300 的层<br> 设置层的外边距</p>
<p> div {<br>     position: relative;        /<em> 相对定位或绝对定位均可 </em>/<br>     width:500px;<br>     height:300px;<br>     top: 50%;<br>     left: 50%;<br>     margin: -150px 0 0 -250px;         /<em> 外边距为自身宽高的一半 </em>/<br>     background-color: pink;         /<em> 方便看效果 </em>/</p>
<p>  }<br>水平垂直居中二</p>
<p> 未知容器的宽高，利用 <code>transform</code> 属性</p>
<p> div {<br>     position: absolute;        /<em> 相对定位或绝对定位均可 </em>/<br>     width:500px;<br>     height:300px;<br>     top: 50%;<br>     left: 50%;<br>     transform: translate(-50%, -50%);<br>     background-color: pink;         /<em> 方便看效果 </em>/</p>
<p> }<br>水平垂直居中三</p>
<p> 利用 flex 布局<br> 实际使用时应考虑兼容性</p>
<p> .container {<br>     display: flex;<br>     align-items: center;         /<em> 垂直居中 </em>/<br>     justify-content: center;    /<em> 水平居中 </em>/</p>
<p> }<br> .container div {<br>     width: 100px;<br>     height: 100px;<br>     background-color: pink;        /<em> 方便看效果 </em>/<br> }  </p>
<hr>
<h2 id="position的值relative和absolute定位原点是？"><a href="#position的值relative和absolute定位原点是？" class="headerlink" title="position的值relative和absolute定位原点是？"></a>position的值relative和absolute定位原点是？</h2><pre><code>absolute
  生成绝对定位的元素，相对于值不为 static的第一个父元素进行定位。
fixed （老IE不支持）
  生成绝对定位的元素，相对于浏览器窗口进行定位。
relative
  生成相对定位的元素，相对于其正常位置进行定位。
static
  默认值。没有定位，元素出现在正常的流中（忽略 top, bottom, left, right z-index 声明）。
inherit
  规定从父元素继承 position 属性的值。
</code></pre><hr>
<h1 id="HTML5"><a href="#HTML5" class="headerlink" title="HTML5"></a>HTML5</h1><h2 id="新特性"><a href="#新特性" class="headerlink" title="新特性"></a>新特性</h2><h3 id="1-标签语义化，"><a href="#1-标签语义化，" class="headerlink" title="1:标签语义化，"></a>1:标签语义化，</h3><p>比如header，footer，nav，aside，article，section等，新增了很多表单元素，入email，url等，除去了center等样式标签，还有除去了有性能问题的frame，frameset等标签</p>
<h3 id="2、音视频元素，"><a href="#2、音视频元素，" class="headerlink" title="2、音视频元素，"></a>2、音视频元素，</h3><p>video，audio的增加使得我们不需要在依赖外部的插件就可以往网页中加入音视频元素。</p>
<h3 id="3、新增很多api，"><a href="#3、新增很多api，" class="headerlink" title="3、新增很多api，"></a>3、新增很多api，</h3><p>比如获取用户地理位置的window.navigator.geoloaction</p>
<h3 id="、websocket"><a href="#、websocket" class="headerlink" title="、websocket"></a>、websocket</h3><p>websocket是伴随html5到来的基于tcp/ip的全双工通信的协议。<br>主要通信过程：先借http完成握手，达到了长连接<br>第一步：浏览器基于tcp，发送http请求<br>第二步：服务器端，接收到请求后。将 tcp用户网络层协议变为websocket协议，完成了握手<br>第三步：服务器端和浏览器完成握手，他们之间形成一条通道，可以源源不断的传送信息<br>websocket是一种协议，可以让我们建立客户端到服务器端的全双工通信，这就意味着服务器端可以主动推送数据到客户端。</p>
<hr>
<h3 id="、HTML5-能够本地存储数据，在之前都是使用-cookies-使用的。"><a href="#、HTML5-能够本地存储数据，在之前都是使用-cookies-使用的。" class="headerlink" title="、HTML5 能够本地存储数据，在之前都是使用 cookies 使用的。"></a>、HTML5 能够本地存储数据，在之前都是使用 cookies 使用的。</h3><p>HTML5 提供了下面本地存储方案：webstorage包括localeStorage和sessionStorage，localeStorage是持久化存储在客户端，只要用户不主动删除，就不会消失，sessionStorage也是存储在客户端，但是他的存在时间是一个回话，一旦浏览器的关于该回话的页面关闭了，sessionStorage就消失了，</p>
<hr>
<h3 id="：请描述一下-cookies，sessionStorage-和-localStorage-的区别？"><a href="#：请描述一下-cookies，sessionStorage-和-localStorage-的区别？" class="headerlink" title="：请描述一下 cookies，sessionStorage 和 localStorage 的区别？"></a>：请描述一下 cookies，sessionStorage 和 localStorage 的区别？</h3><p>  cookie是网站为了标示用户身份而储存在客户端上的数据（通常经过加密）。<br>  cookie数据始终在同源的http请求中携带（即使不需要），记会在浏览器和服务器间来回传递。<br>  sessionStorage和localStorage不会自动把数据发给服务器，仅在本地保存。</p>
<p>  存储大小：<br>      cookie数据大小不能超过4k。<br>      sessionStorage和localStorage 虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大。</p>
<p>  有期时间：<br>      localStorage    存储持久数据，浏览器关闭后数据不丢失除非主动删除数据；<br>      sessionStorage  数据在当前浏览器窗口关闭后自动删除。<br>      cookie  在过期时间之前一直有效，即使窗口或浏览器关闭</p>
<hr>
<h3 id="、应用程序缓存："><a href="#、应用程序缓存：" class="headerlink" title="、应用程序缓存："></a>、应用程序缓存：</h3><p>在用户没有与因特网连接时，可以正常访问站点或应用，在用户与因特网连接时，更新用户机器上的缓存文件。<br>  原理：HTML5的离线存储是基于一个新建的.appcache文件的缓存机制(不是存储技术)，通过这个文件上的解析清单离线存储资源，这些资源就会像cookie一样被存储了下来。之后当网络在处于离线状态下时，浏览器会通过被离线存储的数据进行页面展示。</p>
<p>html5允许我们自己控制哪些文件需要缓存，哪些不需要，具体的做法如下：</p>
<p>1、首先给html添加manifest属性，并赋值为cache.manifest<br>2、cache.manifest的内容为:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">  CACHE MANIFEST</span><br><span class="line">  #v1.2</span><br><span class="line">  CACHE :           //表示需要缓存的文件</span><br><span class="line">    a.js</span><br><span class="line">    b.js</span><br><span class="line">NETWORK:    //表示只在用户在线的时候才需要的文件，不会缓存</span><br><span class="line">  c.js</span><br><span class="line">FALLBACK</span><br><span class="line">/        /index.html     //表示如果找不到第一个资源就用第二个资源代替</span><br></pre></td></tr></table></figure></p>
<hr>
<h3 id="、web-worker，web-worker"><a href="#、web-worker，web-worker" class="headerlink" title="、web worker，web worker"></a>、web worker，web worker</h3><p>是运行在浏览器后台的js程序，他不影响主程序的运行，是另开的一个js线程，可以用这个线程执行复杂的数据操作，然后把操作结果通过postMessage传递给主线程，这样在进行复杂且耗时的操作时就不会阻塞主线程了。</p>
<hr>
<h1 id="CSS3"><a href="#CSS3" class="headerlink" title="CSS3"></a>CSS3</h1><h2 id="css3的新特性哪些，你都用过哪些-5"><a href="#css3的新特性哪些，你都用过哪些-5" class="headerlink" title="css3的新特性哪些，你都用过哪些 5%"></a>css3的新特性哪些，你都用过哪些 5%</h2><p>CSS3有哪些新内容，请至少说出5个。</p>
<p>   1）border-radius。CSS3圆角表格</p>
<p>   2）font-effect。以往对网页上的文字加特效只能用filter属性，但是在CSS3中专门制定了一个加文字特效的属性，而且不止加阴影这种效果。</p>
<p>   3）text-underline-style，text-underline-color，text-underline-mode，text-underline-position。丰富了对链接下划线的样式，以往的下划线都是直线，这次可不一样了，有波浪线、点线、虚线等等，更可对下划线的颜色和<br>位置进行任意改变，哈哈~~下划线的世界从此不再单一。（还有对应顶线和中横线的样式，效果与下划线类似）</p>
<p>   4）font-emphasize-style和font-emphasize-position。我们在做笔记时经常要在文字下点几个点或打个圈什么的，以示重点，CSS3也开始加入了这项功能，这应该在某些特定网页上很有用。</p>
<p>   5）Font-face可以用来加载字体样式，而且它还能够加载服务器端的字体文件，显示客户端没有安装的字体。</p>
<hr>
<h2 id="媒体查询具体到语句-5"><a href="#媒体查询具体到语句-5" class="headerlink" title="媒体查询具体到语句 5%"></a>媒体查询具体到语句 5%</h2><p>作用：媒体查询可以让我们根据设备显示器的特性（如视口宽度、屏幕比例、设备方向：横向或纵向）为其设定CSS样式，检测的媒体特性有 width 、 height 和 color （等）。</p>
<h2 id="响应式布局meta-scale-怎样使用media"><a href="#响应式布局meta-scale-怎样使用media" class="headerlink" title="响应式布局meta,scale 怎样使用media?"></a>响应式布局meta,scale 怎样使用media?</h2><h3 id="meta-scale"><a href="#meta-scale" class="headerlink" title="meta,scale"></a>meta,scale</h3><p>第一步：<br> 首先需要在html文档中添加以下代码，用来兼容移动设备的显示效果</p>
<p>&lt;meta name=”viewport content=”width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no”/&gt;</p>
<p>ps:</p>
<blockquote>
<p>width=device-width:宽度等于当前设备的宽度<br>initial-scale=1：初始的缩放比例（默认为1）<br>maximum-scale=1：允许用户缩放到得最大比例（默认为1）<br>user-scalable=no：用户不能手动缩放</p>
</blockquote>
<h3 id="第二步：媒体查询-语句"><a href="#第二步：媒体查询-语句" class="headerlink" title="第二步：媒体查询 语句"></a>第二步：媒体查询 语句</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@media screen and (max-width:720px) and (min-width:320px)&#123;</span><br><span class="line"></span><br><span class="line">      body&#123;</span><br><span class="line"></span><br><span class="line">       background-color:red;</span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">@media screen and (max-width:320px)&#123;</span><br><span class="line"></span><br><span class="line">      body&#123;</span><br><span class="line"></span><br><span class="line">         background-color:blue;</span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="css-伪类-5"><a href="#css-伪类-5" class="headerlink" title="css 伪类 5%"></a>css 伪类 5%</h2><h3 id="伪类选择器"><a href="#伪类选择器" class="headerlink" title="伪类选择器"></a>伪类选择器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">p:first-of-type	选择属于其父元素的首个 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。</span><br><span class="line">p:last-of-type	选择属于其父元素的最后 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。</span><br><span class="line">p:only-of-type	选择属于其父元素唯一的 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。</span><br><span class="line">p:only-child		选择属于其父元素的唯一子元素的每个 &lt;p&gt; 元素。</span><br><span class="line">p:nth-child(2)	选择属于其父元素的第二个子元素的每个 &lt;p&gt; 元素。</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="伪类-伪元素-1"><a href="#伪类-伪元素-1" class="headerlink" title="伪类 伪元素"></a>伪类 伪元素</h3><p>伪类是给元素模拟添加类 ，来实现某种效果（：）<br>常见伪类：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2377897-394530a71e54ed9f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<p>伪元素是模拟添加个元素来实现效果（::）(css3出现后做的区分)<br>常见伪元素：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2377897-e655b83124da94d9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<p><a href="http://web.jobbole.com/86181/" target="_blank" rel="external">http://web.jobbole.com/86181/</a></p>
<h2 id="说一下flex-3"><a href="#说一下flex-3" class="headerlink" title="说一下flex 3%"></a>说一下flex 3%</h2><h3 id="请解释一下CSS3的Flexbox（弹性盒布局模型）-以及适用场景？"><a href="#请解释一下CSS3的Flexbox（弹性盒布局模型）-以及适用场景？" class="headerlink" title="请解释一下CSS3的Flexbox（弹性盒布局模型）,以及适用场景？"></a>请解释一下CSS3的Flexbox（弹性盒布局模型）,以及适用场景？</h3><p> 一个用于页面布局的全新CSS3功能，Flexbox可以把列表放在同一个方向（从上到下排列，从左到右），并让列表能延伸到占用可用的空间。<br>   较为复杂的布局还可以通过嵌套一个伸缩容器（flex container）来实现。<br>   采用Flex布局的元素，称为Flex容器（flex container），简称”容器”。<br>   它的所有子元素自动成为容器成员，称为Flex项目（flex item），简称”项目”。<br>   常规布局是基于块和内联流方向，而Flex布局是基于flex-flow流可以很方便的用来做局中，能对不同屏幕大小自适应。<br>   在布局上有了比以前更加灵活的空间<br><a href="http://www.w3cplus.com/css3/flexbox-basics.html" target="_blank" rel="external">http://www.w3cplus.com/css3/flexbox-basics.html</a></p>
<hr>
<h2 id="动画-2"><a href="#动画-2" class="headerlink" title="动画 2%"></a>动画 2%</h2><p>  二维动画——animation  这个属性必须配合@keyframes动画关键帧来使用。keyframes里面包含一个百分数，后面跟上在这段时间内变换的css样式。<br>     animation是一个复合属性，它包括以下几个组成部分：</p>
<ul>
<li>1.animation-name：执行动画的keyframes的名字。<ul>
<li>2.animation-duration：执行动画的总时长。</li>
<li>3.animation-timing-function：指定过渡函数。</li>
<li>4.animation-delay：执行延迟时间。</li>
<li>5.animation-direction：动画播放的方式。这个属性的值主要有：normal正常播放模式、reverse倒序播放、alternate<pre><code>动画在奇数次正向播放偶数次倒序播放、alternate-reverse动画在奇数次倒序播放偶数次正向播放。
</code></pre></li>
<li>6.animation-iteration-count：动画执行的次数。infinite是无限次，写一个数字就是要执行几次。<ul>
<li>7.animation-fill-mode：执行完动画后物体停止的位置。forwards是停在结束的位置上、backwards是快速执行初始帧<pre><code>（这个最好配合延迟来观察）、
none是回到初始帧的位置、both是同时具有forwards和backwards的效果。
</code></pre></li>
<li>8.animation-play-state：控制动画的播放状态。running是播放、paused是暂停。</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h2 id="css3动画卡了"><a href="#css3动画卡了" class="headerlink" title="css3动画卡了"></a>css3动画卡了</h2><pre><code>transform: transition3d(0, 0, 0);
transform: translateZ(0);
这两个属性可以开启GPU加速模式
然而面试官问我为什么，你知道原理么？
这两个属性都会开启GPU硬件加速模式，从而让浏览器在渲染动画的时候从CPU转向GPU。
</code></pre><hr>
<h1 id="JS"><a href="#JS" class="headerlink" title="JS"></a>JS</h1><h2 id="js数据类型有哪些-5"><a href="#js数据类型有哪些-5" class="headerlink" title="js数据类型有哪些 5%"></a>js数据类型有哪些 5%</h2><p>数据类型分为：简单数据类型和引用<br> (五大)简单数据类型 ：数字 ，字符串 ， 布尔值(true/false)， null，undifined<br>引用：数组，函数，正则表达式，对象</p>
<hr>
<h2 id="null-和undefined"><a href="#null-和undefined" class="headerlink" title="null 和undefined"></a>null 和undefined</h2><p><a href="http://www.ruanyifeng.com/blog/2014/03/undefined-vs-null.html" target="_blank" rel="external">http://www.ruanyifeng.com/blog/2014/03/undefined-vs-null.html</a></p>
<ul>
<li>相似性：<ul>
<li>undefined和null在if语句中，都会被自动转为false<ul>
<li>undefined == null // true</li>
</ul>
</li>
</ul>
</li>
<li>null：<ul>
<li>null表示”没有对象”，即该处不应该有值</li>
<li>用法：<ul>
<li>原型链的终点</li>
<li>作为函数的参数，表示该函数的参数不是对象</li>
</ul>
</li>
</ul>
</li>
<li>undefined<ul>
<li>undefined表示”缺少值”，就是此处应该有一个值，但是还没有定义</li>
<li>典型用法是：<ul>
<li>变量定义了没有赋值</li>
<li>函数应该传递的参数没有传递</li>
<li>对象定义属性没有赋值</li>
<li>函数没有返回值的时候 返回undefined</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h2 id="原型-原型链-原型继承（说一下原型-原型链，考了几道题-让你现在作答）-5"><a href="#原型-原型链-原型继承（说一下原型-原型链，考了几道题-让你现在作答）-5" class="headerlink" title="原型 原型链 原型继承（说一下原型 原型链，考了几道题 让你现在作答） 5%"></a>原型 原型链 原型继承（说一下原型 原型链，考了几道题 让你现在作答） 5%</h2><p>请简单说一下原型,原型链，继承</p>
<h3 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h3><ul>
<li>来由：原型是在创建对象时原型模式里提出的概念</li>
<li>定义：创建的每个函数都有一个原型prototype属性，这个属性是一个指针,指向一个对象，这个对象包含着这个函数所有实例可以共享的函数和方法。<br>这个原型对象就是:函数每个原型</li>
<li>优点：可以让所有实例共享原型对象中的属性和方法</li>
<li>缺点：因为共享的特性，实例改写引用类型属性 会更改原型对象属性 使得其他实例属性也改变；还有一个：无法给函数初始化参数</li>
<li>prototype与在构造函数中定义属性和方法有什么区别？<ul>
<li>构造函数中的属性和方法，每个实例都将构造函数中的所有属性创建一遍副本，</li>
<li>缺点：无法共享一套属性 <ul>
<li>优点：每个实例改写属性后互不影响</li>
</ul>
</li>
</ul>
</li>
<li>使用构造函数模式+原型模式创建对象取两者优点<ul>
<li>可传递参数</li>
<li>每个实例都可以利用原型对象共享方法</li>
<li>将引用类型属性放到构造函数中，实例改写后互不影响<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function Person(name, age, job) &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.age = age;</span><br><span class="line">    this.job = job;</span><br><span class="line">    this.friends = [&apos;a&apos;, &apos;b&apos;];</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">    constructor: Person,</span><br><span class="line">    sayName: function() &#123;</span><br><span class="line">        console.log(this.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h3 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h3><ul>
<li>来由：原型链这个概念是在讲继承的时候提出的</li>
<li>定义：原型与实例层层递进构成的链条叫做原型链。某个原型对象等于另一函数的实例:child.prototype = new father()，孩子原型.proto指向父原型，父原型的.proto指向 父原型的原型，直到Object.prototype.proto = null</li>
<li><p>确定原型和实例的关系</p>
<ul>
<li>instance instanceof SubType</li>
<li><p>father.prototype.isPrototypeOf(child)</p>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><h4 id="原型链继承-child-prototype-new-father"><a href="#原型链继承-child-prototype-new-father" class="headerlink" title="原型链继承 child.prototype = new father()"></a>原型链继承 child.prototype = new father()</h4><ul>
<li><p>缺点：</p>
<ul>
<li>访问重写父亲引用属性，会更改父原型</li>
<li>创建子类无法给父构造函数传递参数</li>
</ul>
</li>
<li><p>代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">function SuperType() &#123;</span><br><span class="line">    this.property = true;</span><br><span class="line">&#125;</span><br><span class="line">SuperType.prototype.getSuperValue = function() &#123; </span><br><span class="line">    return this.property;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function SubType() &#123;</span><br><span class="line">    this.subproperty = false;</span><br><span class="line">&#125;</span><br><span class="line">//先继承</span><br><span class="line">SubType.prototype = new SuperType(); </span><br><span class="line">//再添加方法</span><br><span class="line">SubType.prototype.getSubValue = function() &#123;</span><br><span class="line">    return this.subproperty;</span><br><span class="line">&#125;</span><br><span class="line">var instance = new SubType(); </span><br><span class="line">console.log(instance.getSuperValue()); //true</span><br><span class="line">//SuperType.prototype : constructor,getSuperValue(),proto</span><br><span class="line">//SubType.prototype : proto, property = true;getSubValue()</span><br><span class="line">// instance : proto , subproperty = false;</span><br><span class="line">//确定原型和实例的关系 instanceof /father.prototype.isPrototypeOf(child)</span><br><span class="line">console.log(instance instanceof SubType);</span><br><span class="line">console.log(instance instanceof SuperType);</span><br><span class="line">console.log(instance instanceof Object);</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="借用构造函数继承-经典继承"><a href="#借用构造函数继承-经典继承" class="headerlink" title="借用构造函数继承/经典继承"></a>借用构造函数继承/经典继承</h4><ul>
<li>定义：在子类构造函数中调用父类构造函数 ，子向父类传递参数</li>
<li>子类中Father.apply(this,param)</li>
<li>缺点：无法达到共享或者复用性（构造模式的问题）</li>
<li>优点：可给父类传递参数，副本属性</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function SuperType(name) &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">&#125;  </span><br><span class="line">function SubType() &#123;</span><br><span class="line">    //在子类构造函数中调用父类构造函数 实现了继承 还传递了参数</span><br><span class="line">    SuperType.call(this, &apos;carry&apos;);</span><br><span class="line">    //给子添加 属性</span><br><span class="line">    this.age = 19;</span><br><span class="line">&#125;</span><br><span class="line">var instance = new SubType();</span><br><span class="line">instance.name; //carry</span><br></pre></td></tr></table></figure>
<h4 id="组合继承（原型链继承-借用构造函数继承）"><a href="#组合继承（原型链继承-借用构造函数继承）" class="headerlink" title="组合继承（原型链继承+借用构造函数继承）"></a>组合继承（原型链继承+借用构造函数继承）</h4><ul>
<li>定义：原型链继承(可继承方法：达到共享)+借用构造函数继承(可继承属性：有自己的副本属性)</li>
<li>组合继承是js中最常用的继承方式</li>
<li>优点：属性互不影响，又可以共用方法，两全其美</li>
<li>缺点：要调用两次父类的构造函数，造成了属性副本在子类原型中的多余 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">function SuperType(name) &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.colors = [&apos;green&apos;, &apos;red&apos;];</span><br><span class="line">&#125;</span><br><span class="line">SuperType.prototype.sayName = function() &#123;</span><br><span class="line">    alert(this.name);</span><br><span class="line">&#125;</span><br><span class="line">function SubType(name, age) &#123;</span><br><span class="line">    //继承实例属性</span><br><span class="line">    SuperType.call(this, name);</span><br><span class="line">    this.age = age;</span><br><span class="line">&#125;</span><br><span class="line">//继承父类方法</span><br><span class="line">SubType.prototype = new SuperType();</span><br><span class="line">SubType.prototype.sayAge = function() &#123;</span><br><span class="line">    alert(this.age);</span><br><span class="line">&#125;</span><br><span class="line">var i1 = new SubType(&apos;bill&apos;, 18);</span><br><span class="line">i1.colors.push(&apos;white&apos;);</span><br><span class="line">alert(i1.colors); //&apos;green&apos;, &apos;red&apos;,&apos;white&apos;</span><br><span class="line">i1.sayAge(); //18</span><br><span class="line">i1.sayName(); //bill</span><br><span class="line">var i2 = new SubType(&apos;carry&apos;, 28)</span><br><span class="line">i2.colors; //&apos;green&apos;, &apos;red</span><br><span class="line">i1.sayAge(); //28</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="原型式继承-var-childObj-Object-create-fatherObj-Object-create-create"><a href="#原型式继承-var-childObj-Object-create-fatherObj-Object-create-create" class="headerlink" title="原型式继承 var childObj = Object.create(fatherObj) //Object.create() = create()"></a>原型式继承 var childObj = Object.create(fatherObj) //Object.create() = create()</h4><ul>
<li>在没有必要兴师动众的创建构造函数的情况下， 只想让两个对象保持差不多一致<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var peron = &#123;</span><br><span class="line">    name: &apos;carry1&apos;,</span><br><span class="line">    friends: [&apos;f1&apos;, &apos;f2&apos;]</span><br><span class="line">&#125;</span><br><span class="line">var np1 = Object.create(peron);</span><br><span class="line">np1.name = &apos;carry2&apos;;</span><br><span class="line">np1.friends.push(&apos;f3&apos;);</span><br><span class="line">var np2 = Object.create(peron, &#123;</span><br><span class="line">    name: &#123;</span><br><span class="line">        value: &apos;carry3&apos;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">console.log(np2.name); //carry3</span><br><span class="line">peron.friends; //f1,f2,f3</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="寄生式继承"><a href="#寄生式继承" class="headerlink" title="寄生式继承"></a>寄生式继承</h4><ul>
<li>封装一个仅仅用于实现继承过程的函数 该函数 完成继承操作 然后返回子对象.</li>
<li>寄生式继承就是利用原型式继承的中Object.create(fatherObj)原理实现实例属性的继承，但是又可以在clone函数中定义自己的方法<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function createClone(father) &#123;</span><br><span class="line">    var clone = Object.create(father);</span><br><span class="line">    clone.sayHi = function() &#123;</span><br><span class="line">        alert(&apos;i am clone&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">    return clone;</span><br><span class="line">&#125;</span><br><span class="line">var peron = &#123;</span><br><span class="line">    name: &apos;carry1&apos;,</span><br><span class="line">    friends: [&apos;f1&apos;, &apos;f2&apos;]</span><br><span class="line">&#125;</span><br><span class="line">var child = createClone(Person);</span><br><span class="line">child.name = &apos;carry2&apos;;</span><br><span class="line">child.sayHi(); //&apos;i am clone&apos;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="寄生组合式继承"><a href="#寄生组合式继承" class="headerlink" title="寄生组合式继承"></a>寄生组合式继承</h4><ul>
<li>采用 借用构造函数 来继承属性  使用 原型链的混成形式来继承 方法</li>
<li>用来完善组合式继承：因为组合式继承 要调用两次父类的构造函数，造成了在子类中又创建了一遍属性</li>
<li>优点：寄生式组合继承 只使用了一次 父类构造函数，避免了child.prototype上创建没必要的属性，原型链的结构还可以保持不变<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">function inheritPrototype(subType, superType) &#123;</span><br><span class="line">    var prototype = Object.create(SuperType.prototype); //创建对象</span><br><span class="line">    prototype.constructor = subType; //增强对象</span><br><span class="line">    subType.prototype = prototype; //指定对象</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function SuperType(name) &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.colors = [&apos;green&apos;, &apos;red&apos;];</span><br><span class="line">&#125;</span><br><span class="line">SuperType.prototype.sayName = function() &#123;</span><br><span class="line">    alert(this.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function SubType(name, age) &#123;</span><br><span class="line">    //继承属性</span><br><span class="line">    SuperType.call(this, name);</span><br><span class="line">    this.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//继承方法</span><br><span class="line">inheritPrototype(SubType, SuperType)</span><br><span class="line">SubType.prototype.sayAge = function() &#123;</span><br><span class="line">    alert(this.age);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h2 id="闭包5"><a href="#闭包5" class="headerlink" title="闭包5%"></a>闭包5%</h2><h3 id="故事版本的讲解"><a href="#故事版本的讲解" class="headerlink" title="故事版本的讲解"></a>故事版本的讲解</h3><p>我叫独孤求败，我在一个山洞里，里面有世界上最好的剑法，还有最好的武器。我学习了里面的剑法，拿走了最好的剑。离开了这里。我来到这个江湖，快意恩仇。但是从来没有人知道我这把剑的来历，和我这一身的武功。。。我就是闭包，我的存在可以将山洞与外界交汇。这山洞的一切对外人而言就像不存在一样，只有我才拥有这里面的宝藏！别人都不知道我的剑法从何而来，即使山洞灭亡，我的剑法还在。<br>（山洞是外层函数，我是内层函数，剑法和武器是外层函数作用域中的变量对象，闭包存在的意义是内层函数使访问的外层函数的变量长久保存而不造成全局污染，而对外界来说都不知道这个变量的来由）</p>
<h3 id="什么是闭包？"><a href="#什么是闭包？" class="headerlink" title="什么是闭包？"></a>什么是闭包？</h3><p>闭包就是可以访问并使用外层函数作用域中变量的函数</p>
<h3 id="为什么需要闭包呢-闭包存在的意义-？"><a href="#为什么需要闭包呢-闭包存在的意义-？" class="headerlink" title="为什么需要闭包呢(闭包存在的意义)？"></a>为什么需要闭包呢(闭包存在的意义)？</h3><p>局部变量无法共享和长久的保存，而全局变量可能造成变量污染，所以我们希望有一种机制既可以长久的保存变量又不会造成全局污染。</p>
<h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><p>占用更多内存<br>不容易被释放</p>
<h4 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h4><p>1.定义外层函数，封装被保护的局部变量。<br>2.定义内层函数，执行对外部函数变量的操作。<br>3.外层函数返回内层函数</p>
<hr>
<h2 id="js事件-5"><a href="#js事件-5" class="headerlink" title="js事件 5%"></a>js事件 5%</h2><h3 id="事件模型"><a href="#事件模型" class="headerlink" title="事件模型"></a>事件模型</h3><ul>
<li>DOM0 :原始事件模型<ul>
<li>btn.onclick=function(){}这种类型的事件模型（btn.onclick = null;）</li>
<li>基于DOM0的事件，对于同一个dom节点而言，只能注册一个， 取后面事件。后边注册的同种事件会覆盖之前注册的。</li>
</ul>
</li>
<li>DOM2<ul>
<li>冒泡 ：事件从事件的发生地（目标元素），一直向上传递，直到window<ul>
<li>IE只支持事件冒泡</li>
</ul>
</li>
<li>捕获 ：事件是从window向下传递，直到事件的发生地（目标元素）</li>
<li>设置捕获和冒泡：<ul>
<li>IE：默认事件冒泡<ul>
<li>标准： addEventListener()第三个参数:捕获/冒泡 = true/false</li>
</ul>
</li>
</ul>
</li>
<li>绑定或者解除事件<ul>
<li>标准：addEventListener(type,handler),removeEventListener(type,handler)</li>
<li>IE: attachEvent,target.detachEvent(“on”+type,handler);</li>
</ul>
</li>
<li>阻止事件冒泡：evt.stopPropagation()/evt.cancelBubble=true</li>
<li>获取事件对象(标准||IE):var event=window.event||event; </li>
<li>获取事件源对象：var target = event.target||event.srcElement;</li>
<li>同一个节点元素，给她添加捕获和冒泡事件模型，捕获比冒泡快</li>
<li>绑定多个事件的顺序:比如说一下子注册了3个冒泡事件，那么执行顺序就按照注册的顺序来，先注册先执行</li>
</ul>
</li>
</ul>
<hr>
<h3 id="事件委托"><a href="#事件委托" class="headerlink" title="事件委托"></a>事件委托</h3><p>应用场景：动态添加 或删除孩子的时候<br>含义：孩子的事委托父亲做<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul id=&quot;ul1&quot;&gt;</span><br><span class="line">    &lt;li&gt;111&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;222&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;333&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;444&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line"></span><br><span class="line">window.onload = function()&#123;</span><br><span class="line">    var oUl = document.getElementById(&quot;ul1&quot;);</span><br><span class="line">   oUl.onclick = function()&#123;</span><br><span class="line">        alert(123);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里用父级ul做事件处理，当li被点击时，由于冒泡原理，事件就会冒泡到ul上，因为ul上有点击事件，所以事件就会触发.<br>当然，这里当点击ul的时候，也是会触发的，那么问题就来了，如果我想让事件代理的效果跟直接给节点的事件效果一样怎么办，比如说只有点击li才会触发，不怕，我们有绝招：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">window.onload = function()&#123;</span><br><span class="line">　　var oUl = document.getElementById(&quot;ul1&quot;);</span><br><span class="line">　　oUl.onclick = function(event)&#123;</span><br><span class="line">　　　　var ev = event || window.event;</span><br><span class="line">　　　　var target = ev.target || ev.srcElement;</span><br><span class="line">　　　　if(target.nodeName.toLowerCase() == &apos;li&apos;)&#123;</span><br><span class="line">　 　　　　　　 alert(123);</span><br><span class="line">　　　　　　　  alert(target.innerHTML);</span><br><span class="line">　　　　&#125;</span><br><span class="line">　　&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<h2 id="原生js的-增-删-改-5"><a href="#原生js的-增-删-改-5" class="headerlink" title="原生js的(增 删 改) 5%"></a>原生js的(增 删 改) 5%</h2><p><img src="http://upload-images.jianshu.io/upload_images/2377897-d9abdd592a00f11f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<h3 id="增"><a href="#增" class="headerlink" title="增"></a>增</h3><ul>
<li>若添加新元素：首先创建该元素节点，然后添加</li>
<li>创建元素节点：document.createElement(‘h1’)</li>
<li>创建文本节点：document.createTextNode(‘描述’)</li>
<li>增加：<ul>
<li>添加孩子<ul>
<li>A.append(B) : 把B追加到A内部</li>
<li>A.appendTo(B) : 把A追加到B内部</li>
<li>A.prepend(B) : 在A的开始添加孩子B</li>
<li>A.prependTo(B) : 把A追加到B的开始<ul>
<li>添加兄弟</li>
<li>A.after(B) :  在A后添加B</li>
<li>A.before(B): 在A前追加B</li>
<li>添加class</li>
<li>elm.classList.add(‘nn’)</li>
<li>elm.className+=” nn”  //nn前边有空格</li>
<li>node.insertBefore(A,B):在父节点node里面的B节点前面追加A</li>
<li>替换节点：parent.replaceChild(child,oldElem);</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="删"><a href="#删" class="headerlink" title="删"></a>删</h3><ul>
<li>elementNow.remove():删除当前元素</li>
<li>parent.removeChild(child):删除父元素中的子元素</li>
<li>child.parentNode.removeChild(child)：不确定父元素的时候可以这样做<h3 id="改"><a href="#改" class="headerlink" title="改"></a>改</h3><a href="http://www.jianshu.com/writer#/notebooks/10862078/notes/15825654/preview" target="_blank" rel="external">http://www.jianshu.com/writer#/notebooks/10862078/notes/15825654/preview</a><ul>
<li>( 获取，设置) 修改HTML元素内容<ul>
<li>node.textContent:用来设置或是获取某个元素内所有文本内容，包括子元素中的内容。（css等兼容性比innerText好）</li>
<li>node.innerText: 只获取当前节点内容</li>
<li>node.innerHTML：</li>
<li>node.outerHTML：</li>
</ul>
</li>
<li>更改属性<ul>
<li>设置属性：node.setAttribute(‘style’,’color:red’)</li>
<li>获取属性：var a = node.getAttribute(‘’style’’);</li>
</ul>
</li>
<li>修改元素CSS<ul>
<li>node.style.color=”red”<h3 id="查"><a href="#查" class="headerlink" title="查"></a>查</h3></li>
</ul>
</li>
<li>querySelector()、</li>
<li>querySelectorAll()</li>
<li>getElementById()、</li>
<li>getElementsByTagName()、</li>
<li>getElementsByName()、</li>
<li>getElementsByClassName()、</li>
</ul>
</li>
</ul>
<hr>
<h3 id="jq增删改查"><a href="#jq增删改查" class="headerlink" title="jq增删改查"></a>jq增删改查</h3><ul>
<li>内部插入主要方法：<ul>
<li>append(content) 向每个匹配的元素内部追加内容。</li>
<li>prepend(content) 向每个匹配的元素内部前置内容。</li>
</ul>
</li>
<li>外部插入：<ul>
<li>after(content) 在每个匹配的元素之后插入内容。</li>
<li>before(content) 在每个匹配的元素之前插入内容。</li>
</ul>
</li>
<li>删除：<ul>
<li>empty() 删除匹配的元素集合中所有的子节点。</li>
<li>remove([expr]) 从DOM中删除所有匹配的元素。</li>
</ul>
</li>
</ul>
<hr>
<h2 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h2><p>1:jsonp跨域<br>JSONP（JSON with Padding）是资料格式 JSON 的一种“使用模式”，可以让网页从别的网域要资料<br>因为通过script标签引入的js是不受同源策略的限制的。所以我们可以通过script标签引入一个js或者是一个其他后缀形式（如php，jsp等）的文件，此文件返回一个js函数的调用。 比如，有个a.html页面，它里面的代码需要利用ajax获取一个不同域上的json数据，假设这个json数据地址是<a href="http://damonare.cn/data.php" target="_blank" rel="external">http://damonare.cn/data.php</a>, 那么a.html中的代码就可以这样<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">    function dosomething(jsondata)&#123;</span><br><span class="line">        //处理获得的json数据</span><br><span class="line">    &#125;</span><br><span class="line">&lt;\/script&gt;</span><br><span class="line">//因为是markdown写的，所以页面显示内容可能有部分差异</span><br><span class="line">&lt;script src=\&quot;http://example.com/data.php?callback=dosomething&quot;&gt;&lt;\/script&gt;</span><br></pre></td></tr></table></figure></p>
<p>2:通过修改document.domain来跨子域<br>仅在相同主域下才有效，且window.domain需要设置为相同的父域 不同的框架之间是可以获取window对象的，但却无法获取相应的属性和方法。<br>比如，有一个页面，它的地址是<a href="http://www.example.com/a.html" target="_blank" rel="external">http://www.example.com/a.html</a> ，<br>在这个页面里面有一个iframe，它的src是<a href="http://example.com/b.html" target="_blank" rel="external">http://example.com/b.html</a>,<br>很显然，这个页面与它里面的iframe框架是不同域的，所以我们是无法通过在页面中书写js代码来获取iframe中的东西的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">    function test()&#123;</span><br><span class="line">        var iframe = document.getElementById(&apos;iframe&apos;);</span><br><span class="line">        var win = document.contentWindow;//可以获取到iframe里的window对象，但该window对象的属性和方法几乎是不可用的</span><br><span class="line">        var doc = win.document;//这里获取不到iframe里的document对象</span><br><span class="line">        var name = win.name;//这里同样获取不到window对象的name属性</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;iframe id = &quot;iframe&quot; src=&quot;http://example.com/b.html&quot; onload = &quot;test()&quot;&gt;&lt;/iframe&gt;</span><br></pre></td></tr></table></figure></p>
<p><img src="http://upload-images.jianshu.io/upload_images/2377897-b81be614658808c3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"><br>3:</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2377897-d51bad8105ff7116.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"><br>4：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2377897-665a15e11ea92788.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"><br>5：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2377897-2e14787d1c2eae05.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<hr>
<h2 id="if-false-的几种情况"><a href="#if-false-的几种情况" class="headerlink" title="if() false 的几种情况"></a>if() false 的几种情况</h2><ul>
<li>if(false)</li>
<li>if(null)</li>
<li>if(undefined)</li>
<li>if(‘’)</li>
<li>if(NaN)-数字NaN</li>
<li>if(0)-数字0</li>
</ul>
<hr>
<h2 id="Ajax实现流程"><a href="#Ajax实现流程" class="headerlink" title="Ajax实现流程"></a>Ajax实现流程</h2><p>创建一个XMLHttpRequest()实例<br>准备一个Ajax请求以待发送<br>发送Ajax请求<br>根据服务器响应的结果，将相应数据填充到xhr对象的属性中 注意url是相对于执行代码的当前页面，也可以是绝对路径。</p>
<p>var xhr = new XMLHttpRequest();<br>xhr.open(Type,URL,Boolean);<br>//请求类型，请求地址，是否异步<br>xhr.send(null);<br>xhr.onreadystatechange = function(){<br>    if(xhr.readyState == 4){<br>        if(xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300 || xhr.status == 304){<br>            alert(xhr.responseText);<br>        }else {<br>            alert(‘unsuccessful ‘ + xhr.status);<br>        }<br>    }<br>};</p>
<hr>
<h2 id="单线程"><a href="#单线程" class="headerlink" title="单线程"></a>单线程</h2><p>为什么javascrip是单线程<br>JavaScript的单线程，与它的用途有关。作为浏览器脚本语言，JavaScript的主要用途是与用户互动，以及操作DOM。这决定了它只能是单线程，否则会带来很复杂的同步问题。<br>浏览器端多线程<br>js<br>css<br>事件<br>数据交互</p>
<hr>
<h2 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h2><p>垃圾收集器必须跟踪哪个变量有用哪个变量没用，对于不再有用的变量打上标记，以备将来收回其占用的内存，内存泄露和浏览器实现的垃圾回收机制息息相关， 而浏览器实现标识无用变量的策略主要有下两个方法：<br>第一，引用计数法<br>跟踪记录每个值被引用的次数。当声明一个变量并将引用类型的值赋给该变量时，则这个值的引用次数就是1。如果同一个值又被赋给另一个变量，则该值的引用次 数加1.相反，如果包含对这个值引用的变量又取得另外一个值，则这个值的引用次数减1.当这个值的引用次数变成0时，则说明没有办法访问这个值了，因此就 可以将其占用的内存空间回收回来。</p>
<p>如： var a = {};     //对象{}的引用计数为1<br>     b = a;          //对象{}的引用计数为 1+1<br>     a = null;       //对象{}的引用计数为2-1<br>所以这时对象{}不会被回收;<br>IE 6, 7 对DOM对象进行引用计数回收， 这样简单的垃圾回收机制，非常容易出现循环引用问题导致内存不能被回收， 进行导致内存泄露等问题，一般不用引用计数法。<br>第二，标记清除法<br>到2008年为止，IE,Firefox,Opera,Chrome和Safari的javascript实现使用的都是标记清除式的垃圾收集策略（或类似的策略），只不过垃圾收集的时间间隔互有不同。<br>标记清除的算法分为两个阶段，标记(mark)和清除(sweep). 第一阶段从引用根节点开始标记所有被引用的对象，第二阶段遍历整个堆，把未标记的对象清除。</p>
<hr>
<hr>
<h2 id="javascript创建对象的几种方式？"><a href="#javascript创建对象的几种方式？" class="headerlink" title="javascript创建对象的几种方式？"></a>javascript创建对象的几种方式？</h2><p> javascript创建对象简单的说,无非就是使用内置对象或各种自定义对象，当然还可以用JSON；但写法有很多种，也能混合使用。</p>
<p> 1、对象字面量的方式</p>
<pre><code>person={firstname:&quot;Mark&quot;,lastname:&quot;Yun&quot;,age:25,eyecolor:&quot;black&quot;};
</code></pre><p> 2、用function来模拟无参的构造函数</p>
<pre><code>function Person(){}
var person=new Person();//定义一个function，如果使用new&quot;实例化&quot;,该function可以看作是一个Class
person.name=&quot;Mark&quot;;
person.age=&quot;25&quot;;
person.work=function(){
alert(person.name+&quot; hello...&quot;);
}
person.work();
</code></pre><p> 3、用function来模拟参构造函数来实现（用this关键字定义构造的上下文属性）</p>
<pre><code>function Pet(name,age,hobby){
   this.name=name;//this作用域：当前对象
   this.age=age;
   this.hobby=hobby;
   this.eat=function(){
      alert(&quot;我叫&quot;+this.name+&quot;,我喜欢&quot;+this.hobby+&quot;,是个程序员&quot;);
   }
}
var maidou =new Pet(&quot;麦兜&quot;,25,&quot;coding&quot;);//实例化、创建对象
maidou.eat();//调用eat方法
</code></pre><p> 4、用工厂方式来创建（内置对象）</p>
<pre><code>var wcDog =new Object();
wcDog.name=&quot;旺财&quot;;
wcDog.age=3;
wcDog.work=function(){
  alert(&quot;我是&quot;+wcDog.name+&quot;,汪汪汪......&quot;);
}
wcDog.work();
</code></pre><p> 5、用原型方式来创建</p>
<pre><code>function Dog(){

 }
 Dog.prototype.name=&quot;旺财&quot;;
 Dog.prototype.eat=function(){
 alert(this.name+&quot;是个吃货&quot;);
 }
 var wangcai =new Dog();
 wangcai.eat();
</code></pre><p> 5、用混合方式来创建</p>
<pre><code>function Car(name,price){
  this.name=name;
  this.price=price;
}
 Car.prototype.sell=function(){
   alert(&quot;我是&quot;+this.name+&quot;，我现在卖&quot;+this.price+&quot;万元&quot;);
  }
var camry =new Car(&quot;凯美瑞&quot;,27);
camry.sell();
</code></pre><hr>
<h2 id="JavaScript有几种类型的值？，你能画一下他们的内存图吗？"><a href="#JavaScript有几种类型的值？，你能画一下他们的内存图吗？" class="headerlink" title="JavaScript有几种类型的值？，你能画一下他们的内存图吗？"></a>JavaScript有几种类型的值？，你能画一下他们的内存图吗？</h2><p> 栈：原始数据类型（Undefined，Null，Boolean，Number、String）<br> 堆：引用数据类型（对象、数组和函数）</p>
<p> 两种类型的区别是：存储位置不同；<br> 原始数据类型直接存储在栈(stack)中的简单数据段，占据空间小、大小固定，属于被频繁使用数据，所以放入栈中存储；<br> 引用数据类型存储在堆(heap)中的对象,占据空间大、大小不固定。如果存储在栈中，将会影响程序运行的性能；引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2377897-f0c90cfaba1aabac.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<hr>
<h2 id="说几条写JavaScript的基本规范？"><a href="#说几条写JavaScript的基本规范？" class="headerlink" title="说几条写JavaScript的基本规范？"></a>说几条写JavaScript的基本规范？</h2><p> 1.不要在同一行声明多个变量。<br> 2.请使用 ===/!==来比较true/false或者数值<br> 3.使用对象字面量替代new Array这种形式<br> 4.不要使用全局函数。<br> 5.Switch语句必须带有default分支<br> 6.函数不应该有时候有返回值，有时候没有返回值。<br> 7.For循环必须使用大括号<br> 8.If语句必须使用大括号<br> 9.for-in循环中的变量 应该使用var关键字明确限定作用域，从而避免作用域污染。</p>
<hr>
<h2 id="封装cookie的添加，删除，查询方法"><a href="#封装cookie的添加，删除，查询方法" class="headerlink" title="封装cookie的添加，删除，查询方法"></a>封装cookie的添加，删除，查询方法</h2><p>cookie是存储在浏览器端的，可以用于存储sessionID，也可以用于自动登陆，记住密码等，但是在浏览器端并没有官方的操作cookie的方法，下面我们来封装一下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">CookieUtil=｛</span><br><span class="line">    addCookie:function(key,value,options)&#123;</span><br><span class="line">        var str=key+&quot;=&quot;+escape(value);</span><br><span class="line">        if(options.expires)&#123;</span><br><span class="line">           var curr=new Date();   //options.expires的单位是小时</span><br><span class="line">           curr.setTime(curr.getTime()+options.expires*3600*1000);</span><br><span class="line">           options.expires=curr.toGMTString();</span><br><span class="line">        &#125;</span><br><span class="line">        for(var k in options)&#123;   //有可能指定了cookie的path，cookie的domain</span><br><span class="line">           str+=&quot;;&quot;+k+&quot;=&quot;+options[k];</span><br><span class="line">        &#125;</span><br><span class="line">        document.cookie=str;</span><br><span class="line">    &#125;,</span><br><span class="line">    queryCookie:function(key)&#123;</span><br><span class="line">      var cookies=document.cookie;</span><br><span class="line">     //获得浏览器端存储的cookie,格式是key=value;key=value;key=value</span><br><span class="line">      cookies+=&quot;;&quot;;</span><br><span class="line">      var start=cookies.indexOf(key);</span><br><span class="line">      if(start&lt;=-1)&#123; return null; &#125;  //说明不存在该cookie</span><br><span class="line">      var end=cookies.indexOf(&quot;;&quot;,start);</span><br><span class="line">      var value=cookies.slice(start+key.length+1,end);</span><br><span class="line">      return unescape(value);</span><br><span class="line">    &#125;,</span><br><span class="line">    deleteCookie:function(key)&#123;</span><br><span class="line">      var value=CookieUtil.queryCookie(key);</span><br><span class="line">      if(value===null)&#123;return false;&#125;</span><br><span class="line">      CookieUtil.addCookie(key,value,&#123;expires:0&#125;);//把过期时间设置为0，浏览器会马上自动帮我们删除cookie</span><br><span class="line">    &#125;</span><br><span class="line">｝</span><br></pre></td></tr></table></figure></p>
<hr>
<h2 id="同源策略"><a href="#同源策略" class="headerlink" title="同源策略"></a>同源策略</h2><p>同源策略是浏览器有一个很重要的概念。所谓同源是指，域名，协议，端口相同。不同源的客户端脚本(javascript、ActionScript)在没明确授权的情况下，不能读写对方的资源。简单的来说，浏览器允许包含在页面A的脚本访问第二个页面B的数据资源，这一切是建立在A和B页面是同源的基础上。</p>
<hr>
<h2 id="介绍js有哪些内置对象？"><a href="#介绍js有哪些内置对象？" class="headerlink" title="介绍js有哪些内置对象？"></a>介绍js有哪些内置对象？</h2><p> Object 是 JavaScript 中所有对象的父对象<br> 数据封装类对象：Object、Array、Boolean、Number 和 String<br> 其他对象：Function、Arguments、Math、Date、RegExp、Error</p>
<hr>
<h2 id="作用域与作用域链-？"><a href="#作用域与作用域链-？" class="headerlink" title="作用域与作用域链 ？"></a>作用域与作用域链 ？</h2><p>0：函数作用域<br>1：作用域<br>2：作用域链<br>3：with语句主要用来临时扩展作用域链，将语句中的对象添加到作用域的头部。</p>
<p>而Javascript压根没有块级作用域，而是有函数作用域.<br>作用域指的是变量的作用范围。<br>内部作用域由函数的参数，局部变量，函数构成。内部作用域和外部的作用域一层层的链接起来形成作用域链。<br>当在函数内部要访问一个变量的时候，首先查找自己的内部作用域有没有这个变量，如果没有就到这个函数所在的外层作用域中找，直到到window所在的作用域。<br>每个函数在声明的时候就默认有一个外部作用域的存在了，比如：<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var t=4;</span><br><span class="line">function foo()&#123;</span><br><span class="line">       var tem=12;</span><br><span class="line">      funciton bar()&#123;</span><br><span class="line">       var temo=34;</span><br><span class="line">       console.log(t+&quot; &quot;+tem+&quot; &quot;+temo);</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>bar（）的外部作用域是foo()作用域。foo()的外部作用域是window</p>
<hr>
<h2 id="this指向"><a href="#this指向" class="headerlink" title="this指向"></a>this指向</h2><blockquote>
<p>在javascript当中每一个function都是一个对象，所以在这个里var temp=this 指的是function当前的对象。this是Javascript语言的一个关键字。它代表函数运行时，自动生成的一个内部对象，只能在函数内部使用。</p>
</blockquote>
<p>一共有四种指向：</p>
<ul>
<li>函数有所属对象时：指向所属对象</li>
<li>没调用对象就指向全局对象</li>
<li>构造函数中的 this：指向新对象</li>
<li>通过 apply 或 call 或 bind 来改变 this 的所指。</li>
</ul>
<h3 id="函数有所属对象时：指向所属对象"><a href="#函数有所属对象时：指向所属对象" class="headerlink" title="函数有所属对象时：指向所属对象"></a>函数有所属对象时：指向所属对象</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var myObject = &#123;value: 100&#125;;</span><br><span class="line">myObject.getValue = function () &#123;</span><br><span class="line"> console.log(this.value); // 输出 100</span><br><span class="line"> </span><br><span class="line"> // 输出 &#123; value: 100, getValue: [Function] &#125;，</span><br><span class="line"> // 其实就是 myObject 对象本身</span><br><span class="line"> console.log(this);</span><br><span class="line"> </span><br><span class="line"> return this.value;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">console.log(myObject.getValue()); // =&gt; 100</span><br></pre></td></tr></table></figure>
<h3 id="没调用对象就指向全局对象"><a href="#没调用对象就指向全局对象" class="headerlink" title="没调用对象就指向全局对象"></a>没调用对象就指向全局对象</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var myObject = &#123;value: 100&#125;;</span><br><span class="line">myObject.getValue = function () &#123;</span><br><span class="line"> var foo = function () &#123;</span><br><span class="line">  console.log(this.value) // =&gt; undefined</span><br><span class="line">  console.log(this);// 输出全局对象 global</span><br><span class="line"> &#125;;</span><br><span class="line"> foo(); </span><br><span class="line"> return this.value;</span><br><span class="line">&#125;;</span><br><span class="line">console.log(myObject.getValue()); // =&gt; 100</span><br></pre></td></tr></table></figure>
<h4 id="构造器中的-this：指向新对象"><a href="#构造器中的-this：指向新对象" class="headerlink" title="构造器中的 this：指向新对象"></a>构造器中的 this：指向新对象</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var SomeClass = function()&#123;</span><br><span class="line"> this.value = 100;</span><br><span class="line">&#125;</span><br><span class="line">var myCreate = new SomeClass();</span><br><span class="line">console.log(myCreate.value); // 输出100</span><br></pre></td></tr></table></figure>
<h3 id="apply-和-call-调用以及-bind-绑定：指向绑定的对象"><a href="#apply-和-call-调用以及-bind-绑定：指向绑定的对象" class="headerlink" title="apply 和 call 调用以及 bind 绑定：指向绑定的对象"></a>apply 和 call 调用以及 bind 绑定：指向绑定的对象</h3><p>call和apply，假设要改变fn函数内部的this的指向，指向obj，那么可以fn.call(obj);或者fn.apply(obj);<br>call和apply的区别是什么<br>其是call和apply的区别在于参数，他们两个的第一个参数都是一样的，表示调用该函数的对象，apply的第二个参数是数组，是[arg1,arg2,arg3]这种形式，而call是arg1,arg2,arg3这样的形式。<br>还有一个bind函数，var bar=fn.bind(obj);那么fn中的this就指向obj对象了，bind函数返回新的函数，这个函数内(bar)的this指针指向obj对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var myObject = &#123;value: 100&#125;;</span><br><span class="line">var foo = function()&#123;</span><br><span class="line"> console.log(this);</span><br><span class="line">&#125;;</span><br><span class="line">foo(); // 全局变量 global</span><br><span class="line">foo.apply(myObject); // &#123; value: 100 &#125;</span><br><span class="line">foo.call(myObject); // &#123; value: 100 &#125;</span><br><span class="line">var newFoo = foo.bind(myObject);</span><br><span class="line">newFoo(); // &#123; value: 100 &#125;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="js常用算法"><a href="#js常用算法" class="headerlink" title="js常用算法"></a>js常用算法</h1><h2 id="判断一个单词是否是回文？"><a href="#判断一个单词是否是回文？" class="headerlink" title="判断一个单词是否是回文？"></a>判断一个单词是否是回文？</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function checkPalindrom(str) &#123;  </span><br><span class="line">    return str == str.split(&apos;&apos;).reverse().join(&apos;&apos;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="去掉一组整型数组重复的值"><a href="#去掉一组整型数组重复的值" class="headerlink" title="去掉一组整型数组重复的值"></a>去掉一组整型数组重复的值</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">let unique = function(arr) &#123;  </span><br><span class="line">  let hashTable = &#123;&#125;;</span><br><span class="line">  let data = [];</span><br><span class="line">  for(let i=0,l=arr.length;i&lt;l;i++) &#123;</span><br><span class="line">    if(!hashTable[arr[i]]) &#123;</span><br><span class="line">      hashTable[arr[i]] = true;</span><br><span class="line">      data.push(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return data</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module.exports = unique;</span><br></pre></td></tr></table></figure>
<h2 id="统计一个字符串出现最多的字母"><a href="#统计一个字符串出现最多的字母" class="headerlink" title="统计一个字符串出现最多的字母"></a>统计一个字符串出现最多的字母</h2><p>给出一段英文连续的英文字符窜，找出重复出现次数最多的字母</p>
<p>输入 ： afjghdfraaaasdenas </p>
<p>输出 ： a<br>前面出现过去重的算法，这里需要是统计重复次数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">function findMaxDuplicateChar(str) &#123;  </span><br><span class="line">  if(str.length == 1) &#123;</span><br><span class="line">    return str;</span><br><span class="line">  &#125;</span><br><span class="line">  let charObj = &#123;&#125;;</span><br><span class="line">  for(let i=0;i&lt;str.length;i++) &#123;</span><br><span class="line">    if(!charObj[str.charAt(i)]) &#123;</span><br><span class="line">      charObj[str.charAt(i)] = 1;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">      charObj[str.charAt(i)] += 1;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  let maxChar = &apos;&apos;,</span><br><span class="line">      maxValue = 1;</span><br><span class="line">  for(var k in charObj) &#123;</span><br><span class="line">    if(charObj[k] &gt;= maxValue) &#123;</span><br><span class="line">      maxChar = k;</span><br><span class="line">      maxValue = charObj[k];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return maxChar;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module.exports = findMaxDuplicateChar;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="快排"><a href="#快排" class="headerlink" title="快排"></a>快排</h2><p>算法参考某个元素值，将小于它的值，放到左数组中，大于它的值的元素就放到右数组中，然后递归进行上一次左右数组的操作，返回合并的数组就是已经排好顺序的数组了。</p>
<p>function quickSort(arr) {</p>
<pre><code>if(arr.length&lt;=1) {
    return arr;
}

let leftArr = [];
let rightArr = [];
let q = arr[0];
for(let i = 1,l=arr.length; i&lt;l; i++) {
    if(arr[i]&gt;q) {
        rightArr.push(arr[i]);
    }else{
        leftArr.push(arr[i]);
    }
}

return [].concat(quickSort(leftArr),[q],quickSort(rightArr));
</code></pre><p>}</p>
<p>module.exports = quickSort;  </p>
<hr>
<h2 id="获取数组中最大或者最小值"><a href="#获取数组中最大或者最小值" class="headerlink" title="获取数组中最大或者最小值"></a>获取数组中最大或者最小值</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function maxAndMin(arr)&#123;</span><br><span class="line">return &#123;</span><br><span class="line">max:Math.max.apply(null,arr.join(&apos;,&apos;).split(&apos;,&apos;)),</span><br><span class="line">min:Math.min.apply(null,arr.join(&apos;,&apos;).split(&apos;,&apos;))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该方法适合一维或者多维数组求最大最小值的情况</p>
<hr>
<h2 id="找出下列正数组的最大差值比如"><a href="#找出下列正数组的最大差值比如" class="headerlink" title="找出下列正数组的最大差值比如:"></a>找出下列正数组的最大差值比如:</h2><p>输入 [10,5,11,7,8,9]</p>
<p>输出 6<br>这是通过一道题目去测试对于基本的数组的最大值的查找，很明显我们知道，最大差值肯定是一个数组中最大值与最小值的差。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">  function getMaxProfit(arr) &#123;</span><br><span class="line"></span><br><span class="line">    var minPrice = arr[0];</span><br><span class="line">    var maxProfit = 0;</span><br><span class="line"></span><br><span class="line">    for (var i = 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">        var currentPrice = arr[i];</span><br><span class="line"></span><br><span class="line">        minPrice = Math.min(minPrice, currentPrice);</span><br><span class="line"></span><br><span class="line">        var potentialProfit = currentPrice - minPrice;</span><br><span class="line"></span><br><span class="line">        maxProfit = Math.max(maxProfit, potentialProfit);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return maxProfit;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<h2 id="随机生成指定长度的字符串"><a href="#随机生成指定长度的字符串" class="headerlink" title="随机生成指定长度的字符串"></a>随机生成指定长度的字符串</h2><p>实现一个算法，随机生成指制定长度的字符窜。<br>比如给定 长度 8  输出 4ldkfg9j<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function randomString(n) &#123;  </span><br><span class="line">  let str = &apos;abcdefghijklmnopqrstuvwxyz9876543210&apos;;</span><br><span class="line">  let tmp = &apos;&apos;,</span><br><span class="line">      i = 0,</span><br><span class="line">      l = str.length;</span><br><span class="line">  for (i = 0; i &lt; n; i++) &#123;</span><br><span class="line">    tmp += str.charAt(Math.floor(Math.random() * l));</span><br><span class="line">  &#125;</span><br><span class="line">  return tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module.exports = randomString;</span><br></pre></td></tr></table></figure></p>
<hr>
<h2 id="正則"><a href="#正則" class="headerlink" title="正則"></a>正則</h2><p><a href="https://segmentfault.com/a/1190000008088937" target="_blank" rel="external">https://segmentfault.com/a/1190000008088937</a></p>
<hr>
<h1 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h1><h2 id="AMD与CMD"><a href="#AMD与CMD" class="headerlink" title="AMD与CMD"></a>AMD与CMD</h2><p>AMD 和 CMD</p>
<p>AMD 是 RequireJS 在推广过程中对模块定义的规范化产出。 CMD 是 SeaJS 在推广过程中对模块定义的规范化产出，类似的还有 CommonJS Modules/2.0 规范。 区别： AMD是提前执行，CMD是延迟执行。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//CMD</span><br><span class="line">define(function(require, exports, module)&#123;</span><br><span class="line">    var a = require(&apos;./a&apos;)</span><br><span class="line">    a.doSomething();</span><br><span class="line">    //</span><br><span class="line">    // 省略100行</span><br><span class="line">    var b = require(&apos;./b&apos;)</span><br><span class="line">    b.doSomething()</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">// CMD 依赖一开始就需要写好</span><br><span class="line">define([&apos;./a&apos;, &apos;./b&apos;], function(a, b)&#123;</span><br><span class="line">    a.doSomething()</span><br><span class="line">    // 此处省略100行</span><br><span class="line">    b.doSomething()</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure></p>
<p>CMD是服务端模块的规范，一个单独的文件就是一个模块。每个模块都是一个单独的作用域。CommonJS规范规定，每个模块内部，module变量代表当前模块。这个变量是一个对象，它的exports属性（即module.exports）是对外的接口。加载某个模块，其实是加载该模块的module.exports属性。<br>所有代码都运行在模块作用域，不会污染全局作用域。<br>模块可以多次加载，但是只会在第一次加载时运行一次，然后运行结果就被缓存了，以后再加载，就直接读取缓存结果。要想让模块再次运行，必须清除缓存。<br>模块加载的顺序，按照其在代码中出现的顺序。<br>AMD是异步加载模块。由于Node.js主要用于服务器编程，模块文件一般都已经存在于本地硬盘，所以加载起来比较快。不用考虑异步方式。但是浏览器端就比较适合AMD规范。</p>
<hr>
<h1 id="Node-amp-Express"><a href="#Node-amp-Express" class="headerlink" title="Node&amp;Express"></a>Node&amp;Express</h1><ul>
<li>基于node的其他web开发框架</li>
<li>node 有关的知识点</li>
</ul>
<hr>
<h2 id="对Node的优点和缺点提出了自己的看法？"><a href="#对Node的优点和缺点提出了自己的看法？" class="headerlink" title="对Node的优点和缺点提出了自己的看法？"></a>对Node的优点和缺点提出了自己的看法？</h2><p>  *（优点）因为Node是基于事件驱动和无阻塞的，所以非常适合处理并发请求，<br>    因此构建在Node上的代理服务器相比其他技术实现（如Ruby）的服务器表现要好得多。<br>    此外，与Node代理服务器交互的客户端代码是由javascript语言编写的，<br>    因此客户端和服务器端都用同一种语言编写，这是非常美妙的事情。</p>
<p>  *（缺点）Node是一个相对新的开源项目，所以不太稳定，它总是一直在变，<br>    而且缺少足够多的第三方库支持。看起来，就像是Ruby/Rails当年的样子。</p>
<hr>
<h2 id="express"><a href="#express" class="headerlink" title="express"></a>express</h2><p>Express 是一个基于 Node的极简灵活的web 应用开发框架。Express是在Node之上扩展了 Web 应用所需的基本功能。<br>Express完全是由中间件构成一个的 web 开发框架：从本质上来说，一个 Express 应用就是在调用各种中间件。</p>
<h3 id="中间件含义"><a href="#中间件含义" class="headerlink" title="中间件含义"></a>中间件含义</h3><p>是一个函数或功能，（err,res,rep,next），是封装在程序中处理请求的功能。后台的请求分为一部分一部分，每一部分都有中间件来完成,之道响应完毕</p>
<h3 id="Express-几种中间件："><a href="#Express-几种中间件：" class="headerlink" title="Express 几种中间件："></a>Express 几种中间件：</h3><p>应用级中间件<br>绑定到app 对象使用 app.use()和 app.METHOD()， 其中， METHOD 是需要处理的 HTTP 请求的方法，例如 GET, PUT, POST 等等</p>
<p>路由级中间件<br>绑定的对象为 express.Router()。路由级使用 router.use() 加载</p>
<p>错误处理中间件<br>4 个参数，而不是 3 个，其签名如下： (err, req, res, next)。</p>
<p>内置的中间件<br>express.static是 Express 唯一内置的中间件。负责在 Express 应用中托管静态资源。</p>
<p>第三方中间件<br>例如 cookie-parser</p>
<hr>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p> 跨域<br>输入url 经历了什么<br>http连接啥的<br>状态码<br>渲染页面</p>
<hr>
<h2 id="httphttps"><a href="#httphttps" class="headerlink" title="httphttps"></a>httphttps</h2><p><a href="http://www.alloyteam.com/2016/07/httphttp2-0spdyhttps-reading-this-is-enough/" target="_blank" rel="external">http://www.alloyteam.com/2016/07/httphttp2-0spdyhttps-reading-this-is-enough/</a></p>
<hr>
<h2 id="一个页面从输入-URL-到页面加载显示完成，这个过程中都发生了什么？（流程说的越详细越好）"><a href="#一个页面从输入-URL-到页面加载显示完成，这个过程中都发生了什么？（流程说的越详细越好）" class="headerlink" title="一个页面从输入 URL 到页面加载显示完成，这个过程中都发生了什么？（流程说的越详细越好）"></a>一个页面从输入 URL 到页面加载显示完成，这个过程中都发生了什么？（流程说的越详细越好）</h2><p> 详细版：<br>      1、浏览器会开启一个线程来处理这个请求，对 URL 分析判断如果是 http 协议就按照 Web 方式来处理;<br>      2、调用浏览器内核中的对应方法，比如 WebView 中的 loadUrl 方法;<br>      3、通过DNS解析获取网址的IP地址，设置 UA 等信息发出第二个GET请求;<br>      4、进行HTTP协议会话，客户端发送报头(请求报头);<br>      5、进入到web服务器上的 Web Server，如 Apache、Tomcat、Node.JS 等服务器;<br>      6、进入部署好的后端应用，如 PHP、Java、JavaScript、Python 等，找到对应的请求处理;<br>      7、处理结束回馈报头，此处如果浏览器访问过，缓存上有对应资源，会与服务器最后修改时间对比，一致则返回304;<br>      8、浏览器开始下载html文档(响应报头，状态码200)，同时使用缓存;<br>      9、文档树建立，根据标记请求所需指定MIME类型的文件（比如css、js）,同时设置了cookie;<br>      10、页面开始渲染DOM，JS根据DOM API操作DOM,执行事件绑定等，页面显示完成。</p>
<pre><code>简洁版：
  浏览器根据请求的URL交给DNS域名解析，找到真实IP，向服务器发起请求；
  服务器交给后台处理完成后返回数据，浏览器接收文件（HTML、JS、CSS、图象等）；
  浏览器对加载到的资源（HTML、JS、CSS等）进行语法解析，建立相应的内部数据结构（如HTML的DOM）；
  载入解析到的资源文件，渲染页面，完成。
</code></pre><hr>
<h2 id="页面渲染流程主要分三部分"><a href="#页面渲染流程主要分三部分" class="headerlink" title="页面渲染流程主要分三部分"></a>页面渲染流程主要分三部分</h2><p>HTML文档解析生成DOM树<br>DOM树构建完到Webkit绘制上下文<br>上下文到最终生成的图像 (JavaScript省略为JS)<br>当用户输入URL时候，WebKit调用其资源加载器加载该URL对应的网页。<br>加载器依赖网络模块建立连接，发送请求并接受答复。<br>WebKit收到各种网页或资源的数据，可能是同步或者是异步获取的。<br>网页被交给HTML解释器转换成一系列词语(Token)。<br>解释器根据词语构建节点(Node)，形成DOM树。<br>如果节点是JS，调用JS引擎解释并执行。<br>JS代码修改DOM树的结构<br>如果节点需要依赖其他资源，如图片、css等，调用资源加载器来加载他们，但他们是异步的，不会阻碍当前DOM树的继续构建，如果是JS资源URL(未标记异步)，则需要停止当前DOM数的构建，直到JS引擎执行后才继续构建DOM树。 至此会触发两个事件，一个时DOMConent表示DOM构建完全(和jQuery的$(function(){})()一样),后者是 onload 事件，表示DOM树所依赖的各种图片、css等资源加载完毕，通常这两个事件不是同时发生。<br>接下来是利用CSS和DOM树构建RenderObject树直到绘图上下文。</p>
<p>CSS文件被CSS解释器解释成表示结构。<br>CSS解释器完成工作之后，在DOM树上附加解释后的样式信息，包括布局计算，这就是RenderObject树。<br>RenderObject节点在创建的同时，WebKit会根据网页的层次结构创建RenderLayer树，同时构建一个虚拟的绘图上下文。<br>实际上，DOM树，RenderObject树，RenderLayer树和绘图上下文在关闭浏览器前并不会被销毁。</p>
<p>最后，根据绘图上下文生成最终图像，主要依赖2D和3D图形库。</p>
<p>绘图上下文将每个绘图操作桥接到不同的具体实现类，也就是绘图具体实现类，绘图实现类将2D图形库或者3D图形库绘制的结果保存下来，交给浏览器来显示。</p>
<hr>
<h2 id="http状态码有那些？分别代表是什么意思？"><a href="#http状态码有那些？分别代表是什么意思？" class="headerlink" title="http状态码有那些？分别代表是什么意思？"></a>http状态码有那些？分别代表是什么意思？</h2><p>简单版<br>      [<br>          100  Continue    继续，一般在发送post请求时，已发送了http header之后服务端将返回此信息，表示确认，之后发送具体参数信息<br>          200  OK         正常返回信息<br>          201  Created      请求成功并且服务器创建了新的资源<br>          202  Accepted     服务器已接受请求，但尚未处理<br>          301  Moved Permanently  请求的网页已永久移动到新位置。<br>          302 Found          临时性重定向。<br>          303 See Other      临时性重定向，且总是使用 GET 请求新的 URI。<br>          304  Not Modified 自从上次请求后，请求的网页未修改过。</p>
<pre><code>      400 Bad Request  服务器无法理解请求的格式，客户端不应当尝试再次使用相同的内容发起请求。
      401 Unauthorized 请求未授权。
      403 Forbidden      禁止访问。
      404 Not Found      找不到如何与 URI 相匹配的资源。

      500 Internal Server Error  最常见的服务器端错误。
      503 Service Unavailable 服务器端暂时无法处理请求（可能是过载或维护）。
  ]

完整版
1**(信息类)：表示接收到请求并且继续处理
  100——客户必须继续发出请求
  101——客户要求服务器根据请求转换HTTP协议版本

2**(响应成功)：表示动作被成功接收、理解和接受
  200——表明该请求被成功地完成，所请求的资源发送回客户端
  201——提示知道新文件的URL
  202——接受和处理、但处理未完成
  203——返回信息不确定或不完整
  204——请求收到，但返回信息为空
  205——服务器完成了请求，用户代理必须复位当前已经浏览过的文件
  206——服务器已经完成了部分用户的GET请求

3**(重定向类)：为了完成指定的动作，必须接受进一步处理
  300——请求的资源可在多处得到
  301——本网页被永久性转移到另一个URL
  302——请求的网页被转移到一个新的地址，但客户访问仍继续通过原始URL地址，重定向，新的URL会在response中的Location中返回，浏览器将会使用新的URL发出新的Request。
  303——建议客户访问其他URL或访问方式
  304——自从上次请求后，请求的网页未修改过，服务器返回此响应时，不会返回网页内容，代表上次的文档已经被缓存了，还可以继续使用
  305——请求的资源必须从服务器指定的地址得到
  306——前一版本HTTP中使用的代码，现行版本中不再使用
  307——申明请求的资源临时性删除

4**(客户端错误类)：请求包含错误语法或不能正确执行
  400——客户端请求有语法错误，不能被服务器所理解
  401——请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用
  HTTP 401.1 - 未授权：登录失败
  　　HTTP 401.2 - 未授权：服务器配置问题导致登录失败
  　　HTTP 401.3 - ACL 禁止访问资源
  　　HTTP 401.4 - 未授权：授权被筛选器拒绝
  HTTP 401.5 - 未授权：ISAPI 或 CGI 授权失败
  402——保留有效ChargeTo头响应
  403——禁止访问，服务器收到请求，但是拒绝提供服务
  HTTP 403.1 禁止访问：禁止可执行访问
  　　HTTP 403.2 - 禁止访问：禁止读访问
  　　HTTP 403.3 - 禁止访问：禁止写访问
  　　HTTP 403.4 - 禁止访问：要求 SSL
  　　HTTP 403.5 - 禁止访问：要求 SSL 128
  　　HTTP 403.6 - 禁止访问：IP 地址被拒绝
  　　HTTP 403.7 - 禁止访问：要求客户证书
  　　HTTP 403.8 - 禁止访问：禁止站点访问
  　　HTTP 403.9 - 禁止访问：连接的用户过多
  　　HTTP 403.10 - 禁止访问：配置无效
  　　HTTP 403.11 - 禁止访问：密码更改
  　　HTTP 403.12 - 禁止访问：映射器拒绝访问
  　　HTTP 403.13 - 禁止访问：客户证书已被吊销
  　　HTTP 403.15 - 禁止访问：客户访问许可过多
  　　HTTP 403.16 - 禁止访问：客户证书不可信或者无效
  HTTP 403.17 - 禁止访问：客户证书已经到期或者尚未生效
  404——一个404错误表明可连接服务器，但服务器无法取得所请求的网页，请求资源不存在。eg：输入了错误的URL
  405——用户在Request-Line字段定义的方法不允许
  406——根据用户发送的Accept拖，请求资源不可访问
  407——类似401，用户必须首先在代理服务器上得到授权
  408——客户端没有在用户指定的饿时间内完成请求
  409——对当前资源状态，请求不能完成
  410——服务器上不再有此资源且无进一步的参考地址
  411——服务器拒绝用户定义的Content-Length属性请求
  412——一个或多个请求头字段在当前请求中错误
  413——请求的资源大于服务器允许的大小
  414——请求的资源URL长于服务器允许的长度
  415——请求资源不支持请求项目格式
  416——请求中包含Range请求头字段，在当前请求资源范围内没有range指示值，请求也不包含If-Range请求头字段
  417——服务器不满足请求Expect头字段指定的期望值，如果是代理服务器，可能是下一级服务器不能满足请求长。

5**(服务端错误类)：服务器不能正确执行一个正确的请求
  HTTP 500 - 服务器遇到错误，无法完成请求
  　　HTTP 500.100 - 内部服务器错误 - ASP 错误
  　　HTTP 500-11 服务器关闭
  　　HTTP 500-12 应用程序重新启动
  　　HTTP 500-13 - 服务器太忙
  　　HTTP 500-14 - 应用程序无效
  　　HTTP 500-15 - 不允许请求 global.asa
  　　Error 501 - 未实现
HTTP 502 - 网关错误
HTTP 503：由于超载或停机维护，服务器目前无法使用，一段时间后可能恢复正常
</code></pre><hr>
<h1 id="JQUERY"><a href="#JQUERY" class="headerlink" title="JQUERY"></a>JQUERY</h1><h2 id="1-你在公司是怎么用jquery的？"><a href="#1-你在公司是怎么用jquery的？" class="headerlink" title="1 你在公司是怎么用jquery的？"></a>1 你在公司是怎么用jquery的？</h2><p>答：在项目中是怎么用的是看看你有没有项目经验(根据自己的实际情况来回答) 你用过的选择器啊，复选框啊，表单啊，ajax啊，事件等配置<a href="http://lib.csdn.net/base/jquery" target="_blank" rel="external">jQuery</a>环境 下载jquery类库 在jsp页面引用jquery类库即可</p>
<p><script type="text/[JavaScript](http://lib.csdn.net/base/javascript)" src="jquery/jquery-1.7.2.min.js">接下来通过在<script> $(function(){ }); </script></p>
<h2 id="2-你为什么要使用jquery？"><a href="#2-你为什么要使用jquery？" class="headerlink" title="2 你为什么要使用jquery？"></a>2 你为什么要使用jquery？</h2><p>答：因为jQuery是轻量级的框架，大小不到30kb,它有强大的选择器，出色的DOM操作的封装，有可靠的事件处理机制(jQuery在处理事件绑定的时候相当的可靠)，完善的ajax(它的ajax封装的非常的好，不需要考虑复杂浏览器的兼容性和XMLHttpRequest对象的创建和使用的问题。) 出色的浏览器的兼容性。 而且支持链式操作，隐式迭代。行为层和结构层的分离，还支持丰富的插件，jquery的文档也非常的丰富。</p>
<h2 id="3-你觉得jquery有哪些好处？-答案同上"><a href="#3-你觉得jquery有哪些好处？-答案同上" class="headerlink" title="3 你觉得jquery有哪些好处？ 答案同上"></a>3 你觉得jquery有哪些好处？ 答案同上</h2><h2 id="4-你使用jquery遇到过哪些问题，你是怎么解决的？"><a href="#4-你使用jquery遇到过哪些问题，你是怎么解决的？" class="headerlink" title="4 你使用jquery遇到过哪些问题，你是怎么解决的？"></a>4 你使用jquery遇到过哪些问题，你是怎么解决的？</h2><p>答：这个答案是开发的，看你是否有相关的项目经验。例前台拿不到值，JSON 可是出现的错误(多了一个空格等)这编译是不会报错的 jquery库与其他库冲突：1&gt;如果其他库在jquery库之前导入的话1.我们可以通过jquery.noconflict()将变量的$的控制权过度给其他库2.自定义快捷键,用一个变量接住jquery.noconflict()3.通过函数传参2&gt;如果jquery库在其他库之前导入就直接使用jquery今天在处理一个数据问题时，发现jQuery.ajax()方法返回的值一直有问题，清除缓存后数据无误，多次<a href="http://lib.csdn.net/base/softwaretest" target="_blank" rel="external">测试</a>后发现返回的值都是之前的值，并且一直未执行url(后台为<a href="http://lib.csdn.net/base/javase" target="_blank" rel="external">Java</a>，设置断点一直未进入)。在网上查找下,发现是未设置type的原因。 如果没设置jQuery.ajax的type=”Post”，那么ajax就会默认type=”Get”，这就会导致之前数据被缓存起来。加上type=”Post”，问题解决！</p>
<h2 id="5-你知道jquery中的选择器吗，请讲一下有哪些选择器？"><a href="#5-你知道jquery中的选择器吗，请讲一下有哪些选择器？" class="headerlink" title="5 你知道jquery中的选择器吗，请讲一下有哪些选择器？"></a>5 你知道jquery中的选择器吗，请讲一下有哪些选择器？</h2><p>答 ：jQuery中的选择器大致分为:基本选择器，层次选择器，过滤选择器，表单选择器</p>
<h2 id="6-jquery中的选择器-和-css中的选择器有区别吗？"><a href="#6-jquery中的选择器-和-css中的选择器有区别吗？" class="headerlink" title="6 jquery中的选择器 和 css中的选择器有区别吗？"></a>6 jquery中的选择器 和 css中的选择器有区别吗？</h2><p>答：jQuery选择器支持CSS里的选择器，jQuery选择器可用来添加样式和添加相应的行为CSS 中的选择器是只能添加相应的样式</p>
<h2 id="7-你觉得jquery中的选择器有什么优势？"><a href="#7-你觉得jquery中的选择器有什么优势？" class="headerlink" title="7 你觉得jquery中的选择器有什么优势？"></a>7 你觉得jquery中的选择器有什么优势？</h2><p>答：简单的写法 $(‘ID’) 来代替 document.getElementById()函数支持CSS1 到<a href="http://lib.csdn.net/base/css3" target="_blank" rel="external">CSS3</a> 选择器完善的处理机制(就算写错了id也不会报错)</p>
<h2 id="8-你在使用选择器的时候有有没有什么觉得要注意的地方？"><a href="#8-你在使用选择器的时候有有没有什么觉得要注意的地方？" class="headerlink" title="8 你在使用选择器的时候有有没有什么觉得要注意的地方？"></a>8 你在使用选择器的时候有有没有什么觉得要注意的地方？</h2><p>答: 1 选择器中含有”.”,”#”,”[“ 等特殊字符的时候需要进行转译2 属性选择器的引号问题3 选择器中含有空格的注意事项</p>
<h2 id="9-jquery对象和dom对象是怎样转换的？"><a href="#9-jquery对象和dom对象是怎样转换的？" class="headerlink" title="9 jquery对象和dom对象是怎样转换的？"></a>9 jquery对象和dom对象是怎样转换的？</h2><p>答 ：jquery转DOM对象:jQuery 对象是一个数组对象，可以通过[index]的丰富得到相应的DOM对象还可以通过get[index]去得到相应的DOM对象。DOM对象转jQuery对象:$(DOM对象)</p>
<h2 id="10-你是如何使用jquery中的ajax的？"><a href="#10-你是如何使用jquery中的ajax的？" class="headerlink" title="10 你是如何使用jquery中的ajax的？"></a>10 你是如何使用jquery中的ajax的？</h2><p>答: 如果是一些常规的ajax程序的话，使用load(),$.get(),$.post(),就可以搞定了，一般我会使用的是$.post() 方法。如果需要设定beforeSend(提交前回调函数),error(失败后处理),success(成功后处理)及complete(请求完成后处理)回调函数等，这个时候我会使用$.ajax()</p>
<h2 id="11-你觉得jquery中的ajax好用吗，为什么？"><a href="#11-你觉得jquery中的ajax好用吗，为什么？" class="headerlink" title="11 你觉得jquery中的ajax好用吗，为什么？"></a>11 你觉得jquery中的ajax好用吗，为什么？</h2><p>答: 好用的。 因为jQuery提供了一些日常开发中夙瑶的快捷操作，例 load，ajax，get，post等等，所以使用jQuery开发ajax将变得极其简单，我们就可以集中精力在业务和用户的体验上，不需要去理会那些繁琐的XMLHttpRequest对象了。</p>
<h2 id="12-jquery中-get-提交和-post-提交有区别吗？"><a href="#12-jquery中-get-提交和-post-提交有区别吗？" class="headerlink" title="12 jquery中$.get()提交和$.post()提交有区别吗？"></a>12 jquery中$.get()提交和$.post()提交有区别吗？</h2><p>答: 1 $.get() 方法使用GET方法来进行异步请求的。$.post() 方法使用POST方法来进行异步请求的。2 get请求会将参数跟在URL后进行传递，而POST请求则是作为HTTP消息的实体内容发送给Web服务器的，这种传递是对用户不可见的。3 get方式传输的数据大小不能超过2KB 而POST要大的多4 GET 方式请求的数据会被浏览器缓存起来，因此有安全问题。</p>
<h2 id="13-jquery中的load方法一般怎么用的？"><a href="#13-jquery中的load方法一般怎么用的？" class="headerlink" title="13 jquery中的load方法一般怎么用的？"></a>13 jquery中的load方法一般怎么用的？</h2><p>答：load方法一般在 载入远程HTML 代码并插入到DOM中的时候用，通常用来从Web服务器上获取静态的数据文件。如果要传递参数的话，可以使用$.get() 或 $.post()。</p>
<h2 id="14-在jquery中你是如何去操作样式的？"><a href="#14-在jquery中你是如何去操作样式的？" class="headerlink" title="14 在jquery中你是如何去操作样式的？"></a>14 在jquery中你是如何去操作样式的？</h2><p>答: addClass() 来追加样式 ，removeClass() 来删除样式，toggle() 来切换样式</p>
<h2 id="15-简单的讲叙一下jquery是怎么处理事件的，你用过哪些事件？"><a href="#15-简单的讲叙一下jquery是怎么处理事件的，你用过哪些事件？" class="headerlink" title="15 简单的讲叙一下jquery是怎么处理事件的，你用过哪些事件？"></a>15 简单的讲叙一下jquery是怎么处理事件的，你用过哪些事件？</h2><p>答: 首先去装载文档，在页面家在完毕后，浏览器会通过javascript 为DOM元素添加事件。</p>
<h2 id="16-你使用过jquery中的动画吗，是怎样用的？"><a href="#16-你使用过jquery中的动画吗，是怎样用的？" class="headerlink" title="16 你使用过jquery中的动画吗，是怎样用的？"></a>16 你使用过jquery中的动画吗，是怎样用的？</h2><p>答:使用过。hide() 和 show() 同时修改多个样式属性。像高度，宽度，不透明度。 fadeIn() 和fadeOut() fadeTo() 只改变不透明度slideUp() 和 slideDown() slideToggle() 只改变高度animate() 属于自定义动画的方法.</p>
<h2 id="17-你使用过jquery中的插件吗？-答-看个人的实力和经验来回答了。"><a href="#17-你使用过jquery中的插件吗？-答-看个人的实力和经验来回答了。" class="headerlink" title="17 你使用过jquery中的插件吗？ 答:看个人的实力和经验来回答了。"></a>17 你使用过jquery中的插件吗？ 答:看个人的实力和经验来回答了。</h2><h2 id="18-你一般用什么去提交数据，为什么？"><a href="#18-你一般用什么去提交数据，为什么？" class="headerlink" title="18 你一般用什么去提交数据，为什么？"></a>18 你一般用什么去提交数据，为什么？</h2><p>答:一般我会使用的是$.post() 方法。如果需要设定beforeSend(提交前回调函数),error(失败后处理),success(成功后处理及complete(请求完成后处理)回调函数等，这个时候我会使用$.ajax()</p>
<h2 id="19-在jquery中引入css有几种方式？"><a href="#19-在jquery中引入css有几种方式？" class="headerlink" title="19 在jquery中引入css有几种方式？"></a>19 在jquery中引入css有几种方式？</h2><p>答:四种 行内式，内嵌式，导入式，链接式</p>
<h2 id="20-你在jquery中使用过哪些插入节点的方法，它们的区别是什么？"><a href="#20-你在jquery中使用过哪些插入节点的方法，它们的区别是什么？" class="headerlink" title="20 你在jquery中使用过哪些插入节点的方法，它们的区别是什么？"></a>20 你在jquery中使用过哪些插入节点的方法，它们的区别是什么？</h2><p>答:append(),appendTo(),prepend(),prependTo(),after(),insertAfter()，before(),insertBefore() 大致可以分为 内部追加和外部追加append() 表式向每个元素内部追加内容。appendTo()表示 讲所有的元素追加到指定的元素中。例$(A)appendTo(B) 是将A追加到B中下面的方法解释类似。</p>
<h2 id="21-你使用过包裹节点的方法吗，包裹节点有方法有什么好处？"><a href="#21-你使用过包裹节点的方法吗，包裹节点有方法有什么好处？" class="headerlink" title="21 你使用过包裹节点的方法吗，包裹节点有方法有什么好处？"></a>21 你使用过包裹节点的方法吗，包裹节点有方法有什么好处？</h2><p>答: wrapAll(),wrap(), wrapInner() 需要在文档中插入额外的结构化标记的时候可以使用这些包裹的方法应为它不会帛画原始文档的语义</p>
<h2 id="22-jquery中如何来获取或和设置属性？"><a href="#22-jquery中如何来获取或和设置属性？" class="headerlink" title="22 jquery中如何来获取或和设置属性？"></a>22 jquery中如何来获取或和设置属性？</h2><p>jQuery中可以用attr()方法来获取和设置元素属性removeAttr() 方法来删除元素属性</p>
<h2 id="23-如何来设置和获取HTML-和文本的值？"><a href="#23-如何来设置和获取HTML-和文本的值？" class="headerlink" title="23 如何来设置和获取HTML 和文本的值？"></a>23 如何来设置和获取HTML 和文本的值？</h2><p>答：html()方法 类似于innerHTML属性 可以用来读取或者设置某个元素中的HTML内容注意：html() 可以用于xhtml文档 不能用于xml文档text() 类似于innerText属性 可以用来读取或设置某个元素中文本内容。val() 可以用来设置和获取元素的值</p>
<h2 id="24-你jquery中有哪些方法可以遍历节点？"><a href="#24-你jquery中有哪些方法可以遍历节点？" class="headerlink" title="24 你jquery中有哪些方法可以遍历节点？"></a>24 你jquery中有哪些方法可以遍历节点？</h2><p>答 ：children() 取得匹配元素的子元素集合,只考虑子元素不考虑后代元素 next() 取得匹配元素后面紧邻的同辈元素prev() 取得匹配元素前面紧邻的同辈元素siblings() 取得匹配元素前后的所有同辈元素closest() 取得最近的匹配元素find() 取得匹配元素中的元素集合 包括子代和后代</p>
<h2 id="25-子元素选择器-和后代选择器元素有什么区别？"><a href="#25-子元素选择器-和后代选择器元素有什么区别？" class="headerlink" title="25 子元素选择器 和后代选择器元素有什么区别？"></a>25 子元素选择器 和后代选择器元素有什么区别？</h2><p>答:子代元素是找子节点下的所有元素,后代元素是找子节点或子节点的子节点中的元素</p>
<h2 id="26-在jquery中可以替换节点吗？"><a href="#26-在jquery中可以替换节点吗？" class="headerlink" title="26 在jquery中可以替换节点吗？"></a>26 在jquery中可以替换节点吗？</h2><p>答：可以 在jQuery中有两者替换节点的方式 replaceWith() 和 replaceAll()例如在</p><p title="hao are you">hao are you</p>替换成<strong>I am fine</strong>$(‘p’).replaceWith(‘<strong>I am fine</strong>‘); replaceAll 与replaceWith的用法前后调换一下即可。<em>**</em><p></p>
<h2 id="27-你觉得beforeSend方法有什么用？"><a href="#27-你觉得beforeSend方法有什么用？" class="headerlink" title="27 你觉得beforeSend方法有什么用？"></a>27 你觉得beforeSend方法有什么用？</h2><p>答：发送请求前可以修改XMLHttpRequest对象的函数，在beforeSend中如果返回false 可以取消本次的Ajax请求。XMLHttpRequest对象是唯一的参数所以在这个方法里可以做验证</p>
<h2 id="28-siblings-方法-和-‘prev-div’-选择器是一样的嘛？"><a href="#28-siblings-方法-和-‘prev-div’-选择器是一样的嘛？" class="headerlink" title="28 siblings() 方法 和 $(‘prev~div’)选择器是一样的嘛？"></a>28 siblings() 方法 和 $(‘prev~div’)选择器是一样的嘛？</h2><p>答: $(‘prev~div’) 只能选择’#prev’元素后面的同辈<div>元素而siblings()方法与前后的文职无关，只要是同辈节点就都能匹配。</div></p>
<h2 id="29-你在ajax中使用过JSON吗，你是如何用的？"><a href="#29-你在ajax中使用过JSON吗，你是如何用的？" class="headerlink" title="29 你在ajax中使用过JSON吗，你是如何用的？"></a>29 你在ajax中使用过JSON吗，你是如何用的？</h2><p>答:使用过，在$.getJSON() 方法的时候就是。因为 $.getJSON() 就是用于加载JSON文件的</p>
<h2 id="30-有哪些查询节点的选择器？"><a href="#30-有哪些查询节点的选择器？" class="headerlink" title="30 有哪些查询节点的选择器？"></a>30 有哪些查询节点的选择器？</h2><p>答：我在公司使用过 :first 查询第一个，:last 查询最后一个，:odd查询奇数但是索引从0开始:even 查询偶数，:eq(index)查询相等的 ,:gt(index)查询大于index的 ,:lt查询小于index:header 选取所有的标题等</p>
<h2 id="31-nextAll-能-替代-‘prev-siblindgs’-选择器吗？"><a href="#31-nextAll-能-替代-‘prev-siblindgs’-选择器吗？" class="headerlink" title="31 nextAll() 能 替代$(‘prev~siblindgs’)选择器吗？"></a>31 nextAll() 能 替代$(‘prev~siblindgs’)选择器吗？</h2><p>答:能。 使用nextAll() 和使用$(‘prev~siblindgs’) 是一样的</p>
<h2 id="32-jQuery中有几种方法可以来设置和获取样式"><a href="#32-jQuery中有几种方法可以来设置和获取样式" class="headerlink" title="32 jQuery中有几种方法可以来设置和获取样式"></a>32 jQuery中有几种方法可以来设置和获取样式</h2><p>答 ：addClass() 方法，attr() 方法</p>
<h2 id="33-document-ready-方法和window-onload有什么区别？"><a href="#33-document-ready-方法和window-onload有什么区别？" class="headerlink" title="33 $(document).ready()方法和window.onload有什么区别？"></a>33 $(document).ready()方法和window.onload有什么区别？</h2><p>答: 两个方法有相似的功能，但是在实行时机方面是有区别的。 1window.onload方法是在网页中所有的元素(包括元素的所有关联文件)完全加载到浏览器后才执行的。2 $(document).ready() 方法可以在DOM载入就绪时就对其进行操纵，并调用执行绑定的函数。</p>
<h2 id="34-jQuery是如何处理缓存的？"><a href="#34-jQuery是如何处理缓存的？" class="headerlink" title="34 jQuery是如何处理缓存的？"></a>34 jQuery是如何处理缓存的？</h2><p>答 ：要处理缓存就是禁用缓存.1 通过$.post() 方法来获取数据，那么默认就是禁用缓存的。2 通过$.get()方法 来获取数据，可以通过设置时间戳来避免缓存。可以在URL后面加上+(+new Date)例 $.get(‘ajax.xml?’+(+new Date),function () { //内容 }); 3 通过$.ajax 方法来获取数据，只要设置cache:false即可。</p>
<h2 id="35-getScript-方法-和-getJson-方法有什么区别？"><a href="#35-getScript-方法-和-getJson-方法有什么区别？" class="headerlink" title="35 $.getScript()方法 和 $.getJson() 方法有什么区别？"></a>35 $.getScript()方法 和 $.getJson() 方法有什么区别？</h2><p>答: 1 $.getScript() 方法可以直接加载.js文件，并且不需要对javascript文件进行处理，javascript文件会自动执行。2 $.getJson() 是用于加载JSON 文件的 ，用法和$.getScript()</p>

      
    </div>

    <div>
      
        
      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
          </div>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2016/07/02/hexo-gihubpages-搭建博客/" rel="prev" title="最详尽-hexo+GithubPages搭建博客">
                最详尽-hexo+GithubPages搭建博客 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
        
<script>
  with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?cdnversion='+~(-new Date()/36e5)];
</script>

      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
      <div class="ds-thread" data-thread-key="2016/06/27/ms/"
           data-title="ms" data-url="http://carryguan.com/2016/06/27/ms/">
      </div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/me2.jpg"
               alt="Carry Guan" />
          <p class="site-author-name" itemprop="name">Carry Guan</p>
          <p class="site-description motion-element" itemprop="description">写写代码，看看韩剧.好开心呀，又吃成长快乐了 ^~^.</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">14</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">51</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/sunningcarryhaha" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/5048785433/profile?topnav=1&wvr=6&is_all=1" target="_blank" title="Weibo">
                  
                    <i class="fa fa-fw fa-weibo"></i>
                  
                  Weibo
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://www.zhihu.com/people/guan-kai-li-88" target="_blank" title="ZhiHu">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  ZhiHu
                </a>
              </span>
            
          
        </div>

        
        

        
        
          <div class="links-of-blogroll motion-element links-of-blogroll-inline">
            <div class="links-of-blogroll-title">
              <i class="fa  fa-fw fa-globe"></i>
              Links
            </div>
            <ul class="links-of-blogroll-list">
              
                <li class="links-of-blogroll-item">
                  <a href="https://www.betterwill.me" title="LiuXiaojian" target="_blank">LiuXiaojian</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="http://yuanguangxin.me" title="Yuanguangxin" target="_blank">Yuanguangxin</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="http://huangxuan.me" title="Nanshen" target="_blank">Nanshen</a>
                </li>
              
            </ul>
          </div>
        

      </section>

      
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">
            
              
            
            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#HTML"><span class="nav-text">HTML</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#常见的行内元素与块级元素都有哪些，分别举例-，并说一说区别5"><span class="nav-text">常见的行内元素与块级元素都有哪些，分别举例 ，并说一说区别5%</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#居中的常见方法-水平，竖直-5"><span class="nav-text">居中的常见方法(水平，竖直) 5%</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-水平居中的-margin：0-auto"><span class="nav-text">1.水平居中的 margin：0 auto;</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-水平居中-text-align：center；"><span class="nav-text">2.水平居中 text-align：center；</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#水平垂直居中（一）-定位-要垂直居中的宽高-需要定位的元素的margin减去宽高的一半"><span class="nav-text">水平垂直居中（一） 定位 要垂直居中的宽高 需要定位的元素的margin减去宽高的一半</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#水平垂直居中（二）定位和margin-auto，不用受到宽高的限制"><span class="nav-text">水平垂直居中（二）定位和margin:auto，不用受到宽高的限制,</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#水平垂直居中（三）绝对定位和transfrom"><span class="nav-text">水平垂直居中（三）绝对定位和transfrom</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#水平垂直居中（四）diplay：table-cell"><span class="nav-text">水平垂直居中（四）diplay：table-cell</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#水平垂直居中（五）flexBox居中"><span class="nav-text">水平垂直居中（五）flexBox居中</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#说一下为什么要清除浮动以及常见的清除浮动的方法-4"><span class="nav-text">说一下为什么要清除浮动以及常见的清除浮动的方法 4%</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#方法一：添加新的元素-、应用-clear：both"><span class="nav-text">方法一：添加新的元素 、应用 clear：both</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#方法二：父级div定义-overflow-auto（hidden也可以，就是对seo不太友好）"><span class="nav-text">方法二：父级div定义 overflow: auto（hidden也可以，就是对seo不太友好）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#方法三：-据说是最高大上的方法-after-方法：（注意：作用于浮动元素的父亲）"><span class="nav-text">方法三： 据说是最高大上的方法  :after 方法：（注意：作用于浮动元素的父亲）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#介绍一下标准的CSS的盒子模型？低版本IE的盒子模型有什么不同的？"><span class="nav-text">介绍一下标准的CSS的盒子模型？低版本IE的盒子模型有什么不同的？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#position-的几种值-，详细说明一下每种的区别-3"><span class="nav-text">position 的几种值 ，详细说明一下每种的区别 3%</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#如果position设置成absolute属性该元素的display属性会变成什么"><span class="nav-text">如果position设置成absolute属性该元素的display属性会变成什么</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#display-有几个值-3"><span class="nav-text">display 有几个值  3%</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#伪类-伪元素"><span class="nav-text">伪类 伪元素</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CSS3新增伪类有那些？"><span class="nav-text">CSS3新增伪类有那些？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CSS选择器有哪些？哪些属性可以继承？"><span class="nav-text">CSS选择器有哪些？哪些属性可以继承？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CSS优先级算法如何计算？"><span class="nav-text">CSS优先级算法如何计算？</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#同权重"><span class="nav-text">同权重</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#属性选择器的权重问题"><span class="nav-text">属性选择器的权重问题:</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#页面导入样式时，使用link和-import有什么区别？"><span class="nav-text">页面导入样式时，使用link和@import有什么区别？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#引入css的几种方式-2"><span class="nav-text">引入css的几种方式 2%</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-行内样式"><span class="nav-text">1.行内样式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-内嵌样式"><span class="nav-text">2.内嵌样式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-链接样式"><span class="nav-text">3.链接样式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-导入样式（不建议使用）"><span class="nav-text">4.导入样式（不建议使用）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#四种CSS引入方式的优先级"><span class="nav-text">四种CSS引入方式的优先级</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#锚点-1"><span class="nav-text">锚点 1%</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#两栏布局"><span class="nav-text">两栏布局</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-左定宽高-浮动，-右边设置margin-left"><span class="nav-text">1:左定宽高 浮动， 右边设置margin - left</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-定位-：左边定宽高-设置定位position-absolute-left-0"><span class="nav-text">2:定位 ：左边定宽高 ,设置定位position absolute, left 0 ;</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#实现三列布局"><span class="nav-text">实现三列布局</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BFC的通俗理解："><span class="nav-text">BFC的通俗理解：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BFC规范中的定义："><span class="nav-text">BFC规范中的定义：</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#BFC的特性"><span class="nav-text">BFC的特性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#BFC的常见应用"><span class="nav-text">BFC的常见应用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#常见的浏览器端的存储技术都有哪些，以及他们的优缺点和使用场景？"><span class="nav-text">常见的浏览器端的存储技术都有哪些，以及他们的优缺点和使用场景？</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#cookie"><span class="nav-text">cookie</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Flash-ShareObject"><span class="nav-text">Flash ShareObject</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#sessionStorage"><span class="nav-text">sessionStorage</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#localStorage"><span class="nav-text">localStorage</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#globalStorage"><span class="nav-text">globalStorage</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Google-Gear"><span class="nav-text">Google Gear</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#userData"><span class="nav-text">userData</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#请描述一下-cookies，sessionStorage-和-localStorage-的区别？"><span class="nav-text">请描述一下 cookies，sessionStorage 和 localStorage 的区别？</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#存储大小："><span class="nav-text">存储大小：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#有期时间："><span class="nav-text">有期时间：</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#html-获取页面，浏览器，屏幕宽高"><span class="nav-text">html 获取页面，浏览器，屏幕宽高</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Doctype"><span class="nav-text">Doctype</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#标准模式与兼容模式（怪异模式）各有什么区别"><span class="nav-text">标准模式与兼容模式（怪异模式）各有什么区别?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#介绍一下你对浏览器内核的理解？"><span class="nav-text">介绍一下你对浏览器内核的理解？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HTML、XML、XHTML-有什么区别？"><span class="nav-text">HTML、XML、XHTML 有什么区别？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#怎样理解-HTML-语义化？"><span class="nav-text">怎样理解 HTML 语义化？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#怎样理解内容与样式分离的原则"><span class="nav-text">怎样理解内容与样式分离的原则</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#title与h1的区别、b与strong的区别、i与em的区别？"><span class="nav-text">title与h1的区别、b与strong的区别、i与em的区别？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#页面可见性（Page-Visibility-API）-可以有哪些用途？"><span class="nav-text">页面可见性（Page Visibility API） 可以有哪些用途？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#iframe有那些缺点？"><span class="nav-text">iframe有那些缺点？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#为什么要初始化CSS样式。"><span class="nav-text">为什么要初始化CSS样式。</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#用纯CSS创建一个三角形的原理是什么？"><span class="nav-text">用纯CSS创建一个三角形的原理是什么？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#经常遇到的浏览器的兼容性有哪些？原因，解决方法是什么，常用hack的技巧-？"><span class="nav-text">经常遇到的浏览器的兼容性有哪些？原因，解决方法是什么，常用hack的技巧 ？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#什么是外边距合并？"><span class="nav-text">什么是外边距合并？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#zoom-1的清除浮动原理"><span class="nav-text">zoom:1的清除浮动原理?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#如何居中div？"><span class="nav-text">如何居中div？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#position的值relative和absolute定位原点是？"><span class="nav-text">position的值relative和absolute定位原点是？</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#HTML5"><span class="nav-text">HTML5</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#新特性"><span class="nav-text">新特性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-标签语义化，"><span class="nav-text">1:标签语义化，</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2、音视频元素，"><span class="nav-text">2、音视频元素，</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3、新增很多api，"><span class="nav-text">3、新增很多api，</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#、websocket"><span class="nav-text">、websocket</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#、HTML5-能够本地存储数据，在之前都是使用-cookies-使用的。"><span class="nav-text">、HTML5 能够本地存储数据，在之前都是使用 cookies 使用的。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#：请描述一下-cookies，sessionStorage-和-localStorage-的区别？"><span class="nav-text">：请描述一下 cookies，sessionStorage 和 localStorage 的区别？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#、应用程序缓存："><span class="nav-text">、应用程序缓存：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#、web-worker，web-worker"><span class="nav-text">、web worker，web worker</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#CSS3"><span class="nav-text">CSS3</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#css3的新特性哪些，你都用过哪些-5"><span class="nav-text">css3的新特性哪些，你都用过哪些 5%</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#媒体查询具体到语句-5"><span class="nav-text">媒体查询具体到语句 5%</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#响应式布局meta-scale-怎样使用media"><span class="nav-text">响应式布局meta,scale 怎样使用media?</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#meta-scale"><span class="nav-text">meta,scale</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#第二步：媒体查询-语句"><span class="nav-text">第二步：媒体查询 语句</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#css-伪类-5"><span class="nav-text">css 伪类 5%</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#伪类选择器"><span class="nav-text">伪类选择器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#伪类-伪元素-1"><span class="nav-text">伪类 伪元素</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#说一下flex-3"><span class="nav-text">说一下flex 3%</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#请解释一下CSS3的Flexbox（弹性盒布局模型）-以及适用场景？"><span class="nav-text">请解释一下CSS3的Flexbox（弹性盒布局模型）,以及适用场景？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#动画-2"><span class="nav-text">动画 2%</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#css3动画卡了"><span class="nav-text">css3动画卡了</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#JS"><span class="nav-text">JS</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#js数据类型有哪些-5"><span class="nav-text">js数据类型有哪些 5%</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#null-和undefined"><span class="nav-text">null 和undefined</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#原型-原型链-原型继承（说一下原型-原型链，考了几道题-让你现在作答）-5"><span class="nav-text">原型 原型链 原型继承（说一下原型 原型链，考了几道题 让你现在作答） 5%</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#原型"><span class="nav-text">原型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#原型链"><span class="nav-text">原型链</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#继承"><span class="nav-text">继承</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#原型链继承-child-prototype-new-father"><span class="nav-text">原型链继承 child.prototype = new father()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#借用构造函数继承-经典继承"><span class="nav-text">借用构造函数继承/经典继承</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#组合继承（原型链继承-借用构造函数继承）"><span class="nav-text">组合继承（原型链继承+借用构造函数继承）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#原型式继承-var-childObj-Object-create-fatherObj-Object-create-create"><span class="nav-text">原型式继承 var childObj = Object.create(fatherObj) //Object.create() = create()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#寄生式继承"><span class="nav-text">寄生式继承</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#寄生组合式继承"><span class="nav-text">寄生组合式继承</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#闭包5"><span class="nav-text">闭包5%</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#故事版本的讲解"><span class="nav-text">故事版本的讲解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#什么是闭包？"><span class="nav-text">什么是闭包？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#为什么需要闭包呢-闭包存在的意义-？"><span class="nav-text">为什么需要闭包呢(闭包存在的意义)？</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#特点"><span class="nav-text">特点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#如何使用"><span class="nav-text">如何使用</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#js事件-5"><span class="nav-text">js事件 5%</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#事件模型"><span class="nav-text">事件模型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#事件委托"><span class="nav-text">事件委托</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#原生js的-增-删-改-5"><span class="nav-text">原生js的(增 删 改) 5%</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#增"><span class="nav-text">增</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#删"><span class="nav-text">删</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#改"><span class="nav-text">改</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#查"><span class="nav-text">查</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#jq增删改查"><span class="nav-text">jq增删改查</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#跨域"><span class="nav-text">跨域</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#if-false-的几种情况"><span class="nav-text">if() false 的几种情况</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Ajax实现流程"><span class="nav-text">Ajax实现流程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#单线程"><span class="nav-text">单线程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#垃圾回收"><span class="nav-text">垃圾回收</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#javascript创建对象的几种方式？"><span class="nav-text">javascript创建对象的几种方式？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JavaScript有几种类型的值？，你能画一下他们的内存图吗？"><span class="nav-text">JavaScript有几种类型的值？，你能画一下他们的内存图吗？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#说几条写JavaScript的基本规范？"><span class="nav-text">说几条写JavaScript的基本规范？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#封装cookie的添加，删除，查询方法"><span class="nav-text">封装cookie的添加，删除，查询方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#同源策略"><span class="nav-text">同源策略</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#介绍js有哪些内置对象？"><span class="nav-text">介绍js有哪些内置对象？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#作用域与作用域链-？"><span class="nav-text">作用域与作用域链 ？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#this指向"><span class="nav-text">this指向</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#函数有所属对象时：指向所属对象"><span class="nav-text">函数有所属对象时：指向所属对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#没调用对象就指向全局对象"><span class="nav-text">没调用对象就指向全局对象</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#构造器中的-this：指向新对象"><span class="nav-text">构造器中的 this：指向新对象</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#apply-和-call-调用以及-bind-绑定：指向绑定的对象"><span class="nav-text">apply 和 call 调用以及 bind 绑定：指向绑定的对象</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#js常用算法"><span class="nav-text">js常用算法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#判断一个单词是否是回文？"><span class="nav-text">判断一个单词是否是回文？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#去掉一组整型数组重复的值"><span class="nav-text">去掉一组整型数组重复的值</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#统计一个字符串出现最多的字母"><span class="nav-text">统计一个字符串出现最多的字母</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#快排"><span class="nav-text">快排</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#获取数组中最大或者最小值"><span class="nav-text">获取数组中最大或者最小值</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#找出下列正数组的最大差值比如"><span class="nav-text">找出下列正数组的最大差值比如:</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#随机生成指定长度的字符串"><span class="nav-text">随机生成指定长度的字符串</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#正則"><span class="nav-text">正則</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#模块化"><span class="nav-text">模块化</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#AMD与CMD"><span class="nav-text">AMD与CMD</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Node-amp-Express"><span class="nav-text">Node&Express</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#对Node的优点和缺点提出了自己的看法？"><span class="nav-text">对Node的优点和缺点提出了自己的看法？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#express"><span class="nav-text">express</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#中间件含义"><span class="nav-text">中间件含义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Express-几种中间件："><span class="nav-text">Express 几种中间件：</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#其他"><span class="nav-text">其他</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#httphttps"><span class="nav-text">httphttps</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#一个页面从输入-URL-到页面加载显示完成，这个过程中都发生了什么？（流程说的越详细越好）"><span class="nav-text">一个页面从输入 URL 到页面加载显示完成，这个过程中都发生了什么？（流程说的越详细越好）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#页面渲染流程主要分三部分"><span class="nav-text">页面渲染流程主要分三部分</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#http状态码有那些？分别代表是什么意思？"><span class="nav-text">http状态码有那些？分别代表是什么意思？</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#JQUERY"><span class="nav-text">JQUERY</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-你在公司是怎么用jquery的？"><span class="nav-text">1 你在公司是怎么用jquery的？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-你为什么要使用jquery？"><span class="nav-text">2 你为什么要使用jquery？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-你觉得jquery有哪些好处？-答案同上"><span class="nav-text">3 你觉得jquery有哪些好处？ 答案同上</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-你使用jquery遇到过哪些问题，你是怎么解决的？"><span class="nav-text">4 你使用jquery遇到过哪些问题，你是怎么解决的？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-你知道jquery中的选择器吗，请讲一下有哪些选择器？"><span class="nav-text">5 你知道jquery中的选择器吗，请讲一下有哪些选择器？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-jquery中的选择器-和-css中的选择器有区别吗？"><span class="nav-text">6 jquery中的选择器 和 css中的选择器有区别吗？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-你觉得jquery中的选择器有什么优势？"><span class="nav-text">7 你觉得jquery中的选择器有什么优势？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-你在使用选择器的时候有有没有什么觉得要注意的地方？"><span class="nav-text">8 你在使用选择器的时候有有没有什么觉得要注意的地方？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9-jquery对象和dom对象是怎样转换的？"><span class="nav-text">9 jquery对象和dom对象是怎样转换的？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#10-你是如何使用jquery中的ajax的？"><span class="nav-text">10 你是如何使用jquery中的ajax的？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#11-你觉得jquery中的ajax好用吗，为什么？"><span class="nav-text">11 你觉得jquery中的ajax好用吗，为什么？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#12-jquery中-get-提交和-post-提交有区别吗？"><span class="nav-text">12 jquery中$.get()提交和$.post()提交有区别吗？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#13-jquery中的load方法一般怎么用的？"><span class="nav-text">13 jquery中的load方法一般怎么用的？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#14-在jquery中你是如何去操作样式的？"><span class="nav-text">14 在jquery中你是如何去操作样式的？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#15-简单的讲叙一下jquery是怎么处理事件的，你用过哪些事件？"><span class="nav-text">15 简单的讲叙一下jquery是怎么处理事件的，你用过哪些事件？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#16-你使用过jquery中的动画吗，是怎样用的？"><span class="nav-text">16 你使用过jquery中的动画吗，是怎样用的？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#17-你使用过jquery中的插件吗？-答-看个人的实力和经验来回答了。"><span class="nav-text">17 你使用过jquery中的插件吗？ 答:看个人的实力和经验来回答了。</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#18-你一般用什么去提交数据，为什么？"><span class="nav-text">18 你一般用什么去提交数据，为什么？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#19-在jquery中引入css有几种方式？"><span class="nav-text">19 在jquery中引入css有几种方式？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#20-你在jquery中使用过哪些插入节点的方法，它们的区别是什么？"><span class="nav-text">20 你在jquery中使用过哪些插入节点的方法，它们的区别是什么？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#21-你使用过包裹节点的方法吗，包裹节点有方法有什么好处？"><span class="nav-text">21 你使用过包裹节点的方法吗，包裹节点有方法有什么好处？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#22-jquery中如何来获取或和设置属性？"><span class="nav-text">22 jquery中如何来获取或和设置属性？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#23-如何来设置和获取HTML-和文本的值？"><span class="nav-text">23 如何来设置和获取HTML 和文本的值？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#24-你jquery中有哪些方法可以遍历节点？"><span class="nav-text">24 你jquery中有哪些方法可以遍历节点？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#25-子元素选择器-和后代选择器元素有什么区别？"><span class="nav-text">25 子元素选择器 和后代选择器元素有什么区别？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#26-在jquery中可以替换节点吗？"><span class="nav-text">26 在jquery中可以替换节点吗？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#27-你觉得beforeSend方法有什么用？"><span class="nav-text">27 你觉得beforeSend方法有什么用？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#28-siblings-方法-和-‘prev-div’-选择器是一样的嘛？"><span class="nav-text">28 siblings() 方法 和 $(‘prev~div’)选择器是一样的嘛？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#29-你在ajax中使用过JSON吗，你是如何用的？"><span class="nav-text">29 你在ajax中使用过JSON吗，你是如何用的？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#30-有哪些查询节点的选择器？"><span class="nav-text">30 有哪些查询节点的选择器？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#31-nextAll-能-替代-‘prev-siblindgs’-选择器吗？"><span class="nav-text">31 nextAll() 能 替代$(‘prev~siblindgs’)选择器吗？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#32-jQuery中有几种方法可以来设置和获取样式"><span class="nav-text">32 jQuery中有几种方法可以来设置和获取样式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#33-document-ready-方法和window-onload有什么区别？"><span class="nav-text">33 $(document).ready()方法和window.onload有什么区别？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#34-jQuery是如何处理缓存的？"><span class="nav-text">34 jQuery是如何处理缓存的？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#35-getScript-方法-和-getJson-方法有什么区别？"><span class="nav-text">35 $.getScript()方法 和 $.getJson() 方法有什么区别？</span></a></li></ol></li></ol></div>
            
          </div>
        </section>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy;  2016 - 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Carry Guan</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.0.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.0.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"carryguan"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
      
      <script src="/vendors/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
      <script src="/js/src/hook-duoshuo.js"></script>
    
  






  
  
  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length == 0) {
       search_path = "search.xml";
    }
    var path = "/" + search_path;
    // monitor main search box;

    function proceedsearch() {
      $("body").append('<div class="popoverlay">').css('overflow', 'hidden');
      $('.popup').toggle();

    }
    // search function;
    var searchFunc = function(path, search_id, content_id) {
    'use strict';
    $.ajax({
        url: path,
        dataType: "xml",
        async: true,
        success: function( xmlResponse ) {
            // get the contents from search data
            isfetched = true;
            $('.popup').detach().appendTo('.header-inner');
            var datas = $( "entry", xmlResponse ).map(function() {
                return {
                    title: $( "title", this ).text(),
                    content: $("content",this).text(),
                    url: $( "url" , this).text()
                };
            }).get();
            var $input = document.getElementById(search_id);
            var $resultContent = document.getElementById(content_id);
            $input.addEventListener('input', function(){
                var matchcounts = 0;
                var str='<ul class=\"search-result-list\">';                
                var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                $resultContent.innerHTML = "";
                if (this.value.trim().length > 1) {
                // perform local searching
                datas.forEach(function(data) {
                    var isMatch = true;
                    var content_index = [];
                    var data_title = data.title.trim().toLowerCase();
                    var data_content = data.content.trim().replace(/<[^>]+>/g,"").toLowerCase();
                    var data_url = data.url;
                    var index_title = -1;
                    var index_content = -1;
                    var first_occur = -1;
                    // only match artiles with not empty titles and contents
                    if(data_title != '' && data_content != '') {
                        keywords.forEach(function(keyword, i) {
                            index_title = data_title.indexOf(keyword);
                            index_content = data_content.indexOf(keyword);
                            if( index_title < 0 && index_content < 0 ){
                                isMatch = false;
                            } else {
                                if (index_content < 0) {
                                    index_content = 0;
                                }
                                if (i == 0) {
                                    first_occur = index_content;
                                }
                            }
                        });
                    }
                    // show search results
                    if (isMatch) {
                        matchcounts += 1;
                        str += "<li><a href='"+ data_url +"' class='search-result-title'>"+ data_title +"</a>";
                        var content = data.content.trim().replace(/<[^>]+>/g,"");
                        if (first_occur >= 0) {
                            // cut out 100 characters
                            var start = first_occur - 20;
                            var end = first_occur + 80;
                            if(start < 0){
                                start = 0;
                            }
                            if(start == 0){
                                end = 50;
                            }
                            if(end > content.length){
                                end = content.length;
                            }
                            var match_content = content.substring(start, end);
                            // highlight all keywords
                            keywords.forEach(function(keyword){
                                var regS = new RegExp(keyword, "gi");
                                match_content = match_content.replace(regS, "<b class=\"search-keyword\">"+keyword+"</b>");
                            });
                            
                            str += "<p class=\"search-result\">" + match_content +"...</p>"
                        }
                        str += "</li>";
                    }
                })};
                str += "</ul>";
                if (matchcounts == 0) { str = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>' }
                if (keywords == "") { str = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>' }
                $resultContent.innerHTML = str;
            });
            proceedsearch();
        }
    });}

    // handle and trigger popup window;
    $('.popup-trigger').mousedown(function(e) {
      e.stopPropagation();
      if (isfetched == false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };

    });

    $('.popup-btn-close').click(function(e){
      $('.popup').hide();
      $(".popoverlay").remove();
      $('body').css('overflow', '');
    });
    $('.popup').click(function(e){
      e.stopPropagation();
    });
  </script>

  

  

  

</body>
</html>
