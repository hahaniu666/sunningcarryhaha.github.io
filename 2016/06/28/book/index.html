<!doctype html>



  


<html class="theme-next muse use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="前端 女程序员 blog  JS" />





  <link rel="alternate" href="/atom.xml" title="关凯丽的博客" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1" />






<meta name="description" content="HTML&amp;amp;CSS常见的行内元素与块级元素都有哪些，分别举例 ，并说一说区别5%
行内元素(inline)：a b span input select strong samll
块级元素(block)：p div ul ol li dl dt dd h1 table form center
行内块级元素(inline-block):img（可以设置宽高，多个元素占一行，可设置所有margin">
<meta property="og:type" content="article">
<meta property="og:title" content="book">
<meta property="og:url" content="http://carryguan.com/2016/06/28/book/index.html">
<meta property="og:site_name" content="关凯丽的博客">
<meta property="og:description" content="HTML&amp;amp;CSS常见的行内元素与块级元素都有哪些，分别举例 ，并说一说区别5%
行内元素(inline)：a b span input select strong samll
块级元素(block)：p div ul ol li dl dt dd h1 table form center
行内块级元素(inline-block):img（可以设置宽高，多个元素占一行，可设置所有margin">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/2377897-a0f4eff0c7cd5c66.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/2377897-2fc97e71155223a0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/2377897-502ce3aaecc4b38b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/2377897-0a9d9c4eb7fc996e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/2377897-394530a71e54ed9f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/2377897-e655b83124da94d9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/2377897-394530a71e54ed9f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/2377897-e655b83124da94d9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/2377897-d9abdd592a00f11f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:updated_time" content="2017-09-18T01:13:15.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="book">
<meta name="twitter:description" content="HTML&amp;amp;CSS常见的行内元素与块级元素都有哪些，分别举例 ，并说一说区别5%
行内元素(inline)：a b span input select strong samll
块级元素(block)：p div ul ol li dl dt dd h1 table form center
行内块级元素(inline-block):img（可以设置宽高，多个元素占一行，可设置所有margin">
<meta name="twitter:image" content="http://upload-images.jianshu.io/upload_images/2377897-a0f4eff0c7cd5c66.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Muse',
    sidebar: {"position":"right","display":"always"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 13817414,
      author: '博主'
    }
  };
</script>




  <link rel="canonical" href="http://carryguan.com/2016/06/28/book/"/>

  <title> book | 关凯丽的博客 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  



  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?baa6059274e7d35050154321a77db806";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>








  
  
    
  

  <div class="container one-collumn sidebar-position-right page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">关凯丽的博客</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">前端打杂</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about-me" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="#" class="st-search-show-outputs">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <form class="site-search-form">
  <input type="text" id="st-search-input" class="st-search-input st-default-search-input" />
</form>

<script type="text/javascript">
  (function(w,d,t,u,n,s,e){w['SwiftypeObject']=n;w[n]=w[n]||function(){
    (w[n].q=w[n].q||[]).push(arguments);};s=d.createElement(t);
    e=d.getElementsByTagName(t)[0];s.async=1;s.src=u;e.parentNode.insertBefore(s,e);
  })(window,document,'script','//s.swiftypecdn.com/install/v2/st.js','_st');

  _st('install', '9swbp66zbunTR5mG6RnR','2.0.0');
</script>



    </div>
  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                book
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-06-28T09:11:43+08:00" content="2016-06-28">
              2016-06-28
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/06/28/book/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/06/28/book/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="HTML-amp-CSS"><a href="#HTML-amp-CSS" class="headerlink" title="HTML&amp;CSS"></a>HTML&amp;CSS</h1><h2 id="常见的行内元素与块级元素都有哪些，分别举例-，并说一说区别5"><a href="#常见的行内元素与块级元素都有哪些，分别举例-，并说一说区别5" class="headerlink" title="常见的行内元素与块级元素都有哪些，分别举例 ，并说一说区别5%"></a>常见的行内元素与块级元素都有哪些，分别举例 ，并说一说区别5%</h2><ul>
<li>行内元素(inline)：a b span input select strong samll</li>
<li>块级元素(block)：p div ul ol li dl dt dd h1 table form center</li>
<li>行内块级元素(inline-block):img（可以设置宽高，多个元素占一行，可设置所有margin和padding）</li>
<li><p>常见的空元素：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;br/&gt; &lt;hr/&gt;  &lt;link/&gt; &lt;meta/&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>行内元素与块级元素的区别：</li>
<li>行内元素一行占好多个，块级元素独占一行</li>
<li>设置宽度width ,height 无效，可以通过line-height来设置。</li>
<li>设置左右margin/padding有效，上下margin/padding无效</li>
</ul>
</li>
</ul>
<hr>
<h2 id="margin"><a href="#margin" class="headerlink" title="margin"></a>margin</h2><p>margin :上   右   下   左<br>margin: 上  右  下<br>margin : 上下  左右</p>
<h2 id="居中的常见方法-水平，竖直-5"><a href="#居中的常见方法-水平，竖直-5" class="headerlink" title="居中的常见方法(水平，竖直) 5%"></a>居中的常见方法(水平，竖直) 5%</h2><h3 id="1-水平居中"><a href="#1-水平居中" class="headerlink" title="1.水平居中"></a>1.水平居中</h3><ul>
<li>自身宽高，块级元素</li>
<li>margin：0 auto; <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">.box&#123;</span><br><span class="line">    width: 300px;</span><br><span class="line">    height: 300px;</span><br><span class="line">    border: 3px solid red;</span><br><span class="line">&#125;</span><br><span class="line">img&#123;</span><br><span class="line">    display: block;</span><br><span class="line">    width: 100px;</span><br><span class="line">    height: 100px;</span><br><span class="line">    margin: 0 auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="2-水平居中-父元素-text-align：center；"><a href="#2-水平居中-父元素-text-align：center；" class="headerlink" title="2.水平居中 父元素 text-align：center；"></a>2.水平居中 父元素 text-align：center；</h3><p>子元素的display：inline-block；在不受float影响下进行<br>是在父元素上添加：text-align：center；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">.box&#123;</span><br><span class="line">    width: 300px;</span><br><span class="line">    height: 300px;</span><br><span class="line">    border: 3px solid red;</span><br><span class="line">    text-align: center;</span><br><span class="line">&#125;</span><br><span class="line">img&#123;</span><br><span class="line">    display: inline-block;</span><br><span class="line">    width: 100px;</span><br><span class="line">    height: 100px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="水平垂直居中（一）"><a href="#水平垂直居中（一）" class="headerlink" title="水平垂直居中（一）"></a>水平垂直居中（一）</h4><p> 自身宽高,position,left,top ,margin-left,top为自身宽高负值一半<br>(left,top,right,bottom使用要，在position ：relative/absolute)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">img&#123;</span><br><span class="line">    width: 100px;</span><br><span class="line">    height: 150px;</span><br><span class="line">    position: absolute;</span><br><span class="line">    top: 50%;</span><br><span class="line">    left: 50%;</span><br><span class="line">    margin-top: -75px;/*自身 高度的一半 */</span><br><span class="line">    margin-left: -50px;/*自身 宽度的一半 */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="水平垂直居中（三）绝对定位和transfrom"><a href="#水平垂直居中（三）绝对定位和transfrom" class="headerlink" title="水平垂直居中（三）绝对定位和transfrom"></a>水平垂直居中（三）绝对定位和transfrom</h3><p>不需要知道居中元素的宽高<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">img&#123;</span><br><span class="line">        position: absolute;</span><br><span class="line">        top: 50%;</span><br><span class="line">        left: 50%;</span><br><span class="line">        transform: translate(-50%,-50%);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="水平垂直居中（二）"><a href="#水平垂直居中（二）" class="headerlink" title="水平垂直居中（二）"></a>水平垂直居中（二）</h3><p>自身宽高，position,定位上下左右为0，margin:atuo（auto等分其余空间）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">img&#123;</span><br><span class="line">       width: 100px;</span><br><span class="line">       height: 150px;</span><br><span class="line">       position: absolute;</span><br><span class="line">       top: 0;</span><br><span class="line">       left: 0;</span><br><span class="line">       right: 0;</span><br><span class="line">       bottom: 0;</span><br><span class="line">       margin: auto;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="水平垂直居中（四）diplay：table-cell"><a href="#水平垂直居中（四）diplay：table-cell" class="headerlink" title="水平垂直居中（四）diplay：table-cell"></a>水平垂直居中（四）diplay：table-cell</h3><p>其实这个就是把其变成表格样式，再利用表格的样式来进行居中，很方便<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">box&#123;</span><br><span class="line">            width: 300px;</span><br><span class="line">            height: 300px;</span><br><span class="line">            background:#e9dfc7; </span><br><span class="line">            border:1px solid red;</span><br><span class="line"></span><br><span class="line">            display: table-cell;</span><br><span class="line">            vertical-align: middle;</span><br><span class="line">            text-align: center;</span><br><span class="line">        &#125;</span><br><span class="line">        img&#123;</span><br><span class="line">            width: 100px;</span><br><span class="line">            height: 150px;</span><br><span class="line">            /*margin: 0 auto;*/  这个也行</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="水平垂直居中（五）flexBox居中"><a href="#水平垂直居中（五）flexBox居中" class="headerlink" title="水平垂直居中（五）flexBox居中"></a>水平垂直居中（五）flexBox居中</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">.box&#123;</span><br><span class="line">            width: 300px;</span><br><span class="line">            height: 300px;</span><br><span class="line">            background:#e9dfc7; </span><br><span class="line">            border:1px solid red;</span><br><span class="line">            display: flex;</span><br><span class="line">            justify-content: center;</span><br><span class="line">            align-items:center;</span><br><span class="line">        &#125;</span><br><span class="line">        img&#123;</span><br><span class="line">            width: 150px;</span><br><span class="line">            height: 100px;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p><a href="http://www.jianshu.com/p/a7552ce07c88" target="_blank" rel="external">http://www.jianshu.com/p/a7552ce07c88</a></p>
<hr>
<h2 id="常见的垂直居中的方式"><a href="#常见的垂直居中的方式" class="headerlink" title="常见的垂直居中的方式"></a>常见的垂直居中的方式</h2><ul>
<li>vertical-align:middle(table)</li>
<li>translateY(-50%)<br>-webkit-transform: translateY(-50%);</li>
<li>css3 flex<br>不定宽高水平垂直居中<br>align-items:center;//子元素垂直居中<br>justify-content:center;//子元素水平居中<br>display:-webkit-flex;</li>
</ul>
<hr>
<h2 id="如何让几行文本垂直居中？如何让一行文本进行垂直居中？"><a href="#如何让几行文本垂直居中？如何让一行文本进行垂直居中？" class="headerlink" title="如何让几行文本垂直居中？如何让一行文本进行垂直居中？"></a>如何让几行文本垂直居中？如何让一行文本进行垂直居中？</h2><ul>
<li>一行文本垂直居中：height = line-height</li>
<li>多行文本固定高度垂直居中：vertical-align（兼容IE7及IE7）<br>因为想使用vertical-align:middle，就要模拟表格：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">父元素:</span><br><span class="line">display:table</span><br><span class="line">子元素：</span><br><span class="line">display:table-cell</span><br><span class="line">vertical-align:middle;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li>多行文本垂直居中：vertical-align+（兼容IE6以上）<br>在IE6中对父元素进行定位后，如果再对子元素进行百分比计算时，计算的基础似乎是有继承性的（使用百分比计算的基础将不再是该元素的高度，而从父元素继承来的定位高度）。<br>父亲元素的外层： display:table;<br>父亲：top:50%<br>孩子：top:-50%<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">.wrap&#123;  </span><br><span class="line">    display:table;  </span><br><span class="line">    position:relative;  </span><br><span class="line">    overflow:hidden;  </span><br><span class="line">&#125;  </span><br><span class="line">父亲元素</span><br><span class="line">.subwrap&#123;  </span><br><span class="line">    vertical-align:middle;  </span><br><span class="line">    display:table-cell;  </span><br><span class="line">    position:absolute;  </span><br><span class="line">    top:50%;  </span><br><span class="line">&#125;  </span><br><span class="line">子元素 ：</span><br><span class="line">.content&#123;  </span><br><span class="line">    position:relative;  </span><br><span class="line">    top:-50%;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h2 id="flex弹性布局："><a href="#flex弹性布局：" class="headerlink" title="flex弹性布局："></a>flex弹性布局：</h2><ul>
<li>flex布局好处？不需要再给子元素设置定位，使用flex属性就可以让浏览器自己计算位置</li>
<li>父块元素：display: flex;</li>
<li>父行级元素：display: inline-flex;</li>
<li>设置了flex布局后，子元素的float、clear和vertical-align属性就会失效</li>
<li>具体描述：<br>设置了 flex的父亲成为：flex容器，孩子成为flex项目<ul>
<li>父亲容器属性：<ul>
<li>flex-direction(孩子横向还是竖向)：row(孩子水平)| row-reverse | column(孩子竖直) | column-reverse;</li>
<li>flex-wrap(孩子换行)：nowrap | wrap | wrap-reverse;</li>
<li>justify-content（孩子对齐方式）: flex-start | flex-end | center | space-between | space-around;</li>
<li>align-items: stretch|center|flex-start|flex-end|baseline|initial|inherit;</li>
<li>孩子項目屬性：<ul>
<li>order ：属性定义项目的排列顺序。数值越小，排列越靠前，默认为0</li>
<li>flex-grow：设置或检索弹性盒的扩展比率。根据弹性盒子元素所设值作为比率来分配剩余空间。</li>
<li>flex-shrink：属性定义了项目的缩小比例，默认为1，如果没有显示定义该属性，将会自动按照默认值1在所有因子相加之后计算比率来进行空间收缩。</li>
</ul>
</li>
<li>flex-basis：设置或检索弹性盒伸缩基准值，如果所有子元素的基准值之和大于剩余空间，则会根据每项设置的基准值，按比率伸缩剩余空间。<ul>
<li>align-self：属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>【问题】：<br>flex弹性盒模型，主轴有几个方向？后代 flex：1代表什么？</p>
<p>【答案】：</p>
<ul>
<li>flex 是 flex-grow、flex-shrink、flex-basis的缩写。故其取值可以考虑以下情况：</li>
<li>flex 的默认值是 0 1 auto</li>
<li>flex : none，则计算值为 0 0 auto</li>
<li>flex : auto，则计算值为 1 1 auto</li>
<li>flex :非负值，则该数字为 flex-grow 值，flex-shrink 取 1，flex-basis 取 0%</li>
<li>flex 长度或百分比，则视为 flex-basis 值，flex-grow 取 1，flex-shrink 取 1</li>
<li>flex : 非负值　非负值，则分别视为 flex-grow 和 flex-shrink 的值，flex-basis 取 0%，如下是等同的：</li>
</ul>
<hr>
<h2 id="浮动"><a href="#浮动" class="headerlink" title="浮动"></a>浮动</h2><ul>
<li>浮动元素会脱离文档流并向左/向右浮动（不在正常位置，并且他后面的不浮动元素会占他的位置），浮动直到碰到父元素或者另一个浮动元素。</li>
<li>浮动不会影响同级别普通元素的布局，同时也存在盖住普通元素的风险。</li>
<li>clear属性不允许被清除浮动的元素的左边/右边挨着浮动元素，底层原理是在被清除浮动的元素上边或者下边添加足够的清除空间。<br><img src="http://upload-images.jianshu.io/upload_images/2377897-a0f4eff0c7cd5c66.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></li>
</ul>
<h2 id="说一下为什么要清除浮动以及常见的清除浮动的方法-4"><a href="#说一下为什么要清除浮动以及常见的清除浮动的方法-4" class="headerlink" title="说一下为什么要清除浮动以及常见的清除浮动的方法 4%"></a>说一下为什么要清除浮动以及常见的清除浮动的方法 4%</h2><p>当一个内层元素是浮动的时候，如果没有关闭浮动时，其父元素也就不会再包含这个浮动的内层元素，因为此时浮动元素已经脱离了文档流。也就是为什么外层不能被撑开了！<br>（2）：边框不能撑开 （3）：margin ,padding设置值不能正确显示（1）：背景不能显示</p>
<h3 id="方法一：在被清除浮动元素内部末尾添加新元素-、应用-clear：both"><a href="#方法一：在被清除浮动元素内部末尾添加新元素-、应用-clear：both" class="headerlink" title="方法一：在被清除浮动元素内部末尾添加新元素 、应用 clear：both"></a>方法一：在被清除浮动元素内部末尾添加新元素 、应用 clear：both</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">div class=&quot;outer&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;div1&quot;&gt;1&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;div2&quot;&gt;2&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;div3&quot;&gt;3&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;clear&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">.clear&#123;clear:both; height: 0; line-height: 0; font-size: 0&#125;</span><br></pre></td></tr></table></figure>
<h3 id="方法二：触发BFC"><a href="#方法二：触发BFC" class="headerlink" title="方法二：触发BFC"></a>方法二：触发BFC</h3><p>父级div定义 overflow: hidden（hidden可以兼容IE，就是对seo不太友好,auto不可以兼容IE）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">父亲 </span><br><span class="line">.over-flow&#123;</span><br><span class="line">    overflow: hidden; // 是在处理兼容性问题</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>###方法三： clearfix:before,after<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 全浏览器通用的clearfix方案【推荐】</span><br><span class="line">// 同时加入:before以解决现代浏览器上边距折叠的问题</span><br><span class="line">.clearfix:before,</span><br><span class="line">.clearfix:after &#123;</span><br><span class="line">    display: table;//block</span><br><span class="line">    content: &quot; &quot;;// &apos;.&apos;</span><br><span class="line">&#125;</span><br><span class="line">.clearfix:after &#123;</span><br><span class="line">    clear: both;</span><br><span class="line">&#125;</span><br><span class="line">.clearfix&#123;</span><br><span class="line">    *zoom: 1;//引入了zoom以支持IE6/7</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><a href="https://my.oschina.net/leipeng/blog/221125" target="_blank" rel="external">https://my.oschina.net/leipeng/blog/221125</a><br><a href="http://www.jianshu.com/p/5138706046b1" target="_blank" rel="external">http://www.jianshu.com/p/5138706046b1</a><br><a href="http://www.jianshu.com/p/09bd5873bed4" target="_blank" rel="external">http://www.jianshu.com/p/09bd5873bed4</a></p>
<hr>
<h2 id="BFC"><a href="#BFC" class="headerlink" title="BFC"></a>BFC</h2><p>BFC可以做:BFC清除浮动，BFC解决垂直边距折叠<br>BFC全称是块状格式化上下文，它是按照块级盒子布局的。我们了解他的特征、触发方式、常见使用场景这些就够了。</p>
<p>BFC的主要特征</p>
<p>✦ BFC容器是一个隔离的容器，和其他元素互不干扰；所以我们可以用触发两个元素的BFC来解决垂直边距折叠问题。<br>✦ BFC可以包含浮动；通常用来解决浮动父元素高度坍塌的问题。</p>
<p>其中，BFC清除浮动就是用的“包含浮动”这条特性。<br>那么，怎样才能触发BFC呢？</p>
<p>BFC的触发方式</p>
<p>我们可以给父元素添加以下属性来触发BFC(一下任意一条就可以)：<br>✦ float 为 left | right(不为none)<br>✦ overflow 为 hidden | auto | scorll(不为visible   )<br>✦ display 为 table-cell | table-caption | inline-block | flex | inline-flex<br>✦ position 为 absolute | fixed</p>
<hr>
<h2 id="介绍一下标准的CSS的盒子模型？低版本IE的盒子模型有什么不同的？"><a href="#介绍一下标准的CSS的盒子模型？低版本IE的盒子模型有什么不同的？" class="headerlink" title="介绍一下标准的CSS的盒子模型？低版本IE的盒子模型有什么不同的？"></a>介绍一下标准的CSS的盒子模型？低版本IE的盒子模型有什么不同的？</h2><p>每个HTML元素都是长方形盒子。<br>  （1）有两种， IE 盒子模型、W3C 盒子模型；<br>  （2）盒模型： 内容(content)、填充(padding)、边界(margin)、 边框(border)；<br>  （3）区  别：<br> 标准盒模型的width为内容区的width，盒子总宽度：width+padding+border+margin<br> IE的width是内容区宽度+padding+border，盒子总宽度：width+margin</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2377897-2fc97e71155223a0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/2377897-502ce3aaecc4b38b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<hr>
<h2 id="position-的几种值-，详细说明一下每种的区别-3"><a href="#position-的几种值-，详细说明一下每种的区别-3" class="headerlink" title="position 的几种值 ，详细说明一下每种的区别 3%"></a>position 的几种值 ，详细说明一下每种的区别 3%</h2><ul>
<li>static    默认。位置设置为 static 的元素，它始终会处于页面流给予的位置（static 元素会忽略任何 top、bottom、left 或 right 声明）。</li>
<li>relative    位置被设置为 relative 的元素，可将其移至相对于其正常位置的地方，因此 “left:20” 会将元素移至元素正常位置左边 20 个像素的位置。</li>
<li>absolute    位置设置为 absolute 的元素，可定位于相对于包含它的元素的指定坐标。此元素的位置可通过 “left”、”top”、”right” 以及 “bottom” 属性来规定。</li>
<li>fixed    位置被设置为 fixed 的元素，可定位于相对于浏览器窗口的指定坐标。此元素的位置可通过 “left”、”top”、”right” 以及”bottom” 属性来规定。不论窗口滚动与否，元素都会留在那个位置。工作于 IE7（strict 模式）。</li>
</ul>
<hr>
<h2 id="如果position设置成absolute属性该元素的display属性会变成什么"><a href="#如果position设置成absolute属性该元素的display属性会变成什么" class="headerlink" title="如果position设置成absolute属性该元素的display属性会变成什么"></a>如果position设置成absolute属性该元素的display属性会变成什么</h2><ul>
<li>position: absolute,float会隐式的改变display类型， 不论之前是什么类型的元素（ display: none除外），<ul>
<li>只要设置了position: absolute或float， 都会让元素以display: inline - block的方式显示， 可以设置长宽，</li>
</ul>
</li>
<li>就算是显示的设置display: inline或display: block， 仍然无效。</li>
</ul>
<hr>
<h2 id="display-有几个值-3"><a href="#display-有几个值-3" class="headerlink" title="display 有几个值  3%"></a>display 有几个值  3%</h2><p>每个元素都有display属性，确定该元素的类型，<br>每个元素都有默认的display值，<br>如div的display默认值为“block”，则为“块级”元素；<br>span默认display属性值为“inline”，是“行内”元素。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2377897-0a9d9c4eb7fc996e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<hr>
<h2 id="伪类-伪元素"><a href="#伪类-伪元素" class="headerlink" title="伪类 伪元素"></a>伪类 伪元素</h2><p>伪类是给元素模拟添加类 ，来实现某种效果（：）<br>常见伪类：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2377897-394530a71e54ed9f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<p>伪元素是模拟添加个元素来实现效果（::）(css3出现后做的区分)<br>常见伪元素：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2377897-e655b83124da94d9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<p><a href="http://web.jobbole.com/86181/" target="_blank" rel="external">http://web.jobbole.com/86181/</a></p>
<hr>
<h2 id="CSS3新增伪类有那些？"><a href="#CSS3新增伪类有那些？" class="headerlink" title="CSS3新增伪类有那些？"></a>CSS3新增伪类有那些？</h2><pre><code>举例：
  p:first-of-type    选择属于其父元素的首个 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。
  p:last-of-type    选择属于其父元素的最后 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。
  p:only-of-type    选择属于其父元素唯一的 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。
  p:only-child        选择属于其父元素的唯一子元素的每个 &lt;p&gt; 元素。
  p:nth-child(2)    选择属于其父元素的第二个子元素的每个 &lt;p&gt; 元素。

 inptut
    :enabled          
   :disabled         控制表单控件的禁用状态。
  :checked        单选框或复选框被选中。
</code></pre><hr>
<h2 id="CSS选择器有哪些？哪些属性可以继承？"><a href="#CSS选择器有哪些？哪些属性可以继承？" class="headerlink" title="CSS选择器有哪些？哪些属性可以继承？"></a>CSS选择器有哪些？哪些属性可以继承？</h2><pre><code> 1.id选择器（ # myid）
2.类选择器（.myclassname）
3.标签选择器（div, h1, p）
4.相邻选择器（h1 + p）
5.子选择器（ul &gt; li）
6.后代选择器（li a）
7.通配符选择器（ * ）
8.属性选择器（a[rel = &quot;external&quot;]）
9.伪类选择器（a:hover, li:nth-child）
</code></pre><ul>
<li><p>可继承的样式： font-size font-family color, UL LI DL DD DT;</p>
</li>
<li><p>不可继承的样式：border padding margin width height ;</p>
</li>
</ul>
<hr>
<h2 id="CSS优先级算法如何计算？"><a href="#CSS优先级算法如何计算？" class="headerlink" title="CSS优先级算法如何计算？"></a>CSS优先级算法如何计算？</h2><ul>
<li>优先级就近原则，同权重情况下样式定义最近者为准;</li>
<li>载入样式以最后载入的定位为准;<h3 id="同权重"><a href="#同权重" class="headerlink" title="同权重"></a>同权重</h3><ul>
<li>1、 位于 &lt; head / &gt; 标签里的 &lt; style / &gt; 中所定义的CSS拥有最高级的优先权。　　</li>
<li>2、 第二级的优先属性由位于 &lt; style / &gt; 标签中的 @import 引入样式表所定义。　　</li>
<li>3、 第三级的优先属性由 &lt; link / &gt; 标签所引入的样式表定义。</li>
<li>4、 第四级的优先属性由 &lt; link / &gt; 标签所引入的样式表内的 @import 导入样式表定义。　　</li>
<li>5、 第五级优先的样式有用户设定。　　 最低级的优先权由浏览器默认。 </li>
</ul>
</li>
</ul>
<p>权重的进制是256</p>
<h3 id="属性选择器的权重问题"><a href="#属性选择器的权重问题" class="headerlink" title="属性选择器的权重问题:"></a>属性选择器的权重问题:</h3><pre><code>// !important ---------&gt;   无穷
// 行间样式-------------&gt;   1000
// id------------------&gt;   100
// class|属性|伪类------&gt;   10
// 标签|伪元素 ---------&gt;    1
// 通配符---------------&gt;   0
</code></pre><hr>
<h2 id="页面导入样式时，使用link和-import有什么区别？"><a href="#页面导入样式时，使用link和-import有什么区别？" class="headerlink" title="页面导入样式时，使用link和@import有什么区别？"></a>页面导入样式时，使用link和@import有什么区别？</h2><p>1 : 属于link属于xml 标签，除了加载css以外，还能定义rss和rel等 。@import是css提供的，只能用于加载css<br>2 :页面加载页面在加载时候，link同时被加载；而@import引用的css等页面加载完毕再加载<br>3：兼容性@import是CSS2.1 提出的，只在IE5以上才能被识别，而link是XHTML标签，无兼容问题;<br>4：link方式的样式权重高于@import的权重。<br>5：使用dom控制样式时的差别。当使用javascript控制dom去改变样式的时候，只能使用link标签，因为@import不是dom可以控制的。<br>6：. 最后一个很有意思， @import url有最大次数的限制， IE6最多引入31次， firefox并没有发现<br>7： @import的优点： 多个样式表导入一个样式表中， 页面只需要引入一个即可</p>
<hr>
<h2 id="引入css的几种方式-2"><a href="#引入css的几种方式-2" class="headerlink" title="引入css的几种方式 2%"></a>引入css的几种方式 2%</h2><h3 id="1-行内样式"><a href="#1-行内样式" class="headerlink" title="1.行内样式"></a>1.行内样式</h3><p>最直接最简单的一种，直接对HTML标签使用style=””，例如：</p>
<p style="color:#F00; "></p>

<p>缺点：HTML页面不纯净，文件体积大，不利于蜘蛛爬行，后期维护不方便。</p>
<h3 id="2-内嵌样式"><a href="#2-内嵌样式" class="headerlink" title="2.内嵌样式"></a>2.内嵌样式</h3><p>内嵌样式就是将CSS代码写在<head></head>之间，并且用<style></style>进行声明，例如：</p>
<style type="text/css">

body,div,a,img,p{margin:0; padding:0;}

</style>

<p>优缺点：页面使用公共CSS代码，也是每个页面都要定义的，如果一个网站有很多页面，每个文件都会变大，后期维护难度也大，如果文件很少，CSS代码也不多，这种样式还是很不错的。</p>
<h3 id="3-链接样式"><a href="#3-链接样式" class="headerlink" title="3.链接样式"></a>3.链接样式</h3><p>链接样式是使用频率最高，最实用的样式，只需要在<head></head>之间加上<link…>就可以了，如下：</link…></p>
<link type="text/css" rel="stylesheet" href="style.css">

<p>优缺点：实现了页面框架代码与表现CSS代码的完全分离，使得前期制作和后期维护都十分方便</p>
<h3 id="4-导入样式（不建议使用）"><a href="#4-导入样式（不建议使用）" class="headerlink" title="4.导入样式（不建议使用）"></a>4.导入样式（不建议使用）</h3><p>导入样式和链接样式比较相似，采用@import样式导入CSS样式表，在HTML初始化时，会被导入到HTML或者CSS文件中，成为文件的一部分，类似第二种内嵌样式。</p>
<ul>
<li>@import在html中使用，如下：</li>
</ul>
<style type="text/css">
@import url(style.css);
</style>

<ul>
<li>@import在CSS中使用，如下：</li>
</ul>
<p>@import url(style.css);</p>
<h3 id="四种CSS引入方式的优先级"><a href="#四种CSS引入方式的优先级" class="headerlink" title="四种CSS引入方式的优先级"></a>四种CSS引入方式的优先级</h3><p>1.就近原则<br>2.理论上：行内&gt;内嵌&gt;链接&gt;导入<br>3.实际上：内嵌、链接、导入在同一个文件头部，谁离相应的代码近，谁的优先级高</p>
<hr>
<h2 id="锚点-1"><a href="#锚点-1" class="headerlink" title="锚点 1%"></a>锚点 1%</h2><p>html 锚点 到底是干吗的？<br>通俗简单地说，比如一篇很长的文章，你想按分段精确来看，那就可以用到锚点了<br>代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href=&quot;#001&quot;&gt;跳到001&lt;/a&gt;</span><br><span class="line">...文字省略</span><br><span class="line">&lt;a name=&quot;001&quot; id=&quot;001&quot; &gt;&lt;/a&gt;</span><br><span class="line">...文字省略</span><br></pre></td></tr></table></figure></p>
<p>(兼容到ie8)<br>其实锚点只需name就可以可，加id是为了让它兼容性更好.<br>href的值要跟name \ i d 一致，前面必须加”#”，以上代码在ie6/7,ff中都可以兼容，但在ie8中就不行。<br>因为我们锚点的<a></a>值为空，为不影响美观我们加个空格就行了,</p>
<p>另一问题，想显示某页面(如：123.html)的某锚点内容呢？ </p>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">代码如下</span><br><span class="line">&lt;a href=&quot;123.html#001&quot;&gt;跳到001&lt;/a&gt;</span><br><span class="line">...文字省略</span><br><span class="line">&lt;a name=&quot;001&quot; id=&quot;001&quot; &gt; &lt;/a&gt;</span><br><span class="line">...文字省略</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="两栏布局（左固定，右自适应）"><a href="#两栏布局（左固定，右自适应）" class="headerlink" title="两栏布局（左固定，右自适应）"></a>两栏布局（左固定，右自适应）</h2><h3 id="1-float-margin"><a href="#1-float-margin" class="headerlink" title="1:float+margin"></a>1:float+margin</h3><p>左定宽高左浮动， 右设置margin - left:左边宽<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.left &#123;</span><br><span class="line">    width: 100 px;</span><br><span class="line">    height: 100 px;</span><br><span class="line">    float: left;</span><br><span class="line">&#125;</span><br><span class="line">.right &#123;</span><br><span class="line">    height: 100 px;</span><br><span class="line">    margin - left: 100 px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="2：float-BFC"><a href="#2：float-BFC" class="headerlink" title="2：float+BFC"></a>2：float+BFC</h3><p>左定宽高左浮动，右触发BFC</p>
<h3 id="3-left-0-left-左宽-right-0"><a href="#3-left-0-left-左宽-right-0" class="headerlink" title="3:left:0,left:-左宽,right:0;"></a>3:left:0,left:-左宽,right:0;</h3><p>左定宽高 ,设置定位position absolute, left 0 ;<br>        .left {<br>            width: 100 px;<br>            height: 100 px;<br>            background - color: red;<br>            position: absolute;<br>            left: 0;<br>        }<br>        .right {<br>            height: 100 px;<br>            background - color: green;<br>            right: 0;<br>        }</p>
<h3 id="三个元素都浮动，左定宽高，右宽-cal-100-x"><a href="#三个元素都浮动，左定宽高，右宽-cal-100-x" class="headerlink" title="三个元素都浮动，左定宽高，右宽 cal(100%-x)"></a>三个元素都浮动，左定宽高，右宽 cal(100%-x)</h3><hr>
<h2 id="实现三列布局（两边固定，中间自适应）"><a href="#实现三列布局（两边固定，中间自适应）" class="headerlink" title="实现三列布局（两边固定，中间自适应）"></a>实现三列布局（两边固定，中间自适应）</h2><p>1：绝对定位法：左右绝对定位，left:0,right:0,中间margin: 0 x;<br>此方法的优点是，理解容易，上手简单，受内部元素影响而破坏布局的概率低，就是比较经得起折腾。<br>缺点在于：如果中间栏含有最小宽度限制.布局可能受内部影响。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">.con &#123;</span><br><span class="line">       overflow: hidden;</span><br><span class="line">       height: 500px;</span><br><span class="line">   &#125;</span><br><span class="line">   .left,.right &#123;</span><br><span class="line">       width: 200px;</span><br><span class="line">       height: 100%;</span><br><span class="line">       position: absolute;</span><br><span class="line">       top: 0;//为了防止将后一个块级元素挤下去</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   .left &#123;</span><br><span class="line">       left: 0;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   .right &#123;</span><br><span class="line">       right: 0；</span><br><span class="line">   &#125;</span><br><span class="line">.main &#123;</span><br><span class="line">       margin: 0 210px;</span><br><span class="line">       overflow: hidden;</span><br><span class="line">       height: 100%;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>2：浮动方法：左右各浮动+中设margin<br>简便，但是灵活性低下<br>dom顺序有限制：因为左右浮动的缘故，只能将mid放在左右后面<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">    .con &#123;</span><br><span class="line">        overflow: hidden;</span><br><span class="line">        height: 500px;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    .main &#123;</span><br><span class="line">        height: 100%;</span><br><span class="line">        margin: 0 210px;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    .left,</span><br><span class="line">    .right &#123;</span><br><span class="line">        width: 200px;</span><br><span class="line">        height: 100%;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    .left &#123;</span><br><span class="line">        float: left;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    .right &#123;</span><br><span class="line">        float: right;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">    &lt;div class=&quot;con&quot;&gt;</span><br><span class="line"></span><br><span class="line">        &lt;div class=&quot;left&quot;&gt;我是左边&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">        &lt;div class=&quot;right&quot;&gt;我是右边&lt;/div&gt;</span><br><span class="line">        &lt;div class=&quot;main&quot;&gt;</span><br><span class="line"></span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure></p>
<p>3:flex，将mid设置属性flex:1<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">.con &#123;</span><br><span class="line">        height: 500px;</span><br><span class="line">        display: flex;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    .main &#123;</span><br><span class="line">        height: 100%;</span><br><span class="line">        flex: 1;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    .left,</span><br><span class="line">    .right &#123;</span><br><span class="line">        width: 200px;</span><br><span class="line">        height: 100%;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>4：圣杯布局：三个都浮动+左右margin负值<br>优点：三栏相互关联，可谓真正意义上的自适应，有一定的抗性——布局不易受内部影响。<br>缺点：相对比较难理解些，上手不容易，代码相对复杂。出现百分比宽度，过多的负值定位，如果出现布局的bug，排查不易。<br>【dom结构】：先自适应的div，然后再左右顺序可以不定<br>mid外层: width:100%，float:left<br>mid :margin 0 x;<br>左右 左浮动<br>第一个兄弟：margin-left:-100%<br>第二个兄弟：margin-left:-xpx;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;con&quot;&gt;</span><br><span class="line">        &lt;div class=&quot;main&quot;&gt;</span><br><span class="line">            &lt;div class=&quot;main-con&quot;&gt;</span><br><span class="line">                我是中间</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">        &lt;div class=&quot;left&quot;&gt;我是左边&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">        &lt;div class=&quot;right&quot;&gt;我是右边&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">    &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">.con &#123;</span><br><span class="line">        overflow: hidden;</span><br><span class="line">        height: 500px;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    .mid-wraper &#123;</span><br><span class="line">        width: 100%;</span><br><span class="line">        height: 100%;</span><br><span class="line">        float: left;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    .mid &#123;</span><br><span class="line">        margin: 0 210px;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    .left,</span><br><span class="line">    .right &#123;</span><br><span class="line">        width: 200px;</span><br><span class="line">        height: 100%;</span><br><span class="line">        float: left;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    .left &#123;</span><br><span class="line">        margin-left: -100%</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    .right &#123;</span><br><span class="line">        margin-left: -220px;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="BFC的通俗理解："><a href="#BFC的通俗理解：" class="headerlink" title="BFC的通俗理解："></a>BFC的通俗理解：</h2><ul>
<li>Block Formatting Context（ 块级格式化上下文） 是W3C CSS 2.1 规范中的一个概念， 它决定了元素如何对其内容进行定位， 以及与其他元素的关系和相互作用。 简单来讲， 我们可以把它理解为， 我们在进行盒模型布局的时候， 如果一个元素符合了成为BFC的条件，<ul>
<li>该元素成为一个隔离了的独立容器， 元素内部元素会垂直的沿着其父元素的边框排列， 和外部元素互不影响。 比如浮动元素会触发BFC，<br>浮动元素内部的子元素主要受到该浮动元素的影响， 而两个浮动元素之间是互不影响的。</li>
<li>在CSS3 中， BFC 叫做Flow Root。 在早期的ie中也有类似的概念haslayout IE6、 7 的很多布局产生的bug（ 如3px间隙、 绝对定位的继承宽度）都可以通过触发hasLayout修复， 比较推荐的方法为zoom: 1 与height: 1 % ，不会破坏已有的样式， 相信大家对它并不陌生。</li>
<li>同样的以往集中在float、 绝对定位、 margin collaspe中的很多困惑， 在理解了bfc后， 都能够被我们一一解除。<h2 id="BFC规范中的定义："><a href="#BFC规范中的定义：" class="headerlink" title="BFC规范中的定义："></a>BFC规范中的定义：</h2>w3c规范对BFC的解释：</li>
<li>浮动元素和绝对定位元素， 不是块级盒子的块容器（ 如 inline - blocks, table - cells, 和 table - captions）， 以及设置了overflow属性（ 除了visible）的块级盒子， 都会为他们的内容创建新的BFC（ 块级格式上下文）。<ul>
<li>在BFC中， 盒子从顶端开始垂直地 一个接一个地排列， 两个盒子之间的垂直的间隙是由他们的margin 值所决定的。 在一个BFC中， 两个相邻的块级盒子的</li>
<li>垂直外边距会产生折叠。 在BFC中， 每一个盒子的左外边缘（ margin - left） 会触碰到容器的左边缘(border - left)（ 对于从右到左的格式来说， 则触碰到右边缘）。</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre><code>    触发BFC的方法：(任一即可)

float 元素
position（ absolute， fixed）
display(table - cell， table - caption， inline - block)
overflow 除了visible 以外的值（ hidden， auto， scroll）
fieldset元素
早期IE的hasLayout会触发一个新的block formatting context
</code></pre><h3 id="BFC的特性"><a href="#BFC的特性" class="headerlink" title="BFC的特性"></a>BFC的特性</h3><ul>
<li>边缘不和浮动元素重叠</li>
<li>不存在collapsing margins问题</li>
<li>第一个特性特别有用， 因为元素触发了BFC的话， 就不会被float元素覆盖， 当子元素全部浮动的时候也能够正确地包含了<ul>
<li>第二个margin不会叠加的特性， 可以理解为两个处于普通流的盒子， 会有margin叠加的问题， 是因为他们属于相同的BFC， 当他自身创建了一个新的BFC时， 这个问题就不存在了<h3 id="BFC的常见应用"><a href="#BFC的常见应用" class="headerlink" title="BFC的常见应用"></a>BFC的常见应用</h3><ol>
<li>通过边缘不和浮动元素重叠的特性， 实现两栏结构。</li>
<li>清除元素内部浮动</li>
<li>解决合并外边距的问题</li>
</ol>
</li>
</ul>
</li>
</ul>
<hr>
<h2 id="常见的浏览器端的存储技术都有哪些，以及他们的优缺点和使用场景？"><a href="#常见的浏览器端的存储技术都有哪些，以及他们的优缺点和使用场景？" class="headerlink" title="常见的浏览器端的存储技术都有哪些，以及他们的优缺点和使用场景？"></a>常见的浏览器端的存储技术都有哪些，以及他们的优缺点和使用场景？</h2><p>有时需要将网页中的一些数据保存在浏览器端，这样做的好处是，当下次访问页面时，不需要再次向服务器请求数据，直接就可以从本地读取数据。目前常用的有以下几种方法：</p>
<h3 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a><strong>cookie</strong></h3><p>cookie会随着每次HTTP请求头信息一起发送，无形中增加了网络流量，另外，cookie能存储的数据容量有限，根据浏览器类型不同而不同，IE6大约只能存储2K，cookie数据大小不能超过4k</p>
<h3 id="Flash-ShareObject"><a href="#Flash-ShareObject" class="headerlink" title="Flash ShareObject"></a><strong>Flash ShareObject</strong></h3><p>这种方式能能解决上面提到的cookie存储的两个弊端，而且能够跨浏览器，应该说是目前最好的本地存储方案。不过，需要在页面中插入一个Flash，当浏览器没有安装Flash控件时就不能用了。所幸的是，没有安装Flash的用户极少。<br>缺点：需要安装Flash插件。</p>
<h3 id="sessionStorage"><a href="#sessionStorage" class="headerlink" title="sessionStorage"></a><strong>sessionStorage</strong></h3><p>使用于Firefox2+的火狐浏览器，用这种方式存储的数据仅窗口级别有效，同一个窗口（或者Tab）页面刷新或者跳转，都能获取到本地存储的数据，当新开窗口或者页面时，原来的数据就失效了。<br>缺点：IE不支持、不能实现数据的持久保存。</p>
<h3 id="localStorage"><a href="#localStorage" class="headerlink" title="localStorage"></a><strong>localStorage</strong></h3><p>localStorage是Web Storage互联网存储规范中的一部分，现在在Firefox 3.5、Safari 4和IE8中得到支持。<br>缺点：低版本浏览器不支持。</p>
<p>提示：localStorage储存的值都是字符串类型，使用时要注意。另外，可以在浏览器调试器中的Resources的localStorage中看到储存的信息。</p>
<blockquote>
<p>//存储信息   （存储的信息名称，要存储的字符串）<br>localStorage.setItem(“CC_email_list”,input_eamil[i])<br>//读取信息   （要读取的信息名称）<br>localStorage.getItem(“CC_email_list”)<br>//清除信息    （要清除的信息名称）<br>localStorage.removeItem(“CC_email_list”);</p>
</blockquote>
<h3 id="globalStorage"><a href="#globalStorage" class="headerlink" title="globalStorage"></a><strong>globalStorage</strong></h3><p>使用于Firefox2+的火狐浏览器，类似于IE的userData。<br>1 //赋值 2 globalStorage[location.hostname][‘name’] = ‘tugai’; 3 //读取 4 globalStorage[location.hostname][‘name’]; 5 //删除 6 globalStorage[location.hostname].removeItem(‘name’);</p>
<h3 id="Google-Gear"><a href="#Google-Gear" class="headerlink" title="Google Gear"></a><strong>Google Gear</strong></h3><p>Google开发出的一种本地存储技术。<br>缺点：需要安装Gear组件。</p>
<h3 id="userData"><a href="#userData" class="headerlink" title="userData"></a><strong>userData</strong></h3><p>IE浏览器可以使用userData来存储数据，容量可达到640K，这种方案是很可靠的，不需要安装额外的插件。缺点：它仅在IE下有效。<br>缺点：IE不支持。</p>
<p>结论：Flash shareobject是不错的选择，如果你不想在页面上嵌入Flash，可以结合使用userData(IE6+)和globalStorage(Firefox2+)和localStorage(chrome3+)实现跨浏览器。</p>
<hr>
<h2 id="请描述一下-cookies，sessionStorage-和-localStorage-的区别？"><a href="#请描述一下-cookies，sessionStorage-和-localStorage-的区别？" class="headerlink" title="请描述一下 cookies，sessionStorage 和 localStorage 的区别？"></a>请描述一下 cookies，sessionStorage 和 localStorage 的区别？</h2><pre><code>cookie是网站为了标示用户身份而储存在用户本地终端（Client Side）上的数据（通常经过加密）。
cookie数据始终在同源的http请求中携带（即使不需要），记会在浏览器和服务器间来回传递。
sessionStorage和localStorage不会自动把数据发给服务器，仅在本地保存。
</code></pre><h3 id="存储大小："><a href="#存储大小：" class="headerlink" title="存储大小："></a>存储大小：</h3><pre><code>cookie数据大小不能超过4k。
sessionStorage和localStorage 虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大。
</code></pre><h3 id="有期时间："><a href="#有期时间：" class="headerlink" title="有期时间："></a>有期时间：</h3><pre><code>localStorage    存储持久数据，浏览器关闭后数据不丢失除非主动删除数据；
sessionStorage  数据在当前浏览器窗口关闭后自动删除。
cookie          设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭
</code></pre><hr>
<h1 id="HTML5"><a href="#HTML5" class="headerlink" title="HTML5"></a>HTML5</h1><h2 id="新特性"><a href="#新特性" class="headerlink" title="新特性"></a>新特性</h2><h3 id="1-标签语义化，"><a href="#1-标签语义化，" class="headerlink" title="1:标签语义化，"></a>1:标签语义化，</h3><p>比如header，footer，nav，aside，article，section等，新增了很多表单元素，入email，url等，除去了center等样式标签，还有除去了有性能问题的frame，frameset等标签</p>
<h3 id="2、音视频元素，"><a href="#2、音视频元素，" class="headerlink" title="2、音视频元素，"></a>2、音视频元素，</h3><p>video，audio的增加使得我们不需要在依赖外部的插件就可以往网页中加入音视频元素。</p>
<h3 id="3、新增很多api，"><a href="#3、新增很多api，" class="headerlink" title="3、新增很多api，"></a>3、新增很多api，</h3><p>比如获取用户地理位置的window.navigator.geoloaction</p>
<h3 id="、websocket"><a href="#、websocket" class="headerlink" title="、websocket"></a>、websocket</h3><p>websocket是伴随html5到来的基于tcp/ip的全双工通信的协议。<br>主要通信过程：先借http完成握手，达到了长连接<br>第一步：浏览器基于tcp，发送http请求<br>第二步：服务器端，接收到请求后。将 tcp用户网络层协议变为websocket协议，完成了握手<br>第三步：服务器端和浏览器完成握手，他们之间形成一条通道，可以源源不断的传送信息<br>websocket是一种协议，可以让我们建立客户端到服务器端的全双工通信，这就意味着服务器端可以主动推送数据到客户端。</p>
<hr>
<h3 id="、HTML5-能够本地存储数据，在之前都是使用-cookies-使用的。"><a href="#、HTML5-能够本地存储数据，在之前都是使用-cookies-使用的。" class="headerlink" title="、HTML5 能够本地存储数据，在之前都是使用 cookies 使用的。"></a>、HTML5 能够本地存储数据，在之前都是使用 cookies 使用的。</h3><p>HTML5 提供了下面本地存储方案：webstorage包括localeStorage和sessionStorage，localeStorage是持久化存储在客户端，只要用户不主动删除，就不会消失，sessionStorage也是存储在客户端，但是他的存在时间是一个回话，一旦浏览器的关于该回话的页面关闭了，sessionStorage就消失了，</p>
<hr>
<h3 id="：请描述一下-cookies，sessionStorage-和-localStorage-的区别？"><a href="#：请描述一下-cookies，sessionStorage-和-localStorage-的区别？" class="headerlink" title="：请描述一下 cookies，sessionStorage 和 localStorage 的区别？"></a>：请描述一下 cookies，sessionStorage 和 localStorage 的区别？</h3><p>  cookie是网站为了标示用户身份而储存在客户端上的数据（通常经过加密）。<br>  cookie数据始终在同源的http请求中携带（即使不需要），记会在浏览器和服务器间来回传递。<br>  sessionStorage和localStorage不会自动把数据发给服务器，仅在本地保存。</p>
<p>  存储大小：<br>      cookie数据大小不能超过4k。<br>      sessionStorage和localStorage 虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大。</p>
<p>  有期时间：<br>      localStorage    存储持久数据，浏览器关闭后数据不丢失除非主动删除数据；<br>      sessionStorage  数据在当前浏览器窗口关闭后自动删除。<br>      cookie  在过期时间之前一直有效，即使窗口或浏览器关闭</p>
<hr>
<h3 id="、应用程序缓存："><a href="#、应用程序缓存：" class="headerlink" title="、应用程序缓存："></a>、应用程序缓存：</h3><p>在用户没有与因特网连接时，可以正常访问站点或应用，在用户与因特网连接时，更新用户机器上的缓存文件。<br>  原理：HTML5的离线存储是基于一个新建的.appcache文件的缓存机制(不是存储技术)，通过这个文件上的解析清单离线存储资源，这些资源就会像cookie一样被存储了下来。之后当网络在处于离线状态下时，浏览器会通过被离线存储的数据进行页面展示。</p>
<p>html5允许我们自己控制哪些文件需要缓存，哪些不需要，具体的做法如下：</p>
<p>1、首先给html添加manifest属性，并赋值为cache.manifest<br>2、cache.manifest的内容为:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">  CACHE MANIFEST</span><br><span class="line">  #v1.2</span><br><span class="line">  CACHE :           //表示需要缓存的文件</span><br><span class="line">    a.js</span><br><span class="line">    b.js</span><br><span class="line">NETWORK:    //表示只在用户在线的时候才需要的文件，不会缓存</span><br><span class="line">  c.js</span><br><span class="line">FALLBACK</span><br><span class="line">/        /index.html     //表示如果找不到第一个资源就用第二个资源代替</span><br></pre></td></tr></table></figure></p>
<hr>
<h3 id="、web-worker，web-worker"><a href="#、web-worker，web-worker" class="headerlink" title="、web worker，web worker"></a>、web worker，web worker</h3><p>是运行在浏览器后台的js程序，他不影响主程序的运行，是另开的一个js线程，可以用这个线程执行复杂的数据操作，然后把操作结果通过postMessage传递给主线程，这样在进行复杂且耗时的操作时就不会阻塞主线程了。</p>
<hr>
<h1 id="CSS3"><a href="#CSS3" class="headerlink" title="CSS3"></a>CSS3</h1><ul>
<li>css3的新特性哪些，你都用过哪些 5%<h2 id="媒体查询具体到语句-5"><a href="#媒体查询具体到语句-5" class="headerlink" title="媒体查询具体到语句 5%"></a>媒体查询具体到语句 5%</h2>作用：媒体查询可以让我们根据设备显示器的特性（如视口宽度、屏幕比例、设备方向：横向或纵向）为其设定CSS样式，检测的媒体特性有 width 、 height 和 color （等）。</li>
</ul>
<h2 id="响应式布局meta-scale-怎样使用media"><a href="#响应式布局meta-scale-怎样使用media" class="headerlink" title="响应式布局meta,scale 怎样使用media?"></a>响应式布局meta,scale 怎样使用media?</h2><h3 id="meta-scale"><a href="#meta-scale" class="headerlink" title="meta,scale"></a>meta,scale</h3><p>第一步：<br> 首先需要在html文档中添加以下代码，用来兼容移动设备的显示效果</p>
<meta name="viewport content=" width="device-width,initial-scale=1,maximum-scale=1,user-scalable=no"/">

ps:
>width=device-width:宽度等于当前设备的宽度
initial-scale=1：初始的缩放比例（默认为1）
maximum-scale=1：允许用户缩放到得最大比例（默认为1）
user-scalable=no：用户不能手动缩放

### 第二步：媒体查询 语句
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@media screen and (max-width:720px) and (min-width:320px)&#123;</span><br><span class="line"></span><br><span class="line">      body&#123;</span><br><span class="line"></span><br><span class="line">       background-color:red;</span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">@media screen and (max-width:320px)&#123;</span><br><span class="line"></span><br><span class="line">      body&#123;</span><br><span class="line"></span><br><span class="line">         background-color:blue;</span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

## css 伪类 5%
### 伪类选择器
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">p:first-of-type	选择属于其父元素的首个 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。</span><br><span class="line">p:last-of-type	选择属于其父元素的最后 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。</span><br><span class="line">p:only-of-type	选择属于其父元素唯一的 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。</span><br><span class="line">p:only-child		选择属于其父元素的唯一子元素的每个 &lt;p&gt; 元素。</span><br><span class="line">p:nth-child(2)	选择属于其父元素的第二个子元素的每个 &lt;p&gt; 元素。</span><br></pre></td></tr></table></figure>

***
### 伪类 伪元素
伪类是给元素模拟添加类 ，来实现某种效果（：）
常见伪类：

![Paste_Image.png](http://upload-images.jianshu.io/upload_images/2377897-394530a71e54ed9f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

伪元素是模拟添加个元素来实现效果（::）(css3出现后做的区分)
常见伪元素：

![Paste_Image.png](http://upload-images.jianshu.io/upload_images/2377897-e655b83124da94d9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

http://web.jobbole.com/86181/

## 说一下flex 3%
### 请解释一下CSS3的Flexbox（弹性盒布局模型）,以及适用场景？
 一个用于页面布局的全新CSS3功能，Flexbox可以把列表放在同一个方向（从上到下排列，从左到右），并让列表能延伸到占用可用的空间。
   较为复杂的布局还可以通过嵌套一个伸缩容器（flex container）来实现。
   采用Flex布局的元素，称为Flex容器（flex container），简称"容器"。
   它的所有子元素自动成为容器成员，称为Flex项目（flex item），简称"项目"。
   常规布局是基于块和内联流方向，而Flex布局是基于flex-flow流可以很方便的用来做局中，能对不同屏幕大小自适应。
   在布局上有了比以前更加灵活的空间
http://www.w3cplus.com/css3/flexbox-basics.html

***
## 动画 2%

  二维动画——animation  这个属性必须配合@keyframes动画关键帧来使用。keyframes里面包含一个百分数，后面跟上在这段时间内变换的css样式。
     animation是一个复合属性，它包括以下几个组成部分：
   * 1.animation-name：执行动画的keyframes的名字。
    * 2.animation-duration：执行动画的总时长。
    * 3.animation-timing-function：指定过渡函数。
    * 4.animation-delay：执行延迟时间。
    *  5.animation-direction：动画播放的方式。这个属性的值主要有：normal正常播放模式、reverse倒序播放、alternate
                  动画在奇数次正向播放偶数次倒序播放、alternate-reverse动画在奇数次倒序播放偶数次正向播放。
     *  6.animation-iteration-count：动画执行的次数。infinite是无限次，写一个数字就是要执行几次。
      *  7.animation-fill-mode：执行完动画后物体停止的位置。forwards是停在结束的位置上、backwards是快速执行初始帧
                  （这个最好配合延迟来观察）、
                  none是回到初始帧的位置、both是同时具有forwards和backwards的效果。
        *  8.animation-play-state：控制动画的播放状态。running是播放、paused是暂停。
***
## css3动画卡了

    transform: transition3d(0, 0, 0);
    transform: translateZ(0);
    这两个属性可以开启GPU加速模式
    然而面试官问我为什么，你知道原理么？
    这两个属性都会开启GPU硬件加速模式，从而让浏览器在渲染动画的时候从CPU转向GPU
## less
*  Less 有了解过吗？有什么好处？
   什么是CSS 预处理器 / 后处理器？
    * 预处理器例如：LESS、Sass、Stylus，用来预编译Sass或less，增强了css代码的复用性，
    还有层级、mixin、变量、循环、函数等，具有很方便的UI组件模块化开发能力，极大的提高工作效率。
   * 后处理器例如：PostCSS，通常被视为在完成的样式表中根据CSS规范处理CSS，让其更有效；目前最常做的是给CSS属性添加浏览器私有前缀，实现跨浏览器兼容性的问题。
## 常见的浏览器端的存储技术都有哪些，以及他们的优缺点和使用场景？
有时需要将网页中的一些数据保存在浏览器端，这样做的好处是，当下次访问页面时，不需要再次向服务器请求数据，直接就可以从本地读取数据。目前常用的有以下几种方法：
### **cookie**
cookie会随着每次HTTP请求头信息一起发送，无形中增加了网络流量，另外，cookie能存储的数据容量有限，根据浏览器类型不同而不同，IE6大约只能存储2K，cookie数据大小不能超过4k
### **Flash ShareObject**
这种方式能能解决上面提到的cookie存储的两个弊端，而且能够跨浏览器，应该说是目前最好的本地存储方案。不过，需要在页面中插入一个Flash，当浏览器没有安装Flash控件时就不能用了。所幸的是，没有安装Flash的用户极少。
缺点：需要安装Flash插件。
### **sessionStorage**
使用于Firefox2+的火狐浏览器，用这种方式存储的数据仅窗口级别有效，同一个窗口（或者Tab）页面刷新或者跳转，都能获取到本地存储的数据，当新开窗口或者页面时，原来的数据就失效了。
缺点：IE不支持、不能实现数据的持久保存。
### **localStorage**
localStorage是Web Storage互联网存储规范中的一部分，现在在Firefox 3.5、Safari 4和IE8中得到支持。
缺点：低版本浏览器不支持。

提示：localStorage储存的值都是字符串类型，使用时要注意。另外，可以在浏览器调试器中的Resources的localStorage中看到储存的信息。
>//存储信息   （存储的信息名称，要存储的字符串）
localStorage.setItem("CC_email_list",input_eamil[i])
//读取信息   （要读取的信息名称）
localStorage.getItem("CC_email_list")
//清除信息    （要清除的信息名称）
localStorage.removeItem("CC_email_list");

### **globalStorage**
使用于Firefox2+的火狐浏览器，类似于IE的userData。
1 //赋值 2 globalStorage[location.hostname]['name'] = 'tugai'; 3 //读取 4 globalStorage[location.hostname]['name']; 5 //删除 6 globalStorage[location.hostname].removeItem('name');
### **Google Gear**
Google开发出的一种本地存储技术。
缺点：需要安装Gear组件。
### **userData**
IE浏览器可以使用userData来存储数据，容量可达到640K，这种方案是很可靠的，不需要安装额外的插件。缺点：它仅在IE下有效。
缺点：IE不支持。

结论：Flash shareobject是不错的选择，如果你不想在页面上嵌入Flash，可以结合使用userData(IE6+)和globalStorage(Firefox2+)和localStorage(chrome3+)实现跨浏览器。
***
## 请描述一下 cookies，sessionStorage 和 localStorage 的区别？

    cookie是网站为了标示用户身份而储存在用户本地终端（Client Side）上的数据（通常经过加密）。
    cookie数据始终在同源的http请求中携带（即使不需要），记会在浏览器和服务器间来回传递。
    sessionStorage和localStorage不会自动把数据发给服务器，仅在本地保存。
### 存储大小：
        cookie数据大小不能超过4k。
        sessionStorage和localStorage 虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大。
### 有期时间：
        localStorage    存储持久数据，浏览器关闭后数据不丢失除非主动删除数据；
        sessionStorage  数据在当前浏览器窗口关闭后自动删除。
        cookie          设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭

***
## html 获取页面，浏览器，屏幕宽高
一个页面的展示，从外到内的容器为：屏幕->浏览器->页面本身。
HTML元素展现在页面内->页面展现在浏览器内->而浏览器展现在屏幕内。
通过Js的一些对象可以获取这些容器的高度、宽度。
1：总

![Paste_Image.png](http://upload-images.jianshu.io/upload_images/2377897-c6dff4f74e7f2eb3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)


2:屏幕
![Paste_Image.png](http://upload-images.jianshu.io/upload_images/2377897-f47a188d60bd97a4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
3:浏览器

![Paste_Image.png](http://upload-images.jianshu.io/upload_images/2377897-8e3d9af0d6d264b0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

![Paste_Image.png](http://upload-images.jianshu.io/upload_images/2377897-5e416993bde1fdb7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)


5:可视区 
定义：可视区域是指能显示网页内容区域的宽高。
拉动控制台的时候网页可视区域的宽高也会随之改变。
可视区宽高跟内容宽高没关系。

如果内容超过可视区域的高度或者宽度就出现滚动条。要获取可视区域的宽高每个浏览器的获取方法不一样

[参照](http://www.cnblogs.com/polk6/p/5051935.html)
***
## Doctype
1.Doctype作用
位置：<!DOCTYPE>声明位于html第一行
作用： 告知浏览器用什么标准解析html文档
            <!DOCTYPE>不存在，或者格式不正确，会导致文档以兼容模 (怪异模式)式出现

语法：
      HTML 顶级元素 可用性 "注册//组织//类型 标签//定义 语言""URL"
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN"> 
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Strict//EN">

其中，DTD的是W3C所发布的一个文档类型定义，简单的说，就是告诉浏览器你的这个HTML，是根据那个标准写的，解析的时候用哪个标准解析。




http://www.qdfuns.com/notes/21146/12ba5b538dd5974b1bee88f77c71b0a0.html
***

##为什么HTML5就只要写<!DOCTYPE HTML>?
HTML 4.01 中的 doctype 需要对 DTD 进行引用，因为 HTML 4.01 基于 SGML。 HTML 5 不基于 SGML，因此不需要对 DTD 进行引用，但是需要 doctype 来规范浏览器的行为。
其中，SGML是标准通用标记语言,简单的说，就是比HTML,XML更老的标准，这两者都是由SGML发展而来的。BUT，HTML5不是的。
***
## 标准模式与兼容模式（怪异模式）各有什么区别?

A：在标准模式中，浏览器根据规范呈现页面；在混杂模式中，页面以一种比较宽松向后兼容的方式显示。简单的说，就是尽可能的显示能显示的东西给用户看。（但是会有些样式失效）

1：width不同
在严格模式中 ：width是内容宽度 ，元素真正的宽度 = width+（padding+border+margin）2
在兼容模式中 ：width则是元素的实际宽度 ，内容宽度 = width - ( padding2+border2)

2.兼容模式下可设置百分比的高度和行内元素的高宽
    在Standards模式下，给span等行内元素设置wdith和height都不会生效，而在兼容模式下，则会生效。
    在standards模式下，一个元素的高度是由其包含的内容来决定的，如果父元素没有设置高度，子元素设置一个百分比的高度是无效的。

3.用margin:0 auto设置水平居中在IE下会失效
    使用margin:0 auto在standards模式下可以使元素水平居中，但在兼容模式下却会失效（用text-align属性解决）
    body{text-align:center};#content{text-align:left}

4.兼容模式下Table中的字体属性不能继承上层的设置，white-space:pre会失效，设置图片的padding会失效

***
## 介绍一下你对浏览器内核的理解？
主要分成两部分：渲染引擎(layout engineer或Rendering Engine)和JS引擎。
  渲染引擎：负责取得网页的内容（HTML、XML、图像等等）、整理讯息（例如加入CSS等），以及计算网页的显示方式，然后会输出至显示器或打印机。浏览器的内核的不同对于网页的语法解释会有不同，所以渲染的效果也不相同。所有网页浏览器、电子邮件客户端以及其它需要编辑、显示网络内容的应用程序都需要内核。

JS引擎则：解析和执行javascript来实现网页的动态效果。
***
常见的浏览器内核有哪些？
 Trident内核：IE,MaxThon,TT,The World,360,搜狗浏览器等。[又称MSHTML]
  Gecko内核：Netscape6及以上版本，FF,MozillaSuite/SeaMonkey等
  Presto内核：Opera7及以上。      [Opera内核原为：Presto，现为：Blink;]
  Webkit内核：Safari,Chrome等。   [ Chrome的：Blink（WebKit的分支）]
***
## HTML、XML、XHTML 有什么区别？
HTML是被设计用来显示数据的，重点是:显示数据以及如何显示数据更好上面。
XML是被设计用来描述数据的，重点是:什么是数据，如何存放数据。
XHTML基于HTML的基础上进行了扩展和规范，让XHTML更加严格，主要目的是促进HTML向XML过渡。

HTML的弊端：
编码不规范，结构混乱臃肿，需要智能的终端才能很好的显示；
表现和结构混乱，不利于开发和维护；
不能使用于更多的网络设备中，比如手机；
为了让HTML逐渐过渡到XML阶段，w3c又定制了XHTML标准。

而XML的弊端也不少：
在数据中寻找信息非常难
大数据量效率低
使用XML传输数据时没有数据库系统那样的信息管理功能
因此XML因为自身严苛限制等因素逐渐被HTML5取代。
***
## 怎样理解 HTML 语义化？
HTML语义化能提高网页语义的清晰度，方便爬虫工具识别网站内容，爬虫工具在识别网站内容时不会受到网站样式的影响，只会关注网站内容本身
HTML的语义化能够提高团队对网站的维护和改进效率
改善网页的可访问性，遇到视觉障碍用户时屏幕阅读器能够更好的系别网页内容

***
## iframe有那些缺点？

  * iframe会阻塞主页面的Onload事件；
  * 搜索引擎的检索程序无法解读这种页面，不利于SEO;

  * iframe和主页面共享连接池，而浏览器对相同域的连接有限制，所以会影响页面的并行加载。

  使用iframe之前需要考虑这两个缺点。如果需要使用iframe，最好是通过javascript
  动态给iframe添加src属性值，这样可以绕开以上两个问题。
***

## 为什么要初始化CSS样式。
- 因为浏览器的兼容问题，不同浏览器对有些标签的默认值是不同的，如果没对CSS初始化往往会出现浏览器之间的页面显示差异。

  - 当然，初始化样式会对SEO有一定的影响，但鱼和熊掌不可兼得，但力求影响最小的情况下初始化。
淘宝的样式初始化代码：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">body, h1, h2, h3, h4, h5, h6, hr, p, blockquote, dl, dt, dd, ul, ol, li, pre, form, fieldset, legend, button, input, textarea, th, td &#123; margin:0; padding:0; &#125;</span><br><span class="line">body, button, input, select, textarea &#123; font:12px/1.5tahoma, arial, \5b8b\4f53; &#125;</span><br><span class="line">h1, h2, h3, h4, h5, h6&#123; font-size:100%; &#125;</span><br><span class="line">address, cite, dfn, em, var &#123; font-style:normal; &#125;</span><br><span class="line">code, kbd, pre, samp &#123; font-family:couriernew, courier, monospace; &#125;</span><br><span class="line">small&#123; font-size:12px; &#125;</span><br><span class="line">ul, ol &#123; list-style:none; &#125;</span><br><span class="line">a &#123; text-decoration:none; &#125;</span><br><span class="line">a:hover &#123; text-decoration:underline; &#125;</span><br><span class="line">sup &#123; vertical-align:text-top; &#125;</span><br><span class="line">sub&#123; vertical-align:text-bottom; &#125;</span><br><span class="line">legend &#123; color:#000; &#125;</span><br><span class="line">fieldset, img &#123; border:0; &#125;</span><br><span class="line">button, input, select, textarea &#123; font-size:100%; &#125;</span><br><span class="line">table &#123; border-collapse:collapse; border-spacing:0; &#125;</span><br></pre></td></tr></table></figure>

## 用纯CSS创建一个三角形的原理是什么？
 把上、左、右三条边隐藏掉（颜色设为 transparent）

>  #demo {
    width: 0;
    height: 0;
    border-width: 20px;
    border-style: solid;
    border-color: transparent transparent red transparent;
  }
***
## 经常遇到的浏览器的兼容性有哪些？原因，解决方法是什么，常用hack的技巧 ？
 * png24位的图片在iE6浏览器上出现背景，解决方案是做成PNG8.

  * 浏览器默认的margin和padding不同。解决方案是加一个全局的*{margin:0;padding:0;}来统一。

  * IE6双边距bug:块属性标签float后，又有横行的margin情况下，在ie6显示margin比设置的大。

    浮动ie产生的双倍距离 #box{ float:left; width:10px; margin:0 0 0 100px;}

    这种情况之下IE会产生20px的距离，解决方案是在float的标签样式控制中加入 ——_display:inline;将其转化为行内属性。(_这个符号只有ie6会识别)

    渐进识别的方式，从总体中逐渐排除局部。

    首先，巧妙的使用“\9”这一标记，将IE游览器从所有情况中分离出来。
    接着，再次使用“+”将IE8和IE7、IE6分离开来，这样IE8已经独立识别。

    css
        .bb{
            background-color:red;/*所有识别*/
            background-color:#00deff\9; /*IE6、7、8识别*/
            +background-color:#a200ff;/*IE6、7识别*/
            _background-color:#1e0bd1;/*IE6识别*/
        }


  *  IE下,可以使用获取常规属性的方法来获取自定义属性,
     也可以使用getAttribute()获取自定义属性;
     Firefox下,只能使用getAttribute()获取自定义属性。
     解决方法:统一通过getAttribute()获取自定义属性。

  *  IE下,even对象有x,y属性,但是没有pageX,pageY属性;
     Firefox下,event对象有pageX,pageY属性,但是没有x,y属性。

  *  解决方法：（条件注释）缺点是在IE浏览器下可能会增加额外的HTTP请求数。

  *  Chrome 中文界面下默认会将小于 12px 的文本强制按照 12px 显示,
     可通过加入 CSS 属性 -webkit-text-size-adjust: none; 解决。

  超链接访问过后hover样式就不出现了 被点击访问过的超链接样式不在具有hover和active了解决方法是改变CSS属性的排列顺序:
  L-V-H-A :  a:link {} a:visited {} a:hover {} a:active {}
***
## 什么是外边距合并？
外边距合并指的是，当两个垂直外边距相遇时，它们将形成一个外边距。
  合并后的外边距的高度等于两个发生合并的外边距的高度中的较大者。
  w3school介绍网址： http://www.w3school.com.cn/css/css_margin_collapsing.asp
***
## zoom:1的清除浮动原理?
清除浮动，触发hasLayout；
  Zoom属性是IE浏览器的专有属性，它可以设置或检索对象的缩放比例。解决ie下比较奇葩的bug。
  譬如外边距（margin）的重叠，浮动清除，触发ie的haslayout属性等。

  来龙去脉大概如下：
  当设置了zoom的值之后，所设置的元素就会就会扩大或者缩小，高度宽度就会重新计算了，这里一旦改变zoom值时其实也会发生重新渲染，运用这个原理，也就解决了ie下子元素浮动时候父元素不随着自动扩大的问题。

  Zoom属是IE浏览器的专有属性，火狐和老版本的webkit核心的浏览器都不支持这个属性。然而，zoom现在已经被逐步标准化，出现在 CSS 3.0 规范草案中。

  目前非ie由于不支持这个属性，它们又是通过什么属性来实现元素的缩放呢？
  可以通过css3里面的动画属性scale进行缩放。 
  ***
## 如何居中div？

水平居中：给div设置一个宽度，然后添加margin:0 auto属性

 div{
     width:200px;
     margin:0 auto;
  }
让绝对定位的div居中

 div {
     position: absolute;
     width: 300px;
     height: 300px;
     margin: auto;
     top: 0;
     left: 0;
     bottom: 0;
     right: 0;
     background-color: pink;    /* 方便看效果 */
 }

水平垂直居中一

 确定容器的宽高 宽500 高 300 的层
 设置层的外边距

 div {
     position: relative;        /* 相对定位或绝对定位均可 */
     width:500px;
     height:300px;
     top: 50%;
     left: 50%;
     margin: -150px 0 0 -250px;         /* 外边距为自身宽高的一半 */
     background-color: pink;         /* 方便看效果 */

  }

水平垂直居中二

 未知容器的宽高，利用 `transform` 属性

 div {
     position: absolute;        /* 相对定位或绝对定位均可 */
     width:500px;
     height:300px;
     top: 50%;
     left: 50%;
     transform: translate(-50%, -50%);
     background-color: pink;         /* 方便看效果 */

 }

水平垂直居中三

 利用 flex 布局
 实际使用时应考虑兼容性

 .container {
     display: flex;
     align-items: center;         /* 垂直居中 */
     justify-content: center;    /* 水平居中 */

 }
 .container div {
     width: 100px;
     height: 100px;
     background-color: pink;        /* 方便看效果 */
 } 
## position的值relative和absolute定位原点是？

    absolute
      生成绝对定位的元素，相对于值不为 static的第一个父元素进行定位。
    fixed （老IE不支持）
      生成绝对定位的元素，相对于浏览器窗口进行定位。
    relative
      生成相对定位的元素，相对于其正常位置进行定位。
    static
      默认值。没有定位，元素出现在正常的流中（忽略 top, bottom, left, right z-index 声明）。
    inherit
      规定从父元素继承 position 属性的值。
***

# HTML5
## 新特性
### 1:标签语义化，
比如header，footer，nav，aside，article，section等，新增了很多表单元素，入email，url等，除去了center等样式标签，还有除去了有性能问题的frame，frameset等标签

### 2、音视频元素，
video，audio的增加使得我们不需要在依赖外部的插件就可以往网页中加入音视频元素。

### 3、新增很多api，
比如获取用户地理位置的window.navigator.geoloaction

### 、websocket
websocket是伴随html5到来的基于tcp/ip的全双工通信的协议。
主要通信过程：先借http完成握手，达到了长连接
第一步：浏览器基于tcp，发送http请求
第二步：服务器端，接收到请求后。将 tcp用户网络层协议变为websocket协议，完成了握手
第三步：服务器端和浏览器完成握手，他们之间形成一条通道，可以源源不断的传送信息
websocket是一种协议，可以让我们建立客户端到服务器端的全双工通信，这就意味着服务器端可以主动推送数据到客户端。
***
### 、HTML5 能够本地存储数据，在之前都是使用 cookies 使用的。
HTML5 提供了下面本地存储方案：webstorage包括localeStorage和sessionStorage，localeStorage是持久化存储在客户端，只要用户不主动删除，就不会消失，sessionStorage也是存储在客户端，但是他的存在时间是一个回话，一旦浏览器的关于该回话的页面关闭了，sessionStorage就消失了，
***
### ：请描述一下 cookies，sessionStorage 和 localStorage 的区别？
  cookie是网站为了标示用户身份而储存在客户端上的数据（通常经过加密）。
  cookie数据始终在同源的http请求中携带（即使不需要），记会在浏览器和服务器间来回传递。
  sessionStorage和localStorage不会自动把数据发给服务器，仅在本地保存。

  存储大小：
      cookie数据大小不能超过4k。
      sessionStorage和localStorage 虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大。

  有期时间：
      localStorage    存储持久数据，浏览器关闭后数据不丢失除非主动删除数据；
      sessionStorage  数据在当前浏览器窗口关闭后自动删除。
      cookie  在过期时间之前一直有效，即使窗口或浏览器关闭
## 具体应用
### cookie:
document.cookie = name, value, expires, domain, path, secure
encodeURIComponent
decodeURIComponent(document.cookie.substring(cookieStart + cookieName.length, cookieEnd)
### localStoragey用法
localStorage储存的值都是字符串类型，使用时要注意。另外，可以在浏览器调试器中的Resources的localStorage中看到储存的信息。
>//存储信息   （存储的信息名称，要存储的字符串）
storage = window.localStorage
storage.setItem("CC_email_list",input_eamil[i])
//读取信息   （要读取的信息名称）
storage.getItem("CC_email_list")
//清除信息    （要清除的信息名称）
storage.removeItem("CC_email_list");
storage.clear();
### sessionStorage:
sessionStorage用法和localStorage完全一致，差别只在有效期：

***

### 1.什么是cookie？
    答：cookie是用于在客户端存储会话信息的。
### 4.如何操作cookie？
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">var CookieUtil = &#123;</span><br><span class="line">    // 设置cookie</span><br><span class="line">    set : function (name, value, expires, domain, path, secure) &#123;</span><br><span class="line">        var cookieText = &quot;&quot;;</span><br><span class="line">        cookieText += encodeURIComponent(name) + &quot;=&quot; + encodeURIComponent(value);</span><br><span class="line">        if (expires instanceof Date) &#123;</span><br><span class="line">            cookieText += &quot;; expires=&quot; + expires.toGMTString();</span><br><span class="line">        &#125;</span><br><span class="line">        if (path) &#123;</span><br><span class="line">            cookieText += &quot;; path=&quot; + path;</span><br><span class="line">        &#125;</span><br><span class="line">        if (domain) &#123;</span><br><span class="line">            cookieText += &quot;; domain=&quot; + domain;</span><br><span class="line">        &#125;</span><br><span class="line">        if (secure) &#123;</span><br><span class="line">            cookieText += &quot;; secure&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        document.cookie = cookieText;</span><br><span class="line">    &#125;,</span><br><span class="line">    // name=value; expires=expiration_time; path=domain_path; domain=domain_name; secure</span><br><span class="line">    // 获取cookie</span><br><span class="line">    get : function (name) &#123;</span><br><span class="line">        var cookieName = encodeURIComponent(name) + &quot;=&quot;,</span><br><span class="line">            cookieStart = document.cookie.indexOf(cookieName),</span><br><span class="line">            cookieValue = &quot;&quot;;</span><br><span class="line">        if (cookieStart &gt; -1) &#123;</span><br><span class="line">            var cookieEnd = document.cookie.indexOf (&quot;;&quot;, cookieStart);</span><br><span class="line">            if (cookieEnd == -1) &#123;</span><br><span class="line">                cookieEnd = document.cookie.length;</span><br><span class="line">            &#125;</span><br><span class="line">            cookieValue = decodeURIComponent(document.cookie.substring(cookieStart + cookieName.length, cookieEnd));</span><br><span class="line">        &#125;</span><br><span class="line">        return cookieValue; </span><br><span class="line">    &#125;,</span><br><span class="line">    // 删除cookie</span><br><span class="line">    unset : function (name, domain, path, secure) &#123;</span><br><span class="line">        this.set(name, &quot;&quot;, Date(0), domain, path, secure);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">// 测试</span><br><span class="line">CookieUtil.set(&quot;name&quot;, &quot;zhang&quot;);</span><br><span class="line">var name = CookieUtil.get(&quot;name&quot;);</span><br><span class="line">alert(name);    // zhang</span><br><span class="line">CookieUtil.unset(&quot;name&quot;);</span><br><span class="line">alert(CookieUtil.get(&quot;name&quot;));  // 空</span><br></pre></td></tr></table></figure>

### 2.cookie的组成部分？
    ①名称：一个唯一确定cookie 的名称。建议区分大小写。cookie 的名称必须是经过URL 编码的。
    ②值：储存在cookie 中的字符串值。值必须被URL 编码。
    ③域：cookie 对于哪个域是有效的。所有向该域发送的请求中都会包含这个cookie 信息。这个值可以包含子域（subdomain，如www.wrox.com），也可以不包含它（如.wrox.com，则对于wrox.com的所有子域都有效）。如果没有明确设定，那么这个域会被认作来自设置cookie 的那个域。
    ④路径：对于指定域中的那个路径，应该向服务器发送cookie。例如，你可以指定cookie 只有从http://www.wrox.com/books/ 中才能访问，那么http://www.wrox.com 的页面就不会发送cookie 信息，即使请求都是来自同一个域的。
    ⑤失效时间：表示cookie 何时应该被删除的时间戳。默认情况下，浏览器会话结束时即将所有cookie 删除；不过也可以自己设置删除时间。这个值是个GMT 格式的日期（Wdy, DD-Mon-YYYY HH:MM:SS GMT），用于指定应该删除cookie 的准确时间。因此，cookie 
    可在浏览器关闭后依然保存在用户的机器上。如果你设置的失效日期是个以前的时间，则cookie 会被立刻删除。
    ⑥安全标志：指定后，cookie 只有在使用SSL 连接的时候才发送到服务器。例如，cookie 信息只能发送给https://www.wrox.com，而http://www.wrox.com 的请求则不能发送cookie。
### 3.列举一个cookie的例子？
    以下是一个完整的cookie的例子，我们将把它分解开来：
    Set-Cookie: name=value; expires=Mon, 22-Jan-07 07:10:24 GMT; domain=.wrox.com; path=/; secure
    ①名称: name字符串表示
    ②值：value字符串表示
    ③过期时间：Mon, 22-Jan-07 07:10:24 GMT
    ④域名：.wrox.com
    ⑤路径：当前目录/
    ⑥安全标志：secure
***
### 、应用程序缓存：
在用户没有与因特网连接时，可以正常访问站点或应用，在用户与因特网连接时，更新用户机器上的缓存文件。
  原理：HTML5的离线存储是基于一个新建的.appcache文件的缓存机制(不是存储技术)，通过这个文件上的解析清单离线存储资源，这些资源就会像cookie一样被存储了下来。之后当网络在处于离线状态下时，浏览器会通过被离线存储的数据进行页面展示。

html5允许我们自己控制哪些文件需要缓存，哪些不需要，具体的做法如下：

1、首先给html添加manifest属性，并赋值为cache.manifest
2、cache.manifest的内容为: 
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">  CACHE MANIFEST</span><br><span class="line">  #v1.2</span><br><span class="line">  CACHE :           //表示需要缓存的文件</span><br><span class="line">    a.js</span><br><span class="line">    b.js</span><br><span class="line">NETWORK:    //表示只在用户在线的时候才需要的文件，不会缓存</span><br><span class="line">  c.js</span><br><span class="line">FALLBACK</span><br><span class="line">/        /index.html     //表示如果找不到第一个资源就用第二个资源代替</span><br></pre></td></tr></table></figure>

***
### 、web worker，web worker
是运行在浏览器后台的js程序，他不影响主程序的运行，是另开的一个js线程，可以用这个线程执行复杂的数据操作，然后把操作结果通过postMessage传递给主线程，这样在进行复杂且耗时的操作时就不会阻塞主线程了。
***
### 标签页的通信
localstorge在一个标签页里被添加、修改或删除时，都会触发一个storage事件，通过在另一个标签页里监听storage事件，即可得到localstorge存储的值，实现不同标签页之间的通信。
标签页1：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;input id=&quot;name&quot;&gt;  </span><br><span class="line">&lt;input type=&quot;button&quot; id=&quot;btn&quot; value=&quot;提交&quot;&gt;  </span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;  </span><br><span class="line">    $(function()&#123;    </span><br><span class="line">        $(&quot;#btn&quot;).click(function()&#123;    </span><br><span class="line">            var name=$(&quot;#name&quot;).val();    </span><br><span class="line">            localStorage.setItem(&quot;name&quot;, name);   </span><br><span class="line">        &#125;);    </span><br><span class="line">    &#125;);    </span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

标签页2：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;  </span><br><span class="line">    $(function()&#123;   </span><br><span class="line">        window.addEventListener(&quot;storage&quot;, function(event)&#123;    </span><br><span class="line">            console.log(event.key + &quot;=&quot; + event.newValue);    </span><br><span class="line">        &#125;);     </span><br><span class="line">    &#125;);  </span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

使用cookie+setInterval，将要传递的信息存储在cookie中，每隔一定时间读取cookie信息，即可随时获取要传递的信息。
标签页1： 
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;input id=&quot;name&quot;&gt;  </span><br><span class="line">&lt;input type=&quot;button&quot; id=&quot;btn&quot; value=&quot;提交&quot;&gt;  </span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;  </span><br><span class="line">    $(function()&#123;    </span><br><span class="line">        $(&quot;#btn&quot;).click(function()&#123;    </span><br><span class="line">            var name=$(&quot;#name&quot;).val();    </span><br><span class="line">            document.cookie=&quot;name=&quot;+name;    </span><br><span class="line">        &#125;);    </span><br><span class="line">    &#125;);    </span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

标签页2：  
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;  </span><br><span class="line">    $(function()&#123;   </span><br><span class="line">        function getCookie(key) &#123;    </span><br><span class="line">            return JSON.parse(&quot;&#123;\&quot;&quot; + document.cookie.replace(/;\s+/gim,&quot;\&quot;,\&quot;&quot;).replace(/=/gim, &quot;\&quot;:\&quot;&quot;) + &quot;\&quot;&#125;&quot;)[key];    </span><br><span class="line">        &#125;     </span><br><span class="line">        setInterval(function()&#123;    </span><br><span class="line">            console.log(&quot;name=&quot; + getCookie(&quot;name&quot;));    </span><br><span class="line">        &#125;, 10000);    </span><br><span class="line">    &#125;);  </span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

# 重排重绘
## 浏览器从下载文档到显示页面的过程
  * 浏览器引擎会解析HTML文档来构建DOM树
  * 根据DOM元素的几何属性构建一棵用于渲染的树
渲染树的每个节点都有大小和边距等属性，类似于盒子模型（由于隐藏元素不需要显示，渲染树中并不包含DOM树中隐藏的元素）。当渲染树构建完成后，浏览器就可以将元素放置到正确的位置了
  * 根据渲染树节点的样式属性绘制出页面。
## 重绘redraw
重绘是一个元素外观的改变所触发的浏览器行为，例如改变visibility、背景色等属性。浏览器会根据元素的新属性重新绘制，使元素呈现新的外观。
重绘不会带来重新布局，并不一定伴随重排。
## 重排
重排是几何上的改变，可以理解为渲染树需要重新计算。
###  触发重排：
   * 1.DOM元素的几何属性变化（定位，位置）
      * 渲染树中的相关节点就会失效，重新构建渲染树中失效的节点，根据新的渲染树重新绘制这部分页面
       * 例如：动画
       * 一个元素重排可能会使其他元素重排重绘
    * 2.DOM树的结构变化（dom增删，移动）
        * 例如节点的增减、移动等，也会触发重排
     * 3.获取某些属性（offsetWidth和offsetHeight）
　浏览器引擎可能会针对重排做了优化。比如Opera，它会等到有足够数量的变化发生，或者等到一定的时间，或者等一个线程结束，再一起处理，这样就只发生一次重排。但除了渲染树的直接变化，当获取一些属性时，浏览器为取得正确的值也会触发重排。这样就使得浏览器的优化失效了。这些属性包括：offsetTop、offsetLeft、 offsetWidth、offsetHeight、scrollTop、scrollLeft、scrollWidth、scrollHeight、clientTop、clientLeft、clientWidth、clientHeight、getComputedStyle() (currentStyle in IE)。
所以，在多次使用这些值时应进行缓存。

### 减少重排
 * 将多次改变样式属性封装成一个类，用js加上类
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">div.changeDiv &#123;</span><br><span class="line">background: #eee;</span><br><span class="line">color: #093;</span><br><span class="line">height: 200px;</span><br><span class="line">&#125;</span><br><span class="line">document.getElementById(‘changeDiv’).className = ‘changeDiv’;</span><br></pre></td></tr></table></figure>

   * 将需要多次重排的元素，position属性设为absolute或fixed
这样此元素就脱离了文档流，它的变化不会影响到其他元素。例如有动画效果的元素就最好设置为绝对定位。
* 最小化DOM深度
减少你的DOM树的大小和每个分支的元素数量。你的文档越小，越浅，重排就会越快。如果你不支持旧版的浏览器，可能你要移除不需要的包裹元素。
* 保证n次创建，1次写入。
例如要异步获取表格数据，渲染到页面。可以先取得数据后在内存中构建整个表格的html片段，再一次性添加到文档中去，而不是循环添加每一行。
* dom 复杂操作时，先隐藏，再显示
由于display属性为none的元素不在渲染树中，对隐藏的元素操作不会引发其他元素的重排。如果要对一个元素进行复杂的操作时，可以先隐藏它，操作完成后再显示。这样只在隐藏和显示时触发2次重排。
* 
在多次使用这些值时应进行缓存。
## 表格排序考虑到减少重排重绘
保证n次创建，1次写入。

***
# CSS3
## css3的新特性哪些，你都用过哪些 5%
CSS3有哪些新内容，请至少说出5个。

   1）border-radius。CSS3圆角表格

   2）font-effect。以往对网页上的文字加特效只能用filter属性，但是在CSS3中专门制定了一个加文字特效的属性，而且不止加阴影这种效果。

   3）text-underline-style，text-underline-color，text-underline-mode，text-underline-position。丰富了对链接下划线的样式，以往的下划线都是直线，这次可不一样了，有波浪线、点线、虚线等等，更可对下划线的颜色和
位置进行任意改变，哈哈~~下划线的世界从此不再单一。（还有对应顶线和中横线的样式，效果与下划线类似）

   4）font-emphasize-style和font-emphasize-position。我们在做笔记时经常要在文字下点几个点或打个圈什么的，以示重点，CSS3也开始加入了这项功能，这应该在某些特定网页上很有用。

   5）Font-face可以用来加载字体样式，而且它还能够加载服务器端的字体文件，显示客户端没有安装的字体。
***
## 媒体查询具体到语句 5%
作用：媒体查询可以让我们根据设备显示器的特性（如视口宽度、屏幕比例、设备方向：横向或纵向）为其设定CSS样式，检测的媒体特性有 width 、 height 和 color （等）。

##  响应式布局meta,scale 怎样使用media?
### meta,scale
第一步：
 首先需要在html文档中添加以下代码，用来兼容移动设备的显示效果
<meta name="viewport content=" width="device-width,initial-scale=1,maximum-scale=1,user-scalable=no"/">

<p>ps:</p>
<blockquote>
<p>width=device-width:宽度等于当前设备的宽度<br>initial-scale=1：初始的缩放比例（默认为1）<br>maximum-scale=1：允许用户缩放到得最大比例（默认为1）<br>user-scalable=no：用户不能手动缩放</p>
</blockquote>
<h3 id="第二步：媒体查询-语句"><a href="#第二步：媒体查询-语句" class="headerlink" title="第二步：媒体查询 语句"></a>第二步：媒体查询 语句</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@media screen and (max-width:720px) and (min-width:320px)&#123;</span><br><span class="line"></span><br><span class="line">      body&#123;</span><br><span class="line"></span><br><span class="line">       background-color:red;</span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">@media screen and (max-width:320px)&#123;</span><br><span class="line"></span><br><span class="line">      body&#123;</span><br><span class="line"></span><br><span class="line">         background-color:blue;</span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="css-伪类-5"><a href="#css-伪类-5" class="headerlink" title="css 伪类 5%"></a>css 伪类 5%</h2><h3 id="伪类选择器"><a href="#伪类选择器" class="headerlink" title="伪类选择器"></a>伪类选择器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">p:first-of-type	选择属于其父元素的首个 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。</span><br><span class="line">p:last-of-type	选择属于其父元素的最后 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。</span><br><span class="line">p:only-of-type	选择属于其父元素唯一的 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。</span><br><span class="line">p:only-child		选择属于其父元素的唯一子元素的每个 &lt;p&gt; 元素。</span><br><span class="line">p:nth-child(2)	选择属于其父元素的第二个子元素的每个 &lt;p&gt; 元素。</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="伪类-伪元素-1"><a href="#伪类-伪元素-1" class="headerlink" title="伪类 伪元素"></a>伪类 伪元素</h3><p>伪类是给元素模拟添加类 ，来实现某种效果（：）<br>常见伪类：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2377897-394530a71e54ed9f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<p>伪元素是模拟添加个元素来实现效果（::）(css3出现后做的区分)<br>常见伪元素：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2377897-e655b83124da94d9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<p><a href="http://web.jobbole.com/86181/" target="_blank" rel="external">http://web.jobbole.com/86181/</a></p>
<h2 id="说一下flex-3"><a href="#说一下flex-3" class="headerlink" title="说一下flex 3%"></a>说一下flex 3%</h2><h3 id="请解释一下CSS3的Flexbox（弹性盒布局模型）-以及适用场景？"><a href="#请解释一下CSS3的Flexbox（弹性盒布局模型）-以及适用场景？" class="headerlink" title="请解释一下CSS3的Flexbox（弹性盒布局模型）,以及适用场景？"></a>请解释一下CSS3的Flexbox（弹性盒布局模型）,以及适用场景？</h3><p> 一个用于页面布局的全新CSS3功能，Flexbox可以把列表放在同一个方向（从上到下排列，从左到右），并让列表能延伸到占用可用的空间。<br>   较为复杂的布局还可以通过嵌套一个伸缩容器（flex container）来实现。<br>   采用Flex布局的元素，称为Flex容器（flex container），简称”容器”。<br>   它的所有子元素自动成为容器成员，称为Flex项目（flex item），简称”项目”。<br>   常规布局是基于块和内联流方向，而Flex布局是基于flex-flow流可以很方便的用来做局中，能对不同屏幕大小自适应。<br>   在布局上有了比以前更加灵活的空间<br><a href="http://www.w3cplus.com/css3/flexbox-basics.html" target="_blank" rel="external">http://www.w3cplus.com/css3/flexbox-basics.html</a></p>
<hr>
<h2 id="动画-2"><a href="#动画-2" class="headerlink" title="动画 2%"></a>动画 2%</h2><p>  二维动画——animation  这个属性必须配合@keyframes动画关键帧来使用。keyframes里面包含一个百分数，后面跟上在这段时间内变换的css样式。<br>     animation是一个复合属性，它包括以下几个组成部分：</p>
<ul>
<li>1.animation-name：执行动画的keyframes的名字。<ul>
<li>2.animation-duration：执行动画的总时长。</li>
<li>3.animation-timing-function：指定过渡函数。</li>
<li>4.animation-delay：执行延迟时间。</li>
<li>5.animation-direction：动画播放的方式。这个属性的值主要有：normal正常播放模式、reverse倒序播放、alternate<pre><code>动画在奇数次正向播放偶数次倒序播放、alternate-reverse动画在奇数次倒序播放偶数次正向播放。
</code></pre></li>
<li>6.animation-iteration-count：动画执行的次数。infinite是无限次，写一个数字就是要执行几次。<ul>
<li>7.animation-fill-mode：执行完动画后物体停止的位置。forwards是停在结束的位置上、backwards是快速执行初始帧<pre><code>（这个最好配合延迟来观察）、
none是回到初始帧的位置、both是同时具有forwards和backwards的效果。
</code></pre></li>
<li>8.animation-play-state：控制动画的播放状态。running是播放、paused是暂停。</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h2 id="css3动画卡了"><a href="#css3动画卡了" class="headerlink" title="css3动画卡了"></a>css3动画卡了</h2><pre><code>transform: transition3d(0, 0, 0);
transform: translateZ(0);
这两个属性可以开启GPU加速模式
然而面试官问我为什么，你知道原理么？
这两个属性都会开启GPU硬件加速模式，从而让浏览器在渲染动画的时候从CPU转向GPU。
</code></pre><hr>
<h1 id="移动端"><a href="#移动端" class="headerlink" title="移动端"></a>移动端</h1><p><a href="https://www.v2ex.com/t/359985?p=1" target="_blank" rel="external">https://www.v2ex.com/t/359985?p=1</a><br><a href="http://caibaojian.com/vw-vh.html" target="_blank" rel="external">http://caibaojian.com/vw-vh.html</a><br><a href="https://aotu.io/notes/2017/04/28/2017-4-28-CSS-viewport-units/" target="_blank" rel="external">https://aotu.io/notes/2017/04/28/2017-4-28-CSS-viewport-units/</a></p>
<h2 id="移动端适配："><a href="#移动端适配：" class="headerlink" title="移动端适配："></a>移动端适配：</h2><ul>
<li>通常<br>通常使用响应式布局和弹性布局+媒体查询配置多个响应断点<br>缺陷：布局在响应断点范围内的分辨率下维持不变，而在响应断点切换的瞬间，布局带来断层式的切换变化，如同卡带的唱机般“咔咔咔”地一下又一下。</li>
<li>rem单位动态计算<br>rem单位的动态计算的弹性布局，则是需要在头部内嵌一段脚本来进行监听分辨率的变化来动态改变根元素字体大小，使得 CSS 与 JS 耦合了在一起。</li>
<li>vh,vw视口单位实现适配<ul>
<li>优点：既能解决响应式断层问题，又能解觉rem决脚本依赖的问题的。</li>
<li>缺点：由于相对于视口为单位，随着视口增大而增大，失去了最大最小宽度限制</li>
</ul>
</li>
<li>vw+rem<ul>
<li>rem 弹性布局的核心在于动态改变根元素大小，那么我们可以通过：<ul>
<li>给根元素大小设置随着视口变化而变化的 vw 单位，这样就可以实现动态改变其大小。</li>
<li>限制根元素字体大小的最大最小值，配合g body 加上最大宽度和最小宽度</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h2 id="自适应，响应式布局："><a href="#自适应，响应式布局：" class="headerlink" title="自适应，响应式布局："></a>自适应，响应式布局：</h2><ul>
<li><p>设置meta viewport</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">　&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot; /&gt;</span><br><span class="line">目的是：网页宽度默认等于屏幕宽度（width=device-width），原始缩放比例（initial-scale=1）为1.0，即网页初始大小占屏幕面积的100%。</span><br></pre></td></tr></table></figure>
</li>
<li><p>媒体查询</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@media screen and (max-device-width: 400px) &#123;&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>不指定像素宽度<br>宽度定百分比或者width:auto</p>
</li>
<li>相对大小的字体<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">* 流动布局</span><br><span class="line">各个区块的位置都是浮动的（float），不是固定不变的,绝对定位的使用也要 非常小心</span><br><span class="line">***</span><br><span class="line">## meta</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>meta是干嘛用的？<br>Meta标签是用来描述网页属性的一种语言，标准的Meta标签可以便于搜索引擎排序，提高搜索引擎网站权重排名。</p>
<ul>
<li>两个属性name 和 http-equiv<ul>
<li>name<ul>
<li>keywords<br>设置你网页的关键字。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>&lt;meta name =”keywords”<br>     content=”science,education,culture,politics”</p>
<pre><code>* description：
  用来告诉搜索引擎你的网站主要内容。
 尽可能准确地描述网页的核心内容，通常为网页内容的摘要信息，也就是希望搜索引擎在检索结果中展示的摘要信息（100中文字之内）
* robots：
 告诉搜索机器人哪些页面需要索引，哪些页面不需要索引
 all,none,index,noindex,follow,nofollow
* author:作者
</code></pre><ul>
<li>http-equiv：相当于http的文件头作用<ul>
<li>Expires（期限）<br>可以用于设定网页的到期时间。一旦网页过期，必须到服务器上重新传输。<br>注意：必须使用GMT的时间格式。<br>用法：<meta http-equiv="expires" content="Fri,12 Jan 2001 18:18:18 GMT"></li>
<li>Pragma(cache模式）<br>说明：禁止浏览器从本地计算机的<a href="http://baike.baidu.com/view/907.htm" target="_blank" rel="external">缓存</a>中访问页面内容。<meta http-equiv="Pragma" content="no-cache"></li>
<li>Refresh（刷新）<br>自动刷新并转到新页面。<br><meta http-equiv="Refresh" content="2;URL">；</li>
<li>Set-Cookie(cookie设定）<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">***</span><br><span class="line">## meta viewport</span><br><span class="line">&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, minimum-scale=1, maximum-scale=1, user-scalable=no&quot;&gt;</span><br><span class="line">### 视窗基本属性</span><br><span class="line">* width：控制 viewport 的大小，你可以给它指定一个值，如：600，或者甚至还可以给它一个特殊的值，如：device-width，device-width为设备的宽度（单位为缩放为 100% 时的 CSS 的像素）。</span><br><span class="line">* height：与 width 相对应，指定viewport 高度。</span><br><span class="line">* initial-scale：初始缩放比例，也即是当页面第一次 load 的时候缩放比例。</span><br><span class="line">* maximum-scale：允许用户缩放到的最大比例。</span><br><span class="line">* minimum-scale：允许用户缩放到的最小比例。</span><br><span class="line">* user-scalable：是否允许用户手动缩放。</span><br><span class="line">### 三个视窗</span><br><span class="line">* 布局视窗：css定义的网页内容宽度，网页内容宽度跟移动端浏览器窗口无关</span><br><span class="line">* 视觉视窗：用户正看的区域window.innerWidth/Height</span><br><span class="line">* 理想视窗：定义理想视口是浏览器的工作，而不是设备或操作系统的工作。因此，同一设备上的不同浏览器拥有不同的理想视口。screen.width/height返回是理想视口的尺寸</span><br><span class="line">[三个视窗](http://www.cnblogs.com/xiaohuochai/p/5496995.html)</span><br><span class="line">[meta-viewport](http://yunkus.com/meta-viewport-usage/)</span><br><span class="line">***</span><br><span class="line">## 媒体查询</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<p>@media screen and (max-width:480px){<br> .ads {<br>   display:none;<br>  }<br>}<br>@media screen and (min-width:600px) and (max-width:900px){<br>  body {background-color:#f5f5f5;}<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">***</span><br><span class="line">## flex弹性布局：</span><br><span class="line">* flex布局好处？不需要再给子元素设置定位，使用flex属性就可以让浏览器自己计算位置</span><br><span class="line">* 父块元素：display: flex;</span><br><span class="line">* 父行级元素：display: inline-flex;</span><br><span class="line">* 设置了flex布局后，子元素的float、clear和vertical-align属性就会失效</span><br><span class="line">* 具体描述：</span><br><span class="line">设置了 flex的父亲成为：flex容器，孩子成为flex项目</span><br><span class="line">  * 父亲容器属性：</span><br><span class="line">    * flex-direction(孩子横向还是竖向)：row(孩子水平)| row-reverse | column(孩子竖直) | column-reverse;</span><br><span class="line">    * flex-wrap(孩子换行)：nowrap | wrap | wrap-reverse;</span><br><span class="line">    * justify-content（孩子对齐方式）: flex-start | flex-end | center | space-between | space-around;</span><br><span class="line">   * 孩子項目屬性：</span><br><span class="line">     * order ：属性定义项目的排列顺序。数值越小，排列越靠前，默认为0</span><br><span class="line">     * flex-basis：属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。</span><br><span class="line">     * flex-grow：属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大</span><br><span class="line">     * flex-shrink：属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。</span><br><span class="line">     * align-self：属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。</span><br><span class="line">【问题】：</span><br><span class="line">flex弹性盒模型，主轴有几个方向？后代 flex：1代表什么？</span><br><span class="line">【答案】：</span><br><span class="line"></span><br><span class="line">flex-grow:0; 定义弹性盒子项的拉伸因子，即子项分配父项剩余空间的比，默认值为 0flex-shrink:1; 指定了 flex 元素的收缩规则，子项的收缩所占的份数，默认值为1 [ 当所有子项相加的宽度大于父项的宽度，每个子项减少的多出的父项宽度的 1/n ]felx-basis:auto; 指定了 flex 元素在主轴方向上的初始大小，即子项的宽度</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">***</span><br><span class="line">## grid system ，网格布局，栅格化 </span><br><span class="line">栅格化？</span><br><span class="line">http://www.cnblogs.com/dojo-lzz/p/4621627.html</span><br><span class="line">http://www.w3cplus.com/css/learncssgrid.html</span><br><span class="line">网格布局的好处？</span><br><span class="line">规范网页中的版面布局以及信息分布，让网页设计不再无规律可循。</span><br><span class="line">有规律的网页设计，可以为网页前端开发带来很多便利。</span><br><span class="line">栅格化主要好处是：快速开发、提高整站布局的一致性。</span><br><span class="line">缺点：灵活性可能稍嫌不足。但我觉得，划分 12 栏的网格系统其实也已具有较大的灵活性了。</span><br><span class="line">http://www.chinaz.com/design/2009/0527/77426.shtml</span><br><span class="line">* 创建网格容器</span><br><span class="line">display: grid/inline-grid</span><br><span class="line">网格项目默认纵项排列</span><br><span class="line">* 设置网格项目的高或者宽</span><br></pre></td></tr></table></figure></p>
<p>grid-template-columns/rows: 10px;<br>grid-template-columns: 1fr 1fr 2fr;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">***</span><br><span class="line"></span><br><span class="line">## px,em,rem，%的区别?</span><br><span class="line">*  px</span><br><span class="line">   相对屏幕分辨率</span><br><span class="line">* em</span><br><span class="line">  * 若自身定义了font-size，按照自身算</span><br><span class="line">  * 自身没定义就按照父元素算</span><br><span class="line">  * em的值并不是固定的</span><br><span class="line">  * 具体使用方案：</span><br></pre></td></tr></table></figure></p>
<p>   body选择器中声明Font-size=62.5%；<br>   16px*62.5% = 10px<br>    1em = 10px;<br>    IE浏览器:Font-size=63%<br>   将你的原来的px数值除以10，然后换上em作为单位；</p>
<p>重新计算那些被放大的字体的em数值。避免字体大小的重复声明。如：行高、字体大小。<br>缺陷：整个页面内1em不是一个固定的值，设置em要知道父元素font-size<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">* rem </span><br><span class="line">  * 相对于html根元素来算，免字体大小逐层复合</span><br><span class="line">  * 除了IE8及更早版本外，所有浏览器均已支持rem</span><br><span class="line">* 百分比</span><br><span class="line">  * 相对于父元素的百分比</span><br><span class="line">  * 使用：如果是随着父容器或者是整体页面布局而改变尺寸，则使用百分比更好，如元素的高度和宽度设置。</span><br><span class="line"></span><br><span class="line">***</span><br><span class="line">## 知道css新属性 vw vh ？【4】</span><br><span class="line">* 定义</span><br><span class="line">  * css3的新单位</span><br><span class="line">  * css3引入的”vw”和”vh”基于宽度/高度相对于窗口大小</span><br><span class="line">  * ”vw”=”view width”, “vh”=”view height”; </span><br><span class="line">  * 相对于浏览器窗口的大小定义的最佳方式</span><br><span class="line">  * 字体大小会随着你窗口改变而改变</span><br><span class="line">*  应用</span><br><span class="line">根据[CSS3规范](https://drafts.csswg.org/css-values-3/#viewport-relative-lengths)，视口单位主要包括以下4个：·</span><br><span class="line">vw : 1vw 等于视口宽度的1%</span><br><span class="line">vh : 1vh 等于视口高度的1%</span><br><span class="line">vmin : 选取 vw 和 vh 中最小的那个</span><br><span class="line">vmax : 选取 vw 和 vh 中最大的那个</span><br><span class="line">视口单位区别于%单位，视口单位是依赖于视口的尺寸，根据视口尺寸的百分比来定义的；而%单位则是依赖于元素的祖先元素。</span><br><span class="line">* 兼容性</span><br><span class="line">兼容主流浏览,IE兼容IE10</span><br><span class="line">***</span><br><span class="line">##  设备像素物理像素？</span><br><span class="line">###  设备像素(物理像素)</span><br><span class="line">又叫 物理像素，设备能控制显示的最小单位，</span><br><span class="line">### 设备独立像素（css像素）</span><br><span class="line">* 独立于设备的用于逻辑衡量像素的单位。平时用的虚拟像素，但不是屏幕分辨率。</span><br><span class="line">* 移动端，PC端通过screen.width/height获取的这个值是设备独立像素（CSS 像素），而不是设备的屏幕分辨率，因为设备的屏幕分辨率对于WEB开发者来说是无法通过代码来获得的，是完全透明的。 </span><br><span class="line">### 物理像素与设备独立像素</span><br><span class="line">* 在PC端浏览器默认情况下（100%，即页面没被缩放），一个物理像素 = 一个设备独立像素</span><br><span class="line">* 在移动端时候，一般物理像素与设备独立像素不相等，有一定的换算关系。</span><br><span class="line">设备像素比 = 物理像素/设备独立像素（在某个方向上）</span><br><span class="line">* 获取设备像素比 : window.devicePixelRatio</span><br><span class="line">### PPI</span><br><span class="line">像素密度（pixel density）. </span><br><span class="line">全称是（pixel per inch）就是每英寸内有多少个设备像素点. </span><br><span class="line">PPI的值越高，画质越好，也就是越细腻，看起来更有逼格。 </span><br><span class="line">标准的PPI是160, 不过现在屏幕标准的少了, 都超过了160. </span><br><span class="line">PPI 值超过300的叫做超高密度屏幕，Apple 给它换了个高大尚的名称：Retina视网膜屏幕</span><br><span class="line">***</span><br><span class="line">[设备像素](http://yunkus.com/physical-pixel-device-independent-pixels/)</span><br><span class="line">[物理像素](http://www.jianshu.com/p/af6dad66e49a)</span><br><span class="line">***</span><br><span class="line">## 用宽确定高，百分比（元素宽度为窗口的多少）</span><br></pre></td></tr></table></figure></p>
<p>1 使用padding，根据宽来定高，注意，元素有内容时，需要去除文本高度<br>width: 50%;padding: 25% 0;<br>2使用vw<br> width: 50vw;<br> height: 50vw;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">### css一个正方形，宽度是屏幕的一半，水平垂直居中</span><br><span class="line">* vw 获取屏幕的width</span><br><span class="line">* 垂直水平居中</span><br></pre></td></tr></table></figure></p>
<pre><code>width: 50vw;
height: 50vw;
position: absolute;
left: 50%;
top: 50%;
transform: translate(-50%, -50%);
background: pink;
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">* 当元素无内容的时候，padding: 25% 0;可以当作元素的高；</span><br></pre></td></tr></table></figure>
<pre><code>width: 50%;
padding: 25% 0;
position: absolute;
top: 50%;
left: 50%;
transform: translate(-50%, -50%);
background: red;
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">***</span><br><span class="line">## ul&gt;li列表，小于480时一行显示两个，大于480&lt;960时候一行显示三个</span><br><span class="line">* media ,vw,可以弄出元素的宽高</span><br></pre></td></tr></table></figure>
<p> @media screen and (max-width:480px) {<br>            li {<br>                width: 38vw;<br>                height: 38vw;<br>                background: pink;<br>                float: left;<br>                margin-left: 1vw;<br>                margin-bottom: 1vw;<br>            }<br>        }</p>
<pre><code>@media screen and (min-width:481px)and (max-width:960px) {
    li {
        width: 27vw;
        height: 27vw;
        background: greenyellow;
        float: left;
        margin-left: 1vw;
        margin-bottom: 1vw;
    }
}

@media screen and (min-width:962px) {
    li {
        width: 30vw;
        height: 30vw;
        background: purple;
        float: left;
        margin-left: 1vw;
        margin-bottom: 1vw;
    }
}

ul {
    position: relative;
}
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line"></span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class="line">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, minimum-scale=1, maximum-scale=1, user-scalable=no&quot;&gt;</span><br><span class="line">    &lt;title&gt;响应式&lt;/title&gt;</span><br><span class="line">    &lt;style type=&quot;text/css&quot;&gt;</span><br><span class="line">        @media screen and (max-width:480px) &#123;</span><br><span class="line">            li &#123;</span><br><span class="line">                width: 44%;</span><br><span class="line">                padding: 22% 0;</span><br><span class="line">                background: pink;</span><br><span class="line">                float: left;</span><br><span class="line">                margin-left: 1%;</span><br><span class="line">                margin-bottom: 1%;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        @media screen and (min-width:480px)and (max-width:960px) &#123;</span><br><span class="line">            li &#123;</span><br><span class="line">                width: 30%;</span><br><span class="line">                padding: 15% 0;</span><br><span class="line">                background: green;</span><br><span class="line">                float: left;</span><br><span class="line">                margin-left: 1%;</span><br><span class="line">                margin-bottom: 1%;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        ul &#123;</span><br><span class="line">            position: relative;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        ul&gt;li &#123;</span><br><span class="line">            list-style-type: none;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        @media screen and (min-width:960px) &#123;</span><br><span class="line">            li &#123;</span><br><span class="line">                width: 30%;</span><br><span class="line">                padding: 15% 0;</span><br><span class="line">                background: red;</span><br><span class="line">                float: left;</span><br><span class="line">                margin-left: 1%;</span><br><span class="line">                margin-bottom: 1%;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line"></span><br><span class="line">&lt;/head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div class=&apos;con&apos;&gt;</span><br><span class="line">        &lt;ul&gt;</span><br><span class="line">            &lt;li&gt;1&lt;/li&gt;</span><br><span class="line">            &lt;li&gt;2&lt;/li&gt;</span><br><span class="line">            &lt;li&gt;3&lt;/li&gt;</span><br><span class="line">            &lt;li&gt;4&lt;/li&gt;</span><br><span class="line">            &lt;li&gt;5&lt;/li&gt;</span><br><span class="line">            &lt;li&gt;6&lt;/li&gt;</span><br><span class="line">        &lt;/ul&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="JS"><a href="#JS" class="headerlink" title="JS"></a>JS</h1><h2 id="js数据类型有哪些-5"><a href="#js数据类型有哪些-5" class="headerlink" title="js数据类型有哪些 5%"></a>js数据类型有哪些 5%</h2><p>数据类型分为：简单数据类型和引用<br> (五大)简单数据类型 ：数字 ，字符串 ， 布尔值(true/false)， null，undifined<br>引用：数组，函数，正则表达式，对象</p>
<hr>
<h2 id="null-和undefined"><a href="#null-和undefined" class="headerlink" title="null 和undefined"></a>null 和undefined</h2><p><a href="http://www.ruanyifeng.com/blog/2014/03/undefined-vs-null.html" target="_blank" rel="external">http://www.ruanyifeng.com/blog/2014/03/undefined-vs-null.html</a></p>
<ul>
<li>相似性：<ul>
<li>undefined和null在if语句中，都会被自动转为false<ul>
<li>undefined == null // true</li>
</ul>
</li>
</ul>
</li>
<li>null：<ul>
<li>null表示”没有对象”，即该处不应该有值</li>
<li>用法：<ul>
<li>原型链的终点</li>
<li>作为函数的参数，表示该函数的参数不是对象</li>
</ul>
</li>
</ul>
</li>
<li>undefined<ul>
<li>undefined表示”缺少值”，就是此处应该有一个值，但是还没有定义</li>
<li>典型用法是：<ul>
<li>变量定义了没有赋值</li>
<li>函数应该传递的参数没有传递</li>
<li>对象定义属性没有赋值</li>
<li>函数没有返回值的时候 返回undefined</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h2 id="简单说一下作用域与作用域链-5"><a href="#简单说一下作用域与作用域链-5" class="headerlink" title="简单说一下作用域与作用域链 5%"></a>简单说一下作用域与作用域链 5%</h2><h3 id="作用域和作用域链"><a href="#作用域和作用域链" class="headerlink" title="作用域和作用域链"></a>作用域和作用域链</h3><p>因为当某个函数第一次被调用时候，会创建相应的执行环境和作用域链<br>并把作用域链赋值给内部属性：scope,使用this,arguments和函数的初始参数为活动对象（活动对象就是函数执行上下文中的变量）<br>当在函数中访问变量的时候，需要在作用域链中进行查找，先访问自己的内部的，再访问外部的，再访问外部外部的，直到作用域链的终点：全局执行环境<br>创建函数时，会创建包含函数外部对象的 作用域链，作用域链保存在当前函数的scope中<br>调用函数时，会创建执行环境，创建执行环境的作用域链：是靠复制函数的scope里面的对象<br>作用域链的本质是指向变量对象的指针链表，指引用，不实际包含变量对象</p>
<h3 id="谈一下关于作用域"><a href="#谈一下关于作用域" class="headerlink" title="谈一下关于作用域"></a>谈一下关于作用域</h3><p>  函数里外变量名相同,取函数内部的。Es6 作用域和他一样吗</p>
<ul>
<li>es5函数作用域，作用域链<br>es5只有全局作用域和函数作用域<ul>
<li>作用域<br>作用域指的是变量的作用范围。</li>
<li>作用域链<br>函数内部作用域由函数的参数，局部变量，函数构成。内部作用域和外部的作用域一层层的链接起来形成作用域链。<br>当在函数内部要访问一个变量的时候，首先查找自己的内部作用域有没有这个变量，如果没有就到这个函数所在的外层作用域中找，直到到window所在的作用域。</li>
</ul>
</li>
<li>es6作用域<br>函数内部访问一个变量,由于块级作用域，只能在函数内部查找是否有这个变量，若函数内部没有这个变量还去访问会报错。</li>
</ul>
<hr>
<h2 id="原型-原型链-原型继承（说一下原型-原型链，考了几道题-让你现在作答）-5"><a href="#原型-原型链-原型继承（说一下原型-原型链，考了几道题-让你现在作答）-5" class="headerlink" title="原型 原型链 原型继承（说一下原型 原型链，考了几道题 让你现在作答） 5%"></a>原型 原型链 原型继承（说一下原型 原型链，考了几道题 让你现在作答） 5%</h2><p>请简单说一下原型,原型链，继承</p>
<h3 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h3><ul>
<li>来由：原型是在创建对象时原型模式里提出的概念</li>
<li>定义：创建的每个函数都有一个原型prototype属性，这个属性是一个指针,指向一个对象，这个对象包含着这个函数所有实例可以共享的函数和方法。<br>这个原型对象就是:函数每个原型</li>
<li>优点：可以让所有实例共享原型对象中的属性和方法</li>
<li>缺点：因为共享的特性，实例改写引用类型属性 会更改原型对象属性 使得其他实例属性也改变；还有一个：无法给函数初始化参数</li>
<li>prototype与在构造函数中定义属性和方法有什么区别？<ul>
<li>构造函数中的属性和方法，每个实例都将构造函数中的所有属性创建一遍副本，</li>
<li>缺点：无法共享一套属性 <ul>
<li>优点：每个实例改写属性后互不影响</li>
</ul>
</li>
</ul>
</li>
<li>使用构造函数模式+原型模式创建对象取两者优点<ul>
<li>可传递参数</li>
<li>每个实例都可以利用原型对象共享方法</li>
<li>将引用类型属性放到构造函数中，实例改写后互不影响<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function Person(name, age, job) &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.age = age;</span><br><span class="line">    this.job = job;</span><br><span class="line">    this.friends = [&apos;a&apos;, &apos;b&apos;];</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">    constructor: Person,</span><br><span class="line">    sayName: function() &#123;</span><br><span class="line">        console.log(this.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h3 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h3><ul>
<li>来由：原型链这个概念是在讲继承的时候提出的</li>
<li>定义：原型与实例层层递进构成的链条叫做原型链。某个原型对象等于另一函数的实例:child.prototype = new father()，孩子原型.proto指向父原型，父原型的.proto指向 父原型的原型，直到Object.prototype.proto = null</li>
<li>确定原型和实例的关系<ul>
<li>instance instanceof SubType</li>
<li>father.prototype.isPrototypeOf(child)<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3></li>
</ul>
</li>
<li><p>原型链继承 child.prototype = new father()</p>
<ul>
<li><p>缺点：</p>
<ul>
<li>访问重写父亲引用属性，会更改父原型</li>
<li>创建子类无法给父构造函数传递参数</li>
</ul>
</li>
<li><p>代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">function SuperType() &#123;</span><br><span class="line">    this.property = true;</span><br><span class="line">&#125;</span><br><span class="line">SuperType.prototype.getSuperValue = function() &#123; </span><br><span class="line">    return this.property;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function SubType() &#123;</span><br><span class="line">    this.subproperty = false;</span><br><span class="line">&#125;</span><br><span class="line">//先继承</span><br><span class="line">SubType.prototype = new SuperType(); </span><br><span class="line">//再添加方法</span><br><span class="line">SubType.prototype.getSubValue = function() &#123;</span><br><span class="line">    return this.subproperty;</span><br><span class="line">&#125;</span><br><span class="line">var instance = new SubType(); </span><br><span class="line">console.log(instance.getSuperValue()); //true</span><br><span class="line">//SuperType.prototype : constructor,getSuperValue(),proto</span><br><span class="line">//SubType.prototype : proto, property = true;getSubValue()</span><br><span class="line">// instance : proto , subproperty = false;</span><br><span class="line">//确定原型和实例的关系 instanceof /father.prototype.isPrototypeOf(child)</span><br><span class="line">console.log(instance instanceof SubType);</span><br><span class="line">console.log(instance instanceof SuperType);</span><br><span class="line">console.log(instance instanceof Object);</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>借用构造函数继承/经典继承</p>
<ul>
<li>定义：在子类构造函数中调用父类构造函数 ，子向父类传递参数</li>
<li>子类中Father.apply(this,param)</li>
<li>缺点：无法达到共享或者复用性（构造模式的问题）</li>
<li>优点：可给父类传递参数，副本属性</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function SuperType(name) &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">&#125;  </span><br><span class="line">function SubType() &#123;</span><br><span class="line">    //在子类构造函数中调用父类构造函数 实现了继承 还传递了参数</span><br><span class="line">    SuperType.call(this, &apos;carry&apos;);</span><br><span class="line">    //给子添加 属性</span><br><span class="line">    this.age = 19;</span><br><span class="line">&#125;</span><br><span class="line">var instance = new SubType();</span><br><span class="line">instance.name; //carry</span><br></pre></td></tr></table></figure>
<ul>
<li><p>组合继承（原型链继承+借用构造函数继承）</p>
<ul>
<li>定义：原型链继承(可继承方法：达到共享)+借用构造函数继承(可继承属性：有自己的副本属性)</li>
<li>组合继承是js中最常用的继承方式</li>
<li>优点：属性互不影响，又可以共用方法，两全其美</li>
<li>缺点：要调用两次父类的构造函数，造成了属性副本在子类原型中的多余 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">function SuperType(name) &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.colors = [&apos;green&apos;, &apos;red&apos;];</span><br><span class="line">&#125;</span><br><span class="line">SuperType.prototype.sayName = function() &#123;</span><br><span class="line">    alert(this.name);</span><br><span class="line">&#125;</span><br><span class="line">function SubType(name, age) &#123;</span><br><span class="line">    //继承实例属性</span><br><span class="line">    SuperType.call(this, name);</span><br><span class="line">    this.age = age;</span><br><span class="line">&#125;</span><br><span class="line">//继承父类方法</span><br><span class="line">SubType.prototype = new SuperType();</span><br><span class="line">SubType.prototype.sayAge = function() &#123;</span><br><span class="line">    alert(this.age);</span><br><span class="line">&#125;</span><br><span class="line">var i1 = new SubType(&apos;bill&apos;, 18);</span><br><span class="line">i1.colors.push(&apos;white&apos;);</span><br><span class="line">alert(i1.colors); //&apos;green&apos;, &apos;red&apos;,&apos;white&apos;</span><br><span class="line">i1.sayAge(); //18</span><br><span class="line">i1.sayName(); //bill</span><br><span class="line">var i2 = new SubType(&apos;carry&apos;, 28)</span><br><span class="line">i2.colors; //&apos;green&apos;, &apos;red</span><br><span class="line">i1.sayAge(); //28</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>原型式继承 var childObj = Object.create(fatherObj) //Object.create() = create()  </p>
<ul>
<li>在没有必要兴师动众的创建构造函数的情况下， 只想让两个对象保持差不多一致<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var peron = &#123;</span><br><span class="line">    name: &apos;carry1&apos;,</span><br><span class="line">    friends: [&apos;f1&apos;, &apos;f2&apos;]</span><br><span class="line">&#125;</span><br><span class="line">var np1 = Object.create(peron);</span><br><span class="line">np1.name = &apos;carry2&apos;;</span><br><span class="line">np1.friends.push(&apos;f3&apos;);</span><br><span class="line">var np2 = Object.create(peron, &#123;</span><br><span class="line">    name: &#123;</span><br><span class="line">        value: &apos;carry3&apos;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">console.log(np2.name); //carry3</span><br><span class="line">peron.friends; //f1,f2,f3</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>寄生式继承</p>
<ul>
<li>封装一个仅仅用于实现继承过程的函数 该函数 完成继承操作 然后返回子对象.</li>
<li>寄生式继承就是利用原型式继承的中Object.create(fatherObj)原理实现实例属性的继承，但是又可以在clone函数中定义自己的方法<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function createClone(father) &#123;</span><br><span class="line">    var clone = Object.create(father);</span><br><span class="line">    clone.sayHi = function() &#123;</span><br><span class="line">        alert(&apos;i am clone&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">    return clone;</span><br><span class="line">&#125;</span><br><span class="line">var peron = &#123;</span><br><span class="line">    name: &apos;carry1&apos;,</span><br><span class="line">    friends: [&apos;f1&apos;, &apos;f2&apos;]</span><br><span class="line">&#125;</span><br><span class="line">var child = createClone(Person);</span><br><span class="line">child.name = &apos;carry2&apos;;</span><br><span class="line">child.sayHi(); //&apos;i am clone&apos;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>寄生组合式继承</p>
<ul>
<li>采用 借用构造函数 来继承属性  使用 原型链的混成形式来继承 方法</li>
<li>用来完善组合式继承：因为组合式继承 要调用两次父类的构造函数，造成了在子类中又创建了一遍属性</li>
<li>优点：寄生式组合继承 只使用了一次 父类构造函数，避免了child.prototype上创建没必要的属性，原型链的结构还可以保持不变<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">function inheritPrototype(subType, superType) &#123;</span><br><span class="line">    var prototype = Object.create(SuperType.prototype); //创建对象</span><br><span class="line">    prototype.constructor = subType; //增强对象</span><br><span class="line">    subType.prototype = prototype; //指定对象</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function SuperType(name) &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.colors = [&apos;green&apos;, &apos;red&apos;];</span><br><span class="line">&#125;</span><br><span class="line">SuperType.prototype.sayName = function() &#123;</span><br><span class="line">    alert(this.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function SubType(name, age) &#123;</span><br><span class="line">    //继承属性</span><br><span class="line">    SuperType.call(this, name);</span><br><span class="line">    this.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//继承方法</span><br><span class="line">inheritPrototype(SubType, SuperType)</span><br><span class="line">SubType.prototype.sayAge = function() &#123;</span><br><span class="line">    alert(this.age);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<hr>
<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>闭包大纲</p>
<ul>
<li>什么是闭包？</li>
<li>闭包的原理？</li>
<li>平时如何用闭包，闭包能解决什么问题？</li>
</ul>
<h3 id="a：说一下什么是闭包"><a href="#a：说一下什么是闭包" class="headerlink" title="a：说一下什么是闭包?"></a>a：说一下什么是闭包?</h3><p>使用着另一个函数作用域中的变量的函数，保留变量并不被回收</p>
<h3 id="b-闭包的原理（深刻一点，包括作用域链，垃圾回收机制）"><a href="#b-闭包的原理（深刻一点，包括作用域链，垃圾回收机制）" class="headerlink" title="b:闭包的原理（深刻一点，包括作用域链，垃圾回收机制）"></a>b:闭包的原理（深刻一点，包括作用域链，垃圾回收机制）</h3><p>之所以内层函数可以访问外的变量是因为</p>
<ul>
<li>内部函数的作用域链中包含着外层函数的变量对象（活动对象和全局变量对象）</li>
<li>外层函数执行完毕后，它的执行环境和作用域链会被销毁，但被闭包引用的变量对象不被销毁</li>
</ul>
<p>如何销毁闭包：</p>
<ul>
<li>var a = outerFunction(‘123’);</li>
<li>使用闭包后,想销毁闭包的作用域链</li>
<li>a = null;//通知垃圾回收进行清除</li>
</ul>
<h3 id="c-你是如何应用闭包的"><a href="#c-你是如何应用闭包的" class="headerlink" title="c:你是如何应用闭包的?"></a>c:你是如何应用闭包的?</h3><p>使用闭包定义私有方法和变量</p>
<h4 id="1-模拟块级作用域（私有变量和作用域）"><a href="#1-模拟块级作用域（私有变量和作用域）" class="headerlink" title="1:模拟块级作用域（私有变量和作用域）"></a>1:模拟块级作用域（私有变量和作用域）</h4><p>只让for循环内访问变量i，立即函数模拟块级作用域，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">function foo3(count) &#123;</span><br><span class="line">    for (var i = 0; i &lt; count; i++) &#123;</span><br><span class="line">        console.log(&apos;inner:&apos; + i); //12345</span><br><span class="line">    &#125;</span><br><span class="line">    console.log(&apos;outer:&apos; + i); //5</span><br><span class="line">&#125;</span><br><span class="line">foo3(5);</span><br><span class="line"></span><br><span class="line">//使用立即函数和闭包定义块级作用域</span><br><span class="line">function foo4(count) &#123;</span><br><span class="line">    (function() &#123;</span><br><span class="line">        //块作用域</span><br><span class="line">        for (var i = 0; i &lt; count; i++) &#123;</span><br><span class="line">            console.log(&apos;inner:&apos; + i); //12345</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;)();</span><br><span class="line">    console.log(&apos;outer:&apos; + i); //报错</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="2：构造模式，定义接口，让外界可以访问函数的私有变量"><a href="#2：构造模式，定义接口，让外界可以访问函数的私有变量" class="headerlink" title="2：构造模式，定义接口，让外界可以访问函数的私有变量"></a>2：构造模式，定义接口，让外界可以访问函数的私有变量</h4><p>//定义构造函数，使用闭包访问函数的私有变量<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function Person(name) &#123;</span><br><span class="line">    this.getName = function() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line">    this.setName = function(value) &#123;</span><br><span class="line">        name = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var a = new Person(&apos;carry&apos;);</span><br><span class="line">var k =  a.getName(); //carry;</span><br><span class="line">a.setName(&apos;bill&apos;);</span><br><span class="line">a.getName(); //bill;</span><br></pre></td></tr></table></figure></p>
<h4 id="3：原型模式-私有作用域-定义接口"><a href="#3：原型模式-私有作用域-定义接口" class="headerlink" title="3：原型模式 私有作用域 定义接口"></a>3：原型模式 私有作用域 定义接口</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">(function() &#123;</span><br><span class="line">    //定义私有变量</span><br><span class="line">    var name = &apos;&apos;;</span><br><span class="line">    //定义私有方法</span><br><span class="line">    Person = function(value) &#123;</span><br><span class="line">            name = value;</span><br><span class="line">        &#125;</span><br><span class="line">        //定义接口</span><br><span class="line">    Person.prototype.getName = function() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line">    Person.prototype.setName = function(value) &#123;</span><br><span class="line">        name = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
<h4 id="4：模块化"><a href="#4：模块化" class="headerlink" title="4：模块化"></a>4：模块化</h4><p>retrun {f:f}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">function CoolModule() &#123;</span><br><span class="line">    var something = &quot;cool&quot;;</span><br><span class="line">    var another = [1, 2, 3];</span><br><span class="line"></span><br><span class="line">    function doSomething() &#123;</span><br><span class="line">        alert( something );</span><br><span class="line">    &#125;</span><br><span class="line">    function doAnother() &#123;</span><br><span class="line">        alert( another.join( &quot; ! &quot; ) );</span><br><span class="line">    &#125;</span><br><span class="line">    return &#123;</span><br><span class="line">        doSomething: doSomething,</span><br><span class="line">        doAnother: doAnother</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line">var foo = CoolModule();</span><br><span class="line">foo.doSomething(); // cool</span><br><span class="line">foo.doAnother(); // 1 ! 2 ! 3</span><br></pre></td></tr></table></figure></p>
<hr>
<h3 id="d-使用闭包应该注意？"><a href="#d-使用闭包应该注意？" class="headerlink" title="d:使用闭包应该注意？"></a>d:使用闭包应该注意？</h3><ul>
<li>1:闭包只能取某变量的最后一个值（for循环中的匿名函数）</li>
<li>2:闭包中的this指向全局环境，无法正常的访问作用域中的this和arguments,</li>
</ul>
<h4 id="1-闭包只能取某变量的最后一个值（for循环中的匿名函数）"><a href="#1-闭包只能取某变量的最后一个值（for循环中的匿名函数）" class="headerlink" title="1:闭包只能取某变量的最后一个值（for循环中的匿名函数）"></a>1:闭包只能取某变量的最后一个值（for循环中的匿名函数）</h4><p>下面函数的输出结果是 10个10<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function foo1() &#123;</span><br><span class="line">    var result = [];</span><br><span class="line">    for (var i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">        result[i] = function() &#123;</span><br><span class="line">            console.log(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>使用立即函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function foo1() &#123;</span><br><span class="line">    var result = [];</span><br><span class="line">    for (var i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">        result[i] = function(n) &#123;</span><br><span class="line">            return function() &#123;</span><br><span class="line">                console.log(n);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;(i);</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="2-闭包中的this指向-window"><a href="#2-闭包中的this指向-window" class="headerlink" title="2:闭包中的this指向 window"></a>2:闭包中的this指向 window</h4><p>this在运行时是基于函数的执行环境绑定的<br>匿名函数的执行环境具有全局性，闭包中的this指向window<br>闭包在执行环境中搜索 this和arguments<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var name = &apos;the window&apos;;</span><br><span class="line">var obj = &#123;</span><br><span class="line">    name: &apos;my obj&apos;,</span><br><span class="line">    getName: function() &#123;</span><br><span class="line">        var that = this;</span><br><span class="line">        return function() &#123;</span><br><span class="line">            return that.name;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">console.log(obj.getName());</span><br></pre></td></tr></table></figure></p>
<h3 id="d-闭包的优缺点"><a href="#d-闭包的优缺点" class="headerlink" title="d:闭包的优缺点"></a>d:闭包的优缺点</h3><p>优点：避免全局变量的污染，存在私有变量，使一个成员常驻内存。<br>缺点：闭包会常驻内存，会增大内存使用，使用不当容易造成内存溢出。<br>闭包会保存外层函数的变量对象，会占用更多的内存。<br>V 8优化后的js引擎会尝试回收被闭包占用的内存，但还需慎重使用闭包</p>
<h3 id="f-如何创建闭包"><a href="#f-如何创建闭包" class="headerlink" title="f:如何创建闭包"></a>f:如何创建闭包</h3><p>1.定义外层函数，和变量。<br>2.定义内层函数，并对外部函数的变量进行使用。<br>3.返回内层函数。<br>返回的内层函数，在其他地方被调用，仍然保存着外函数的变量。（通过访问闭包来访问变量，闭包使变量为私有变量）</p>
<h3 id="作用域和作用域链-1"><a href="#作用域和作用域链-1" class="headerlink" title="作用域和作用域链"></a>作用域和作用域链</h3><p>因为当某个函数第一次被调用时候，会创建相应的执行环境和作用域链<br>并把作用域链赋值给内部属性：scope,使用this,arguments和函数的初始参数为活动对象（活动对象就是函数执行上下文中的变量）<br>当在函数中访问变量的时候，需要在作用域链中进行查找，先访问自己的内部的，再访问外部的，再访问外部外部的，直到作用域链的终点：全局执行环境<br>创建函数时，会创建包含函数外部对象的 作用域链，作用域链保存在当前函数的scope中<br>调用函数时，会创建执行环境，创建执行环境的作用域链：是靠复制函数的scope里面的对象<br>作用域链的本质是指向变量对象的指针链表，指引用，不实际包含变量对象</p>
<h3 id="内存泄露，垃圾回收机制"><a href="#内存泄露，垃圾回收机制" class="headerlink" title="内存泄露，垃圾回收机制"></a>内存泄露，垃圾回收机制</h3><p>循环引用会导致内存泄露<br>在IE9之前版本使用闭包，会导致一些特殊的问题。例如，闭包的作用域链中保存着html元素，无法被销毁</p>
<ul>
<li>解决 定义访问的dom元素的副本，element = null; //解除对dom对象的引用<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function foo2() &#123;</span><br><span class="line">    var element = document.getElementById(&apos;someElement&apos;);</span><br><span class="line">    var id = element.id; //定义让闭包访问的副本</span><br><span class="line">    element.onclick = function() &#123;</span><br><span class="line">        alert(id);</span><br><span class="line">    &#125;;</span><br><span class="line">    element = null; //解除对dom对象的引用</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h3 id="函数声明与函数表达式"><a href="#函数声明与函数表达式" class="headerlink" title="函数声明与函数表达式"></a>函数声明与函数表达式</h3><p>function a (){};<br>a();<br>var a = function(){};<br>a();</p>
<p>函数声明方式后不能直接加 ()调用，需要 (function a (){})();</p>
<hr>
<h2 id="js事件-5"><a href="#js事件-5" class="headerlink" title="js事件 5%"></a>js事件 5%</h2><h3 id="事件模型"><a href="#事件模型" class="headerlink" title="事件模型"></a>事件模型</h3><ul>
<li>DOM0 :原始事件模型<ul>
<li>btn.onclick=function(){}这种类型的事件模型（btn.onclick = null;）</li>
<li>基于DOM0的事件，对于同一个dom节点而言，只能注册一个， 取后面事件。后边注册的同种事件会覆盖之前注册的。</li>
</ul>
</li>
<li>DOM2<ul>
<li>冒泡 ：事件从事件的发生地（目标元素），一直向上传递，直到window<ul>
<li>IE只支持事件冒泡</li>
</ul>
</li>
<li>捕获 ：事件是从window向下传递，直到事件的发生地（目标元素）</li>
<li>设置捕获和冒泡：<ul>
<li>IE：默认事件冒泡<ul>
<li>标准： addEventListener()第三个参数:捕获/冒泡 = true/false</li>
</ul>
</li>
</ul>
</li>
<li>绑定或者解除事件<ul>
<li>标准：addEventListener(type,handler),removeEventListener(type,handler)</li>
<li>IE: attachEvent,target.detachEvent(“on”+type,handler);</li>
</ul>
</li>
<li>阻止事件冒泡：evt.stopPropagation()/evt.cancelBubble=true</li>
<li>获取事件对象(标准||IE):var event=window.event||event; </li>
<li>获取事件源对象：var target = event.target||event.srcElement;</li>
<li>同一个节点元素，给她添加捕获和冒泡事件模型，捕获比冒泡快</li>
<li>绑定多个事件的顺序:比如说一下子注册了3个冒泡事件，那么执行顺序就按照注册的顺序来，先注册先执行</li>
</ul>
</li>
</ul>
<hr>
<h3 id="事件委托"><a href="#事件委托" class="headerlink" title="事件委托"></a>事件委托</h3><p>应用场景：动态添加 或删除孩子的时候<br>含义：孩子的事委托父亲做<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul id=&quot;ul1&quot;&gt;</span><br><span class="line">    &lt;li&gt;111&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;222&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;333&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;444&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line"></span><br><span class="line">window.onload = function()&#123;</span><br><span class="line">    var oUl = document.getElementById(&quot;ul1&quot;);</span><br><span class="line">   oUl.onclick = function()&#123;</span><br><span class="line">        alert(123);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里用父级ul做事件处理，当li被点击时，由于冒泡原理，事件就会冒泡到ul上，因为ul上有点击事件，所以事件就会触发.<br>当然，这里当点击ul的时候，也是会触发的，那么问题就来了，如果我想让事件代理的效果跟直接给节点的事件效果一样怎么办，比如说只有点击li才会触发，不怕，我们有绝招：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">window.onload = function()&#123;</span><br><span class="line">　　var oUl = document.getElementById(&quot;ul1&quot;);</span><br><span class="line">　　oUl.onclick = function(event)&#123;</span><br><span class="line">　　　　var ev = event || window.event;</span><br><span class="line">　　　　var target = ev.target || ev.srcElement;</span><br><span class="line">　　　　if(target.nodeName.toLowerCase() == &apos;li&apos;)&#123;</span><br><span class="line">　 　　　　　　 alert(123);</span><br><span class="line">　　　　　　　  alert(target.innerHTML);</span><br><span class="line">　　　　&#125;</span><br><span class="line">　　&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<p>##【事件相关问题】<br>1：阻止默认事件：preventDefault():<br>2：阻止冒泡：stopPropagation();<br>3：什么时候会事件捕获？应用事件捕获解决什么问题？<br>你想作全局的点击事件监听，相对于document结点与document下所有的子结点，在某个条件下要求所有的子结点点击无效，这种情况下冒泡模型就解决不了了，而捕获型却非常适合，可以在最顶层结点添加捕获型事件监听器。<br>3：事件冒泡和事件捕获分别有哪些浏览器支持？<br>IE只支持事件冒泡</p>
<hr>
<h2 id="浏览器对事件的处理过"><a href="#浏览器对事件的处理过" class="headerlink" title="浏览器对事件的处理过"></a>浏览器对事件的处理过</h2><ul>
<li>鼠标点击以后 浏览器对于事件的处理详细过程？<br>当(click)点击某个元素，以PC端为例，操作系统会将(click)鼠标点击事件广播到所有应用中，浏览器应用接受到鼠标事件广播后，查询事件源和对应的回函数（按照先捕获后冒泡的顺序），并压入事件处理队列（Event Queue）。Event Loop 则会从中取出回调函数并执行。<ul>
<li>注册（绑定）事件，浏览器干嘛了？<br>DOM.addEventListener，函数以类似”委托”的形式注册到浏览器内建的队列中，等到某个”事件”被触发后，则回Call之前注册的函数。</li>
<li>执行（响应）事件浏览器干嘛了？<br>当(click)点击某个元素，以PC端为例，操作系统会将(click)鼠标点击事件广播到所有应用中，浏览器应用接受到鼠标事件广播后，查询事件源和对应的回函数（按照先捕获后冒泡的顺序），并压入事件处理队列（Event Queue）。</li>
<li>异步<br>js中的异步没有从语言上约定其异步的特性，是浏览器/执行引擎来实现，我们所探讨的“异步”都是由执行引擎所赋予的。<br>javascript 是的单线程的，于是就产生了一种任务执行机制叫 eventloop。它维护了一个任务队列，完成一个任务才会开始下一个任务。</li>
</ul>
</li>
</ul>
<hr>
<h2 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收?"></a>垃圾回收?</h2><h3 id="为什么要垃圾回收？"><a href="#为什么要垃圾回收？" class="headerlink" title="* 为什么要垃圾回收？"></a>* 为什么要垃圾回收？</h3><p>由于字符串、对象和数组没有固定大小，所有当他们的大小已知时，才能对他们进行动态的存储分配。JavaScript程序每次创建字符串、数组或对象时，解释器都必须分配内存来存储那个实体。只要像这样动态地分配了内存，最终都要释放这些内存以便他们能够被再用，否则，JavaScript的解释器将会消耗完系统中所有可用的内存，造成系统崩溃。</p>
<h3 id="垃圾回收的基本方法？"><a href="#垃圾回收的基本方法？" class="headerlink" title="* 垃圾回收的基本方法？"></a>* 垃圾回收的基本方法？</h3><h4 id="1、标记清除（mark-and-sweep）"><a href="#1、标记清除（mark-and-sweep）" class="headerlink" title="1、标记清除（mark and sweep）"></a><strong>1、标记清除（mark and sweep）</strong></h4><p>　　这是javascript中最常用的垃圾回收方式。当变量进入执行环境是，就标记这个变量为“进入环境”。从逻辑上讲，永远不能释放进入环境的变量所占用的内存，因为只要执行流进入相应的环境，就可能会用到他们。当变量离开环境时，则将其标记为“离开环境”。　　垃圾收集器在运行的时候会给存储在内存中的所有变量都加上标记。然后，它会去掉环境中的变量以及被环境中的变量引用的标记。而在此之后再被加上标记的变量将被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。最后。垃圾收集器完成内存清除工作，销毁那些带标记的值，并回收他们所占用的内存空间。</p>
<h4 id="2。标记清除"><a href="#2。标记清除" class="headerlink" title="2。标记清除"></a>2。标记清除</h4><p>　　另一种不太常见的垃圾回收策略是引用计数。引用计数的含义是跟踪记录每个值被引用的次数。当声明了一个变量并将一个引用类型赋值给该*变量时，则这个值的引用次数就是1。相反，如果包含对这个值引用的变量又取得了另外一个值，则这个值的引用次数就减1。当这个引用次数变成0时，则说明没有办法再访问这个值了，因而就可以将其所占的内存空间给收回来。这样，垃圾收集器下次再运行时，它就会释放那些引用次数为0的值所占的内存。</p>
<h4 id="减少垃圾回收？"><a href="#减少垃圾回收？" class="headerlink" title="* 减少垃圾回收？"></a>* 减少垃圾回收？</h4><p> 1:只保留程序运行时需要的数据，对于已经使用的或者不需要的数据，应该将其值设为 null<br> 2:避免创建对象<br>    清空数组：array.length = 0</p>
<hr>
<h2 id="原生js的-增-删-改-5"><a href="#原生js的-增-删-改-5" class="headerlink" title="原生js的(增 删 改) 5%"></a>原生js的(增 删 改) 5%</h2><p><img src="http://upload-images.jianshu.io/upload_images/2377897-d9abdd592a00f11f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<h3 id="增"><a href="#增" class="headerlink" title="增"></a>增</h3><ul>
<li>若添加新元素：首先创建该元素节点，然后添加</li>
<li>创建元素节点：document.createElement(‘h1’)</li>
<li>创建文本节点：document.createTextNode(‘描述’)</li>
<li>增加：<ul>
<li>添加孩子<ul>
<li>A.append(B) : 把B追加到A内部</li>
<li>A.appendTo(B) : 把A追加到B内部</li>
<li>A.prepend(B) : 在A的开始添加孩子B</li>
<li>A.prependTo(B) : 把A追加到B的开始<ul>
<li>添加兄弟</li>
<li>A.after(B) :  在A后添加B</li>
<li>A.before(B): 在A前追加B</li>
<li>添加class</li>
<li>elm.classList.add(‘nn’)</li>
<li>elm.className+=” nn”  //nn前边有空格</li>
<li>parent.insertBefore(newNode,oldNode):在父节点n里面的B节点前面追加A<br>模拟insertAfter: parent.insertBefore(newNode,oN.nextsilibing());</li>
<li>替换节点：parent.replaceChild(child,oldElem);</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="删"><a href="#删" class="headerlink" title="删"></a>删</h3><ul>
<li>elementNow.remove():删除当前元素</li>
<li>parent.removeChild(child):删除父元素中的子元素</li>
<li>child.parentNode.removeChild(child)：不确定父元素的时候可以这样做<h3 id="改"><a href="#改" class="headerlink" title="改"></a>改</h3><a href="http://www.jianshu.com/writer#/notebooks/10862078/notes/15825654/preview" target="_blank" rel="external">http://www.jianshu.com/writer#/notebooks/10862078/notes/15825654/preview</a><ul>
<li>( 获取，设置) 修改HTML元素内容<ul>
<li>node.textContent:用来设置或是获取某个元素内所有文本内容，包括子元素中的内容。（css等兼容性比innerText好）</li>
<li>node.innerText: 只获取当前节点内容</li>
<li>node.innerHTML：</li>
<li>node.outerHTML：</li>
</ul>
</li>
<li>更改属性<ul>
<li>设置属性：node.setAttribute(‘style’,’color:red’)</li>
<li>获取属性：var a = node.getAttribute(‘’style’’);</li>
</ul>
</li>
<li>修改元素CSS<ul>
<li>node.style.color=”red”<h3 id="查"><a href="#查" class="headerlink" title="查"></a>查</h3></li>
</ul>
</li>
<li>querySelector()、</li>
<li>querySelectorAll()</li>
<li>getElementById()、</li>
<li>getElementsByTagName()、</li>
<li>getElementsByName()、</li>
<li>getElementsByClassName()、</li>
</ul>
</li>
</ul>
<hr>
<h3 id="jq增删改查"><a href="#jq增删改查" class="headerlink" title="jq增删改查"></a>jq增删改查</h3><ul>
<li>内部插入主要方法：<ul>
<li>append(content) 向每个匹配的元素内部追加内容。</li>
<li>prepend(content) 向每个匹配的元素内部前置内容。</li>
</ul>
</li>
<li>外部插入：<ul>
<li>after(content) 在每个匹配的元素之后插入内容。</li>
<li>before(content) 在每个匹配的元素之前插入内容。</li>
</ul>
</li>
<li>删除：<ul>
<li>empty() 删除匹配的元素集合中所有的子节点。</li>
<li>remove([expr]) 从DOM中删除所有匹配的元素。</li>
</ul>
</li>
</ul>
<hr>
<h2 id="深拷贝与浅拷贝"><a href="#深拷贝与浅拷贝" class="headerlink" title="深拷贝与浅拷贝"></a>深拷贝与浅拷贝</h2><p>深拷贝与浅拷贝是之于Array,Object来说的，来由背景，引用类型对象的赋值，一个改变，会引起另一个改变，因为两个变量指向同一个堆空间放的对象</p>
<ul>
<li>深拷贝和浅拷贝最根本的区别在于是否是真正获取了一个对象的复制实体，而不是引用地址<figure class="highlight plain"><figcaption><span>a = &#123;b:'k'&#125;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var c = a;</span><br><span class="line">a.b = &apos;carry&apos;;</span><br><span class="line">c.b? 答案是&apos;carry&apos;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>那么我们如何给引用类型对象赋值（copy），完全隔离，互不影响呢？</p>
<h3 id="数组深拷贝"><a href="#数组深拷贝" class="headerlink" title="数组深拷贝"></a>数组深拷贝</h3><ul>
<li>ES6拷贝数组Array.from， […oldArr]</li>
<li>使用循环遍历拷贝</li>
<li>使用slice，concat进行数组拷贝</li>
</ul>
<h4 id="1-使用slice，concat进行数组拷贝"><a href="#1-使用slice，concat进行数组拷贝" class="headerlink" title="1.使用slice，concat进行数组拷贝"></a>1.使用slice，concat进行数组拷贝</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1. var a = [1,2];</span><br><span class="line">var b = a.slice(0);</span><br><span class="line">b[0] = 3;</span><br><span class="line">alert(a) //1,2</span><br><span class="line">2. var a = [1,2];</span><br><span class="line">var b = a.concat(0);</span><br></pre></td></tr></table></figure>
<h4 id="2-使用循环遍历拷贝"><a href="#2-使用循环遍历拷贝" class="headerlink" title="2.使用循环遍历拷贝"></a>2.使用循环遍历拷贝</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var arr1=[1,2,3,4];</span><br><span class="line">var arr2=[];</span><br><span class="line">for(var i=0; i&lt;arr1.length; i++)&#123;</span><br><span class="line">  arr2[i]=arr1[i];</span><br><span class="line">&#125;</span><br><span class="line">arr1.push(5);</span><br><span class="line">arr2.push(6);</span><br><span class="line">alert(arr1); //12345</span><br><span class="line">alert(arr2); //12346</span><br></pre></td></tr></table></figure>
<h4 id="3-ES6拷贝数组Array-from，-…oldArr"><a href="#3-ES6拷贝数组Array-from，-…oldArr" class="headerlink" title="3. ES6拷贝数组Array.from， […oldArr]"></a>3. ES6拷贝数组Array.from， […oldArr]</h4><ul>
<li>第一种：var newArr = Array.from(oldArr);</li>
<li>第二种：var newArr = […oldArr]<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var arr1=[1,2,3];</span><br><span class="line">var arr2=Array.from(arr1);</span><br><span class="line">arr1.push(4);</span><br><span class="line">alert(arr1);  //1234</span><br><span class="line">alert(arr2);  //123</span><br><span class="line">arr2.push(5);</span><br><span class="line">alert(arr1);  //1234</span><br><span class="line">alert(arr2);  //1235</span><br></pre></td></tr></table></figure>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var arr1=[1,2,3];</span><br><span class="line">var arr2=[...arr1];</span><br><span class="line">arr1.push(4);</span><br><span class="line">alert(arr1);  //1234</span><br><span class="line">alert(arr2);  //123</span><br><span class="line">arr2.push(5);</span><br><span class="line">alert(arr1);  //1234</span><br><span class="line">alert(arr2);  //1235</span><br></pre></td></tr></table></figure>
<h3 id="对象深拷贝"><a href="#对象深拷贝" class="headerlink" title="对象深拷贝"></a>对象深拷贝</h3><ul>
<li>JSON对象的parse和stringify</li>
<li>jQuery中的extend复制方法</li>
</ul>
<h4 id="JSON对象的parse和stringify"><a href="#JSON对象的parse和stringify" class="headerlink" title="JSON对象的parse和stringify"></a>JSON对象的parse和stringify</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var source = &#123;</span><br><span class="line">    name:&quot;source&quot;,</span><br><span class="line">    child:&#123;</span><br><span class="line">        name:&quot;child&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var target = JSON.parse(JSON.stringify(source));</span><br><span class="line">//改变target的name属性</span><br><span class="line">target.name = &quot;target&quot;;</span><br><span class="line">console.log(source.name);   //source</span><br><span class="line">console.log(target.name);   //target</span><br><span class="line">//改变target的child</span><br><span class="line">target.child.name = &quot;target child&quot;;</span><br><span class="line">console.log(source.child.name);  //child</span><br><span class="line">console.log(target.child.name);  //target child</span><br></pre></td></tr></table></figure>
<h4 id="jQuery中的extend复制方法"><a href="#jQuery中的extend复制方法" class="headerlink" title="jQuery中的extend复制方法"></a>jQuery中的extend复制方法</h4><h3 id="自己实现深拷贝"><a href="#自己实现深拷贝" class="headerlink" title="自己实现深拷贝"></a>自己实现深拷贝</h3><ul>
<li>判断对象数据类型 Object.prototype.toString.call(obj);</li>
<li>若为Object则实现深拷贝</li>
<li>Array和Object 用遍历的方式深拷贝<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">//util作为判断变量具体类型的辅助模块</span><br><span class="line">   var util = (function()&#123;</span><br><span class="line">       var class2type = &#123;&#125;;</span><br><span class="line">       [&quot;Null&quot;,&quot;Undefined&quot;,&quot;Number&quot;,&quot;Boolean&quot;,&quot;String&quot;,&quot;Object&quot;,&quot;Function&quot;,&quot;Array&quot;,&quot;RegExp&quot;,&quot;Date&quot;].forEach(function(item)&#123;</span><br><span class="line">           class2type[&quot;[object &quot;+ item + &quot;]&quot;] = item.toLowerCase();</span><br><span class="line">       &#125;)</span><br><span class="line"> </span><br><span class="line">       function isType(obj, type)&#123;</span><br><span class="line">           return getType(obj) === type;</span><br><span class="line">       &#125;</span><br><span class="line">       function getType(obj)&#123;</span><br><span class="line">           return class2type[Object.prototype.toString.call(obj)] || &quot;object&quot;;</span><br><span class="line">       &#125;</span><br><span class="line">       return &#123;</span><br><span class="line">           isType:isType,</span><br><span class="line">           getType:getType</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;)();</span><br><span class="line"> </span><br><span class="line">   function copy(obj,deep)&#123;</span><br><span class="line">        //如果obj不是对象，那么直接返回值就可以了</span><br><span class="line">       if(obj === null || typeof obj !== &quot;object&quot;)&#123;</span><br><span class="line">           return obj;</span><br><span class="line">       &#125;</span><br><span class="line">　　　　//定义需要的局部变脸，根据obj的类型来调整target的类型</span><br><span class="line">       var i, target = util.isType(obj,&quot;array&quot;) ? [] : &#123;&#125;,value,valueType;</span><br><span class="line">       for(i in obj)&#123;</span><br><span class="line">           value = obj[i];</span><br><span class="line">           valueType = util.getType(value);</span><br><span class="line">　　　　　　　//只有在明确执行深复制，并且当前的value是数组或对象的情况下才执行递归复制</span><br><span class="line">           if(deep &amp;&amp; (valueType === &quot;array&quot; || valueType === &quot;object&quot;))&#123;</span><br><span class="line">               target[i] = copy(value);</span><br><span class="line">           &#125;else&#123;</span><br><span class="line">               target[i] = value;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       return target;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h2 id="new"><a href="#new" class="headerlink" title="new"></a>new</h2><h3 id="New一共做了几个操作步骤，要求具体说明"><a href="#New一共做了几个操作步骤，要求具体说明" class="headerlink" title="New一共做了几个操作步骤，要求具体说明"></a>New一共做了几个操作步骤，要求具体说明</h3><ol>
<li><p>创建空对象；<br>　　var obj = {};</p>
</li>
<li><p>设置新对象的constructor属性为构造函数的名称，设置新对象的<strong>proto</strong>属性指向构造函数的prototype对象；<br>　　obj.<strong>proto</strong> = ClassA.prototype;</p>
</li>
<li><p>使用新对象调用函数，函数中的this被指向新实例对象：<br>　　ClassA.call(obj);　　//{}.构造函数();          </p>
</li>
<li><p>将初始化完毕的新对象地址，保存到等号左边的变量中</p>
<h3 id="new一个对象-执行了什么过程？，那-return-‘-’，null-undefined会怎样？"><a href="#new一个对象-执行了什么过程？，那-return-‘-’，null-undefined会怎样？" class="headerlink" title="new一个对象 执行了什么过程？，那 return ‘ ’，null,undefined会怎样？"></a>new一个对象 执行了什么过程？，那 return ‘ ’，null,undefined会怎样？</h3></li>
</ol>
<hr>
<h2 id="如何判定js一个变量值的类型（至少3种）3"><a href="#如何判定js一个变量值的类型（至少3种）3" class="headerlink" title="如何判定js一个变量值的类型（至少3种）3%"></a>如何判定js一个变量值的类型（至少3种）3%</h2><p>Object.prototype.toString.call(obj)<br>[] instanceof Array<br>[].constructor === Object</p>
<hr>
<h2 id="数组和字符串的转换-3"><a href="#数组和字符串的转换-3" class="headerlink" title="数组和字符串的转换 3%"></a>数组和字符串的转换 3%</h2><p>split,join</p>
<hr>
<h2 id="arguments"><a href="#arguments" class="headerlink" title="arguments"></a>arguments</h2><h3 id="是啥？"><a href="#是啥？" class="headerlink" title="是啥？"></a>是啥？</h3><p>函数参数对象，不是数组，但是有length属性，也能arguments[0]取值</p>
<h3 id="转为数组？"><a href="#转为数组？" class="headerlink" title="转为数组？"></a>转为数组？</h3><ul>
<li>Array.prototype.slice.apply(arguments)这是运行效率比较快的方法</li>
<li>Array.prototype.concat.apply(thisArg,arguments)</li>
<li>Array.prototype.slice.call(arguments);<br>对象转为数组</li>
<li>Array.from(arguments) </li>
<li>[…arguments]<h3 id="arguments其他用法？"><a href="#arguments其他用法？" class="headerlink" title="arguments其他用法？"></a>arguments其他用法？</h3><h4 id="利用arguments-callee实现递归"><a href="#利用arguments-callee实现递归" class="headerlink" title="利用arguments.callee实现递归"></a>利用arguments.callee实现递归</h4></li>
</ul>
<hr>
<h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><h3 id="1-arguments-callee"><a href="#1-arguments-callee" class="headerlink" title="1.arguments.callee"></a>1.arguments.callee</h3><p>解决函数名递归带来的危险，arguments.callee指向正在执行的函数，使用它来代替函数名<br>arguments.callee是一个指向正在执行的函数的指针<br>好处：不用使用当前函数进行递归，性能变高<br>缺点：严格模式下不管用</p>
<h3 id="2-使用函数命名表达式"><a href="#2-使用函数命名表达式" class="headerlink" title="2.使用函数命名表达式"></a>2.使用函数命名表达式</h3><p>一个函数两个名字<br>有点：严格模式和非严格模式都适用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var factorial = （ function f(num)&#123;</span><br><span class="line">  return num * f(num-1)</span><br><span class="line">&#125;）</span><br></pre></td></tr></table></figure></p>
<h3 id="3-递归性能上的分析？优化？用es6优化？"><a href="#3-递归性能上的分析？优化？用es6优化？" class="headerlink" title="3.递归性能上的分析？优化？用es6优化？"></a>3.递归性能上的分析？优化？用es6优化？</h3><p>递归非常耗费内存，因为需要同时保存成千上百个调用帧，很容易发生“栈溢出”错误（stack overflow）</p>
<h4 id="使用尾调递归优化递归"><a href="#使用尾调递归优化递归" class="headerlink" title="使用尾调递归优化递归"></a>使用尾调递归优化递归</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function factorial(n) &#123;</span><br><span class="line">  if (n === 1) return 1;</span><br><span class="line">  return n * factorial(n - 1);</span><br><span class="line">&#125;</span><br><span class="line">factorial(5) // 120</span><br></pre></td></tr></table></figure>
<p>比正常递归函数多了一个参数total<br>尾递归，只保留一个调用记录，复杂度 O(1)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function factorial(n, total) &#123;</span><br><span class="line">  if (n === 1) return total;</span><br><span class="line">  return factorial(n - 1, n * total);</span><br><span class="line">&#125;</span><br><span class="line">factorial(5, 1) // 120</span><br></pre></td></tr></table></figure></p>
<h4 id="ES6尾调用"><a href="#ES6尾调用" class="headerlink" title="ES6尾调用"></a>ES6尾调用</h4><p>ES6 的尾调用优化只在严格模式下开启，正常模式是无效的。<br>这是因为在正常模式下，函数内部有两个变量，可以跟踪函数的调用栈。<br>func.arguments：返回调用时函数的参数。<br>func.caller：返回调用当前函数的那个函数。<br>尾调用优化发生时，函数的调用栈会改写，因此上面两个变量就会失真。严格模式禁用这两个变量，所以尾调用模式仅在严格模式下生效。</p>
<hr>
<h2 id="字符串和json的转换3"><a href="#字符串和json的转换3" class="headerlink" title="字符串和json的转换3%"></a>字符串和json的转换3%</h2><p>JSON.stringify( );<br>JSON.parse（）</p>
<h2 id="eval"><a href="#eval" class="headerlink" title="eval()"></a>eval()</h2><p>eval() 函数可计算某个字符串，并执行其中的的 JavaScript 代码。<br>eval(“alert(‘Hello world’)”)<br>eval(“x=10;y=20;document.write(x*y)”)</p>
<h2 id="typeof-输出"><a href="#typeof-输出" class="headerlink" title="typeof 输出"></a>typeof 输出</h2><p>typeof(的)运算数未定义,返回(的)就是 “undefined”.<br>typeof(undifiend)//undifiend</p>
<p>运算数为数字 typeof(x) = “number”<br>字符串 typeof(x) = “string”<br>布尔值 typeof(x) = “boolean”<br>对象,数组和null typeof(x) = “object”<br>函数 typeof(x) = “function”<br>        typeof(‘aa’+4);//string<br>       typeof(‘1’+undifiend);//报错</p>
<hr>
<h2 id="链式调用"><a href="#链式调用" class="headerlink" title="链式调用"></a>链式调用</h2><p>所谓链式调用就是能够返回自身对象<br>$(‘#id’).show().hide().show().hide().show().hide();<br>有点：代码简洁易读，减少了多次重复使用同一个变量</p>
<h3 id="1-方法中直接-return-this"><a href="#1-方法中直接-return-this" class="headerlink" title="1.方法中直接 return this"></a>1.方法中直接 return this</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">   function ClassA()&#123;</span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line">    ClassA.prototype = &#123;</span><br><span class="line">        hide:function()&#123;</span><br><span class="line">            console.log(&apos;hide&apos;);</span><br><span class="line">            return this;</span><br><span class="line">        &#125;,</span><br><span class="line">    getName:function(callback)&#123;</span><br><span class="line">         if(callback)&#123;</span><br><span class="line">            callback.call(this,this.name);</span><br><span class="line">         &#125;</span><br><span class="line">        return this;</span><br><span class="line">      &#125;,</span><br><span class="line">        show:function()&#123;</span><br><span class="line">            console.log(&apos;show&apos;);</span><br><span class="line">            return this;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">var a = new ClassA();</span><br><span class="line">a.show().hide().show().hide().show();</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h2><h2 id="如何解决ajax跨域"><a href="#如何解决ajax跨域" class="headerlink" title="如何解决ajax跨域"></a>如何解决ajax跨域</h2><h3 id="1-CROS方式（跨域资源共享）"><a href="#1-CROS方式（跨域资源共享）" class="headerlink" title="1.CROS方式（跨域资源共享）"></a>1.CROS方式（跨域资源共享）</h3><p> 原理 ：配置的两大基本信息,Origin和headers<br>第一步:配置Php 后台允许跨域<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">header(&apos;Access-Control-Allow-Origin: *&apos;);</span><br><span class="line">header(&apos;Access-Control-Allow-Headers: Origin, X-Requested-With, Content-Type, Accept&apos;);</span><br><span class="line">//主要为跨域CORS配置的两大基本信息,Origin和headers</span><br></pre></td></tr></table></figure></p>
<p>第二步:配置Apache web服务器跨域(httpd.conf中)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;Directory /&gt;</span><br><span class="line">   //AllowOverride none</span><br><span class="line">    //Require all denied</span><br><span class="line">    Options FollowSymLinks</span><br><span class="line">    AllowOverride none</span><br><span class="line">    Order deny,allow</span><br><span class="line">    Allow from all</span><br><span class="line">&lt;/Directory&gt;</span><br></pre></td></tr></table></figure></p>
<hr>
<h3 id="2-JSONP方式"><a href="#2-JSONP方式" class="headerlink" title="2.JSONP方式"></a>2.JSONP方式</h3><p>jsonp解决跨域问题是一个比较古老的方案(实际中不推荐使用),这里做简单介绍(实际项目中如果要使用JSONP,一般会使用JQ等对JSONP进行了封装的类库来进行ajax请求)</p>
<p>实现原理</p>
<p>JSONP之所以能够用来解决跨域方案,主要是因为 <script> 脚本拥有跨域能力,而JSONP正是利用这一点来实现。具体原理如图<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">function addScriptTag(src) &#123;</span><br><span class="line">  var script = document.createElement(&apos;script&apos;);</span><br><span class="line">  script.setAttribute(&quot;type&quot;,&quot;text/javascript&quot;);</span><br><span class="line">  script.src = src;</span><br><span class="line">  document.body.appendChild(script);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">window.onload = function () &#123;</span><br><span class="line">  addScriptTag(&apos;http://example.com/ip?callback=foo&apos;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function foo(data) &#123;</span><br><span class="line">  console.log(&apos;response data: &apos; + JSON.stringify(data));</span><br><span class="line">&#125;;</span><br><span class="line">服务端对应的接口在返回参数外面添加函数包裹层</span><br><span class="line">foo(&#123;</span><br><span class="line">  &quot;test&quot;: &quot;testData&quot;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<h4 id="jsonp的弊端"><a href="#jsonp的弊端" class="headerlink" title="jsonp的弊端"></a>jsonp的弊端</h4><p>JSONP只支持GET请求，CORS支持所有类型的HTTP请求。JSONP的优势在于支持老式浏览器，以及可以向不支持CORS的网站请求数据。</p>
<h2 id="请求代理进行跨域nginx"><a href="#请求代理进行跨域nginx" class="headerlink" title="请求代理进行跨域nginx"></a>请求代理进行跨域nginx</h2><hr>
<p>如何解决ajax跨域</p>
<p>一般ajax跨域解决就是通过JSONP解决或者CORS解决,如以下:(注意，现在已经几乎不会再使用JSONP了，所以JSONP了解下即可)</p>
<h2 id="其他跨域"><a href="#其他跨域" class="headerlink" title="其他跨域"></a>其他跨域</h2><p>2:通过修改document.domain来跨子域<br>仅在相同主域下才有效，且window.domain需要设置为相同的父域 不同的框架之间是可以获取window对象的，但却无法获取相应的属性和方法。<br>比如，有一个页面，它的地址是<a href="http://www.example.com/a.html">http://www.example.com/a.html</a> ，<br>在这个页面里面有一个iframe，它的src是<a href="http://example.com/b.html">http://example.com/b.html</a>,<br>很显然，这个页面与它里面的iframe框架是不同域的，所以我们是无法通过在页面中书写js代码来获取iframe中的东西的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">    function test()&#123;</span><br><span class="line">        var iframe = document.getElementById(&apos;iframe&apos;);</span><br><span class="line">        var win = document.contentWindow;//可以获取到iframe里的window对象，但该window对象的属性和方法几乎是不可用的</span><br><span class="line">        var doc = win.document;//这里获取不到iframe里的document对象</span><br><span class="line">        var name = win.name;//这里同样获取不到window对象的name属性</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;iframe id = &quot;iframe&quot; src=&quot;http://example.com/b.html&quot; onload = &quot;test()&quot;&gt;&lt;/iframe&gt;</span><br></pre></td></tr></table></figure></p>
<p><img src="http://upload-images.jianshu.io/upload_images/2377897-b81be614658808c3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"><br>3:</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2377897-d51bad8105ff7116.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"><br>4：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2377897-665a15e11ea92788.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"><br>5：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2377897-2e14787d1c2eae05.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<hr>
<h2 id="if-false-的几种情况"><a href="#if-false-的几种情况" class="headerlink" title="if() false 的几种情况"></a>if() false 的几种情况</h2><ul>
<li>if(false)</li>
<li>if(null)</li>
<li>if(undefined)</li>
<li>if(‘’)</li>
<li>if(NaN)-数字NaN</li>
<li>if(0)-数字0</li>
</ul>
<hr>
<h2 id="Ajax实现流程"><a href="#Ajax实现流程" class="headerlink" title="Ajax实现流程"></a>Ajax实现流程</h2><p>创建一个XMLHttpRequest()实例<br>准备一个Ajax请求以待发送<br>发送Ajax请求<br>根据服务器响应的结果，将相应数据填充到xhr对象的属性中 注意url是相对于执行代码的当前页面，也可以是绝对路径。</p>
<p>var xhr = new XMLHttpRequest();<br>xhr.open(Type,URL,Boolean);<br>//请求类型，请求地址，是否异步<br>xhr.send(null);<br>xhr.onreadystatechange = function(){<br>    if(xhr.readyState == 4){<br>        if(xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300 || xhr.status == 304){<br>            alert(xhr.responseText);<br>        }else {<br>            alert(‘unsuccessful ‘ + xhr.status);<br>        }<br>    }<br>};</p>
<hr>
<h2 id="单线程"><a href="#单线程" class="headerlink" title="单线程"></a>单线程</h2><p>为什么javascrip是单线程<br>JavaScript的单线程，与它的用途有关。作为浏览器脚本语言，JavaScript的主要用途是与用户互动，以及操作DOM。这决定了它只能是单线程，否则会带来很复杂的同步问题。<br>浏览器端多线程<br>js<br>css<br>事件<br>数据交互</p>
<hr>
<h2 id="垃圾回收-1"><a href="#垃圾回收-1" class="headerlink" title="垃圾回收"></a>垃圾回收</h2><p>垃圾收集器必须跟踪哪个变量有用哪个变量没用，对于不再有用的变量打上标记，以备将来收回其占用的内存，内存泄露和浏览器实现的垃圾回收机制息息相关， 而浏览器实现标识无用变量的策略主要有下两个方法：<br>第一，引用计数法<br>跟踪记录每个值被引用的次数。当声明一个变量并将引用类型的值赋给该变量时，则这个值的引用次数就是1。如果同一个值又被赋给另一个变量，则该值的引用次 数加1.相反，如果包含对这个值引用的变量又取得另外一个值，则这个值的引用次数减1.当这个值的引用次数变成0时，则说明没有办法访问这个值了，因此就 可以将其占用的内存空间回收回来。</p>
<p>如： var a = {};     //对象{}的引用计数为1<br>     b = a;          //对象{}的引用计数为 1+1<br>     a = null;       //对象{}的引用计数为2-1<br>所以这时对象{}不会被回收;<br>IE 6, 7 对DOM对象进行引用计数回收， 这样简单的垃圾回收机制，非常容易出现循环引用问题导致内存不能被回收， 进行导致内存泄露等问题，一般不用引用计数法。<br>第二，标记清除法<br>到2008年为止，IE,Firefox,Opera,Chrome和Safari的javascript实现使用的都是标记清除式的垃圾收集策略（或类似的策略），只不过垃圾收集的时间间隔互有不同。<br>标记清除的算法分为两个阶段，标记(mark)和清除(sweep). 第一阶段从引用根节点开始标记所有被引用的对象，第二阶段遍历整个堆，把未标记的对象清除。</p>
<hr>
<h2 id="javascript创建对象的几种方式？"><a href="#javascript创建对象的几种方式？" class="headerlink" title="javascript创建对象的几种方式？"></a>javascript创建对象的几种方式？</h2><p> javascript创建对象简单的说,无非就是使用内置对象或各种自定义对象，当然还可以用JSON；但写法有很多种，也能混合使用。</p>
<p> 1、对象字面量的方式</p>
<pre><code>person={firstname:&quot;Mark&quot;,lastname:&quot;Yun&quot;,age:25,eyecolor:&quot;black&quot;};
</code></pre><p> 2、用function来模拟无参的构造函数</p>
<pre><code>function Person(){}
var person=new Person();//定义一个function，如果使用new&quot;实例化&quot;,该function可以看作是一个Class
person.name=&quot;Mark&quot;;
person.age=&quot;25&quot;;
person.work=function(){
alert(person.name+&quot; hello...&quot;);
}
person.work();
</code></pre><p> 3、用function来模拟参构造函数来实现（用this关键字定义构造的上下文属性）</p>
<pre><code>function Pet(name,age,hobby){
   this.name=name;//this作用域：当前对象
   this.age=age;
   this.hobby=hobby;
   this.eat=function(){
      alert(&quot;我叫&quot;+this.name+&quot;,我喜欢&quot;+this.hobby+&quot;,是个程序员&quot;);
   }
}
var maidou =new Pet(&quot;麦兜&quot;,25,&quot;coding&quot;);//实例化、创建对象
maidou.eat();//调用eat方法
</code></pre><p> 4、用工厂方式来创建（内置对象）</p>
<pre><code>var wcDog =new Object();
wcDog.name=&quot;旺财&quot;;
wcDog.age=3;
wcDog.work=function(){
  alert(&quot;我是&quot;+wcDog.name+&quot;,汪汪汪......&quot;);
}
wcDog.work();
</code></pre><p> 5、用原型方式来创建</p>
<pre><code>function Dog(){

 }
 Dog.prototype.name=&quot;旺财&quot;;
 Dog.prototype.eat=function(){
 alert(this.name+&quot;是个吃货&quot;);
 }
 var wangcai =new Dog();
 wangcai.eat();
</code></pre><p> 5、用混合方式来创建</p>
<pre><code>function Car(name,price){
  this.name=name;
  this.price=price;
}
 Car.prototype.sell=function(){
   alert(&quot;我是&quot;+this.name+&quot;，我现在卖&quot;+this.price+&quot;万元&quot;);
  }
var camry =new Car(&quot;凯美瑞&quot;,27);
camry.sell();
</code></pre><hr>
<h2 id="JavaScript有几种类型的值？，你能画一下他们的内存图吗？"><a href="#JavaScript有几种类型的值？，你能画一下他们的内存图吗？" class="headerlink" title="JavaScript有几种类型的值？，你能画一下他们的内存图吗？"></a>JavaScript有几种类型的值？，你能画一下他们的内存图吗？</h2><p> 栈：原始数据类型（Undefined，Null，Boolean，Number、String）<br> 堆：引用数据类型（对象、数组和函数）</p>
<p> 两种类型的区别是：存储位置不同；<br> 原始数据类型直接存储在栈(stack)中的简单数据段，占据空间小、大小固定，属于被频繁使用数据，所以放入栈中存储；<br> 引用数据类型存储在堆(heap)中的对象,占据空间大、大小不固定。如果存储在栈中，将会影响程序运行的性能；引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2377897-f0c90cfaba1aabac.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<hr>
<h2 id="说几条写JavaScript的基本规范？"><a href="#说几条写JavaScript的基本规范？" class="headerlink" title="说几条写JavaScript的基本规范？"></a>说几条写JavaScript的基本规范？</h2><p> 1.不要在同一行声明多个变量。<br> 2.请使用 ===/!==来比较true/false或者数值<br> 3.使用对象字面量替代new Array这种形式<br> 4.不要使用全局函数。<br> 5.Switch语句必须带有default分支<br> 6.函数不应该有时候有返回值，有时候没有返回值。<br> 7.For循环必须使用大括号<br> 8.If语句必须使用大括号<br> 9.for-in循环中的变量 应该使用var关键字明确限定作用域，从而避免作用域污染。</p>
<hr>
<h1 id="Node-amp-Express"><a href="#Node-amp-Express" class="headerlink" title="Node&amp;Express"></a>Node&amp;Express</h1><ul>
<li>基于node的其他web开发框架</li>
<li>node 有关的知识点</li>
</ul>
<hr>
<h2 id="express"><a href="#express" class="headerlink" title="express"></a>express</h2><p>Express 是一个基于 Node的极简灵活的web 应用开发框架。Express是在Node之上扩展了 Web 应用所需的基本功能。<br>Express完全是由中间件构成一个的 web 开发框架：从本质上来说，一个 Express 应用就是在调用各种中间件。</p>
<h3 id="中间件含义"><a href="#中间件含义" class="headerlink" title="中间件含义"></a>中间件含义</h3><p>是一个函数或功能，（err,res,rep,next），是封装在程序中处理请求的功能。后台的请求分为一部分一部分，每一部分都有中间件来完成,之道响应完毕</p>
<h3 id="Express-几种中间件："><a href="#Express-几种中间件：" class="headerlink" title="Express 几种中间件："></a>Express 几种中间件：</h3><p>应用级中间件<br>绑定到app 对象使用 app.use()和 app.METHOD()， 其中， METHOD 是需要处理的 HTTP 请求的方法，例如 GET, PUT, POST 等等</p>
<p>路由级中间件<br>绑定的对象为 express.Router()。路由级使用 router.use() 加载</p>
<p>错误处理中间件<br>4 个参数，而不是 3 个，其签名如下： (err, req, res, next)。</p>
<p>内置的中间件<br>express.static是 Express 唯一内置的中间件。负责在 Express 应用中托管静态资源。</p>
<p>第三方中间件<br>例如 cookie-parser</p>
<hr>
<h1 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h1><p> 对前端安全有什么看法？<br>是否了解Web注入攻击，说下原理，最常见的两种攻击（XSS 和 CSRF）了解到什么程度？</p>
<p>1, XSS(cross-site scripting跨域脚本攻击)是一种经常出现在web应用中的计算机安全漏洞，它允许恶意web用户将代码植入到提供给其它用户使用的页面中。 其实在web前端方面，可以简单的理解为一种javascript代码注入。 解决方法：将前端输出数据都进行转义（$lt,$gt）</p>
<p>2, CSRF（cross-site request forgery），翻译为跨站请求伪造，与XSS非常相似，但XSS是利用用户对当前网站的信任来发起攻击，而CSRF是利用网站对用户的信任来发起攻击(即模拟请求攻击)。</p>
<p>对于CSRF攻击，我们所能做的可以有：</p>
<p>检查报头中的Referer参数确保请求发自正确的网站（但XHR请求可调用setRequestHeader方法来修改Referer报头）；<br>对于任何重要的请求都需要重新验证用户的身份；<br>创建一个唯一的令牌（Token），将其存在服务端的session中及客户端的cookie中，对任何请求，都检查二者是否一致。</p>
<hr>
<h1 id="网络部分"><a href="#网络部分" class="headerlink" title="网络部分"></a>网络部分</h1><h2 id="一个页面从输入-URL-到页面加载显示完成，这个过程中都发生了什么？（流程说的越详细越好）"><a href="#一个页面从输入-URL-到页面加载显示完成，这个过程中都发生了什么？（流程说的越详细越好）" class="headerlink" title="一个页面从输入 URL 到页面加载显示完成，这个过程中都发生了什么？（流程说的越详细越好）"></a>一个页面从输入 URL 到页面加载显示完成，这个过程中都发生了什么？（流程说的越详细越好）</h2><p> 详细版：<br>      1、浏览器会开启一个线程来处理这个请求，对 URL 分析判断如果是 http 协议就按照 Web 方式来处理;<br>      2、调用浏览器内核中的对应方法，比如 WebView 中的 loadUrl 方法;<br>      3、通过DNS解析获取网址的IP地址，设置 UA 等信息发出第二个GET请求;<br>      4、进行HTTP协议会话，客户端发送报头(请求报头);<br>      5、进入到web服务器上的 Web Server，如 Apache、Tomcat、Node.JS 等服务器;<br>      6、进入部署好的后端应用，如 PHP、Java、JavaScript、Python 等，找到对应的请求处理;<br>      7、处理结束回馈报头，此处如果浏览器访问过，缓存上有对应资源，会与服务器最后修改时间对比，一致则返回304;<br>      8、浏览器开始下载html文档(响应报头，状态码200)，同时使用缓存;<br>      9、文档树建立，根据标记请求所需指定MIME类型的文件（比如css、js）,同时设置了cookie;<br>      10、页面开始渲染DOM，JS根据DOM API操作DOM,执行事件绑定等，页面显示完成。</p>
<pre><code>简洁版：
  浏览器根据请求的URL交给DNS域名解析，找到真实IP，向服务器发起请求；
  服务器交给后台处理完成后返回数据，浏览器接收文件（HTML、JS、CSS、图象等）；
  浏览器对加载到的资源（HTML、JS、CSS等）进行语法解析，建立相应的内部数据结构（如HTML的DOM）；
  载入解析到的资源文件，渲染页面，完成。
</code></pre><hr>
<h2 id="页面渲染流程主要分三部分"><a href="#页面渲染流程主要分三部分" class="headerlink" title="页面渲染流程主要分三部分"></a>页面渲染流程主要分三部分</h2><p>HTML文档解析生成DOM树<br>DOM树构建完到Webkit绘制上下文<br>上下文到最终生成的图像 (JavaScript省略为JS)<br>当用户输入URL时候，WebKit调用其资源加载器加载该URL对应的网页。<br>加载器依赖网络模块建立连接，发送请求并接受答复。<br>WebKit收到各种网页或资源的数据，可能是同步或者是异步获取的。<br>网页被交给HTML解释器转换成一系列词语(Token)。<br>解释器根据词语构建节点(Node)，形成DOM树。<br>如果节点是JS，调用JS引擎解释并执行。<br>JS代码修改DOM树的结构<br>如果节点需要依赖其他资源，如图片、css等，调用资源加载器来加载他们，但他们是异步的，不会阻碍当前DOM树的继续构建，如果是JS资源URL(未标记异步)，则需要停止当前DOM数的构建，直到JS引擎执行后才继续构建DOM树。 至此会触发两个事件，一个时DOMConent表示DOM构建完全(和jQuery的$(function(){})()一样),后者是 onload 事件，表示DOM树所依赖的各种图片、css等资源加载完毕，通常这两个事件不是同时发生。<br>接下来是利用CSS和DOM树构建RenderObject树直到绘图上下文。</p>
<p>CSS文件被CSS解释器解释成表示结构。<br>CSS解释器完成工作之后，在DOM树上附加解释后的样式信息，包括布局计算，这就是RenderObject树。<br>RenderObject节点在创建的同时，WebKit会根据网页的层次结构创建RenderLayer树，同时构建一个虚拟的绘图上下文。<br>实际上，DOM树，RenderObject树，RenderLayer树和绘图上下文在关闭浏览器前并不会被销毁。</p>
<p>最后，根据绘图上下文生成最终图像，主要依赖2D和3D图形库。</p>
<p>绘图上下文将每个绘图操作桥接到不同的具体实现类，也就是绘图具体实现类，绘图实现类将2D图形库或者3D图形库绘制的结果保存下来，交给浏览器来显示。</p>
<h2 id="浏览器接收到服务器文件（HTML、JS、CSS、图象等），开始加载资源，对于加载到的资源进行以下操作："><a href="#浏览器接收到服务器文件（HTML、JS、CSS、图象等），开始加载资源，对于加载到的资源进行以下操作：" class="headerlink" title="浏览器接收到服务器文件（HTML、JS、CSS、图象等），开始加载资源，对于加载到的资源进行以下操作："></a>浏览器接收到服务器文件（HTML、JS、CSS、图象等），开始加载资源，对于加载到的资源进行以下操作：</h2><ul>
<li>浏览器解析<ul>
<li>解析html形成 Dom Tree</li>
<li>解析 css 形成 Css Rule Tree</li>
<li>Js通过  DOM API和CSSOM API来操作DOM Tree和CSS Rule Tree</li>
</ul>
</li>
<li>构建Render Tree<ul>
<li>浏览器引擎用Dom Tree 和 Css Rule Tree 构建 Render Tree<ul>
<li>Css Rule Tree对比DOM生成Style Context Tree</li>
</ul>
</li>
</ul>
</li>
<li>绘制网页</li>
</ul>
<hr>
<h2 id="网络有几层，每层有哪些协议"><a href="#网络有几层，每层有哪些协议" class="headerlink" title="网络有几层，每层有哪些协议"></a>网络有几层，每层有哪些协议</h2><ul>
<li>OSI分层（7层）：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层。</li>
<li>TCP/IP分层（4层）：网络接口层、网际层、运输层、应用层。</li>
<li>五层协议（5层）：物理层、数据链路层、网络层、运输层、应用层。<br>tcp,udp在运输层<br>http,ftp 在应用层<br>ip在网络层<h2 id="UDP-TCP-的区别，什么时候用哪个-哪个是可靠的？"><a href="#UDP-TCP-的区别，什么时候用哪个-哪个是可靠的？" class="headerlink" title="UDP TCP 的区别，什么时候用哪个,哪个是可靠的？"></a>UDP TCP 的区别，什么时候用哪个,哪个是可靠的？</h2></li>
<li>1、TCP面向连接;UDP是无连接的，即发送数据之前不需要建立连接</li>
<li>2、TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达（ack）;UDP尽最大努力交付，即不保证可靠交付</li>
<li>3、TCP面向字节流，实际上是TCP把数据看成一连串无结构的字节流;UDP是面向报文的<br>UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如IP电话，实时视频会议等）</li>
<li>4、每一条TCP连接只能是点到点的;UDP支持一对一，一对多，多对一和多对多的交互通信</li>
<li>5、TCP首部开销20字节;UDP的首部开销小，只有8个字节</li>
<li>6、TCP的逻辑通信信道是全双工的可靠信道，UDP则是不可靠信道</li>
</ul>
<h2 id="http-中get和post的区别"><a href="#http-中get和post的区别" class="headerlink" title="http 中get和post的区别"></a>http 中get和post的区别</h2><ul>
<li>GET：一般用来获取数据  ，POST：一般用来修改数据</li>
<li>发送值：<br>　<em> geturl参数可见。
　</em> post是通过HTTP post机制，将数据放到 头传过去</li>
<li>长度限制：<ul>
<li>大部分浏览器对GET url有长度限制2k</li>
<li>post传送的数据量较大，一般被默认为不受限制。80KB-100KB。</li>
</ul>
</li>
<li>缓存:<ul>
<li>GET 请求默认在ajax环境下是会被缓存的 ，这样就会减轻服务器端的压力。<ul>
<li>但是post请求是不会被缓存的。</li>
</ul>
</li>
</ul>
</li>
<li>GET/POST使用场景有区别<ul>
<li>用get:<br>请求中的URL可以被手动输入<br>请求中的URL可以被存在书签里，或者历史里，或者快速拨号里面，或者分享给别人。<br>请求中的URL可以被缓存。GET 请求默认在ajax环境下是会被缓存的 ，这样就会减轻服务器端的压力。但是post请求是不会被缓存的。<br> 用GET： 可以重复的交互，比如取个数据，跳个页面</li>
<li>post:<br>表单数据，数据库内添加新的数据行，用POST, 因为POST不能被缓存，所以浏览器不会多次提交。</li>
</ul>
</li>
<li>延伸<br>http:get 获取数据 post:修改数据 put:增加数据 delete：删除数据<h2 id="为什么get方式有限制是2kb-，出于什么原因？"><a href="#为什么get方式有限制是2kb-，出于什么原因？" class="headerlink" title="为什么get方式有限制是2kb.，出于什么原因？"></a>为什么get方式有限制是2kb.，出于什么原因？</h2></li>
<li>不同<strong>的</strong>浏览器对于URL是有限制<strong>的</strong>，比如IE浏览器对于URL<strong>的</strong>限制为<strong>2KB</strong>，而Chrome，FireFox浏览器理论上对于URL是没有限制<strong>的</strong>，它真正<strong>的</strong>限制取决于操作系统本身</li>
<li>服务器最多处理64K大小的url。超过的部分，恕不处理。<h2 id="知道post请求发几个包？，知道某个名词吗"><a href="#知道post请求发几个包？，知道某个名词吗" class="headerlink" title="知道post请求发几个包？，知道某个名词吗?"></a>知道post请求发几个包？，知道某个名词吗?</h2>GET和POST还有一个重大区别是：GET产生一个TCP数据包，而POST产生两个TCP数据包(但又不是绝对)</li>
<li><p>1、对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200(返回数据);</p>
</li>
<li><p>2、而对于POST，浏览器先发送header，服务器响应100(客户端应当继续发送请求) continue，浏览器再发送data，服务器响应200 ok(返回数据)。</p>
</li>
<li><p>3、也就是说，GET只需要汽车跑一趟就把货送到了，而POST得跑两趟，第一趟，先去和服务器打个招呼“嗨，我等下要送一批货来，你们打开门迎接我”，然后再回头把货送过去。</p>
</li>
<li>4、因为POST需要两步，时间上消耗的要多一点，看起来GET比POST更有效。因此Yahoo团队有推荐用GET替换POST来优化网站性能。但这是一个坑!跳入需谨慎。为什么?</li>
<li>6、 据研究，在网络环境好的情况下，发一次包的时间和发两次包的时间差别基本可以无视。而在网络环境差的情况下，两次包的TCP在验证数据包完整性上，有非常大的优点。</li>
<li>7、但并不是所有浏览器都会在POST中发送两次包，Firefox就只发送一次。<h2 id="握手挥手"><a href="#握手挥手" class="headerlink" title="握手挥手"></a>握手挥手</h2><h3 id="握手"><a href="#握手" class="headerlink" title="握手"></a>握手</h3>三次握手过程：<br>客户端向服务器发送一个SYN（包含了SYN，SEQ）。<br>当服务器会向客户端发送一个SYN+ACK的数据包<br>当客户端向服务器发送ACK的数据包，此时ACK数据包中的ack值等于上一次SYN中的seq+syn。<br>如果某个阶段莫名中断，TCP会再次以相同的顺序发送相同的数据包。<h4 id="三次握手的目的："><a href="#三次握手的目的：" class="headerlink" title="三次握手的目的："></a>三次握手的目的：</h4>防止已过期的连接请求报文突然又传送到服务器，因而产生错误。<h3 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h3>第一次挥手：主动关闭方A发送一个FIN，用来A到被动关闭方B对的数据传送，也就是A不再给B发数据了，但是A还可以接收数据</li>
</ul>
<p>第二次挥手：B收到FIN包后，发一个ACK给对方，确认序号为收到序号+1。（一个FIN占用一个序号）</p>
<p>第三次挥手：B发送一个FIN，用来关闭B到A的数据传送</p>
<p>第四次挥手：A收到FIN后，发送一个ACK给B，确认序号为收到序号+1。完成四次挥手。</p>
<h2 id="为什么挥手比握手多了一个次？"><a href="#为什么挥手比握手多了一个次？" class="headerlink" title="为什么挥手比握手多了一个次？"></a>为什么挥手比握手多了一个次？</h2><p>但关闭连接时，当收到对方的FIN报文通知时，它仅仅表示对方没有数据发送给你了；但未必你所有的数据都全部发送给对方了，所以它这里的ACK报文和FIN报文分开发送的。</p>
<h2 id="http的缓存机制（cookie）"><a href="#http的缓存机制（cookie）" class="headerlink" title="http的缓存机制（cookie）"></a>http的缓存机制（cookie）</h2><p><a href="http://www.jianshu.com/p/0c31b58dbccb">http://www.jianshu.com/p/0c31b58dbccb</a><br><a href="https://segmentfault.com/a/1190000010775131">https://segmentfault.com/a/1190000010775131</a></p>
<p><img src="http://upload-images.jianshu.io/upload_images/2377897-3e3258c0ab144bfd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/2377897-870aaa08f5c962a7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<hr>
<h2 id="http请求是有状态的嘛？websocket区别"><a href="#http请求是有状态的嘛？websocket区别" class="headerlink" title="http请求是有状态的嘛？websocket区别"></a>http请求是有状态的嘛？websocket区别</h2><h3 id="http"><a href="#http" class="headerlink" title="http"></a>http</h3><ul>
<li>http基于tcp</li>
<li>http为非状态协议，每次发送数据都要重新请求连接</li>
<li>被动性：服务器不能主动发送请求，只能等待响应<h3 id="websocket"><a href="#websocket" class="headerlink" title="websocket"></a>websocket</h3><ul>
<li>基于tcp,为了实现实时 通信而产生的。</li>
<li>特点：<ul>
<li>服务器可以主动发送请求</li>
<li>节约带宽</li>
<li>持久连接<h2 id="Http与https"><a href="#Http与https" class="headerlink" title="Http与https"></a>Http与https</h2>HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全。<br>HTTPS和HTTP的区别主要如下：</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>　　1、https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用。</p>
<p>　　2、http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。</p>
<p>　　3、http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。</p>
<p>　　4、http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。</p>
<hr>
<h2 id="HTTP请求报文与响应报文格式"><a href="#HTTP请求报文与响应报文格式" class="headerlink" title="HTTP请求报文与响应报文格式"></a>HTTP请求报文与响应报文格式</h2><h3 id="请求报文包含三部分："><a href="#请求报文包含三部分：" class="headerlink" title="请求报文包含三部分："></a>请求报文包含三部分：</h3><p>a、请求行：包含请求方法、URI、HTTP版本信息<br>b、请求首部字段<br>c、请求内容实体</p>
<h3 id="响应报文包含三部分："><a href="#响应报文包含三部分：" class="headerlink" title="响应报文包含三部分："></a>响应报文包含三部分：</h3><p>a、状态行：包含HTTP版本、状态码、状态码的原因短语<br>b、响应首部字段<br>c、响应内容实体</p>
<hr>
<h2 id="常见HTTP首部字段"><a href="#常见HTTP首部字段" class="headerlink" title="常见HTTP首部字段"></a>常见HTTP首部字段</h2><p>###　a、通用首部字段（请求报文与响应报文都会使用的首部字段）<br>Date：创建报文时间<br>Connection：连接的管理<br>Cache-Control：缓存的控制<br>Transfer-Encoding：报文主体的传输编码方式</p>
<h3 id="b、请求首部字段（请求报文会使用的首部字段）"><a href="#b、请求首部字段（请求报文会使用的首部字段）" class="headerlink" title="b、请求首部字段（请求报文会使用的首部字段）"></a>b、请求首部字段（请求报文会使用的首部字段）</h3><p>Host：请求资源所在服务器<br>Accept：可处理的媒体类型<br>Accept-Charset：可接收的字符集<br>Accept-Encoding：可接受的内容编码<br>Accept-Language：可接受的自然语言</p>
<h3 id="c、响应首部字段（响应报文会使用的首部字段）"><a href="#c、响应首部字段（响应报文会使用的首部字段）" class="headerlink" title="c、响应首部字段（响应报文会使用的首部字段）"></a>c、响应首部字段（响应报文会使用的首部字段）</h3><p>Accept-Ranges：可接受的字节范围<br>Location：令客户端重新定向到的URI<br>Server：HTTP服务器的安装信息</p>
<h3 id="d、实体首部字段（请求报文与响应报文的的实体部分使用的首部字段）"><a href="#d、实体首部字段（请求报文与响应报文的的实体部分使用的首部字段）" class="headerlink" title="d、实体首部字段（请求报文与响应报文的的实体部分使用的首部字段）"></a>d、实体首部字段（请求报文与响应报文的的实体部分使用的首部字段）</h3><p>Allow：资源可支持的HTTP方法<br>Content-Type：实体主类的类型<br>Content-Encoding：实体主体适用的编码方式<br>Content-Language：实体主体的自然语言<br>Content-Length：实体主体的的字节数<br>Content-Range：实体主体的位置范围，一般用于发出部分请求时使用</p>
<hr>
<h3 id="Http状态码-常用的"><a href="#Http状态码-常用的" class="headerlink" title="Http状态码 常用的"></a>Http状态码 常用的</h3><p>成功的状态码：<br>200 – 服务器成功返回网页<br>304 – 未修改<br>失败的状态码：<br>404 – 请求的网页不存在<br>503 – 服务器暂时不可用<br>500 – 服务器内部错误  </p>
<h2 id="http状态码有那些？分别代表是什么意思？"><a href="#http状态码有那些？分别代表是什么意思？" class="headerlink" title="http状态码有那些？分别代表是什么意思？"></a>http状态码有那些？分别代表是什么意思？</h2><h3 id="简单版"><a href="#简单版" class="headerlink" title="简单版"></a>简单版</h3><pre><code>[
    100  Continue    继续，一般在发送post请求时，已发送了http header之后服务端将返回此信息，表示确认，之后发送具体参数信息
    200  OK         正常返回信息
    201  Created      请求成功并且服务器创建了新的资源
    202  Accepted     服务器已接受请求，但尚未处理
    301  Moved Permanently  请求的网页已永久移动到新位置。
    302 Found          临时性重定向。
    303 See Other      临时性重定向，且总是使用 GET 请求新的 URI。
    304  Not Modified 自从上次请求后，请求的网页未修改过。

    400 Bad Request  服务器无法理解请求的格式，客户端不应当尝试再次使用相同的内容发起请求。
    401 Unauthorized 请求未授权。
    403 Forbidden      禁止访问。
    404 Not Found      找不到如何与 URI 相匹配的资源。

    500 Internal Server Error  最常见的服务器端错误。
    503 Service Unavailable 服务器端暂时无法处理请求（可能是过载或维护）。
]
</code></pre><h3 id="完整版"><a href="#完整版" class="headerlink" title="完整版"></a>完整版</h3><h4 id="1-信息类-：表示接收到请求并且继续处理"><a href="#1-信息类-：表示接收到请求并且继续处理" class="headerlink" title="1**(信息类)：表示接收到请求并且继续处理"></a>1**(信息类)：表示接收到请求并且继续处理</h4><pre><code>100——客户必须继续发出请求
101——客户要求服务器根据请求转换HTTP协议版本
</code></pre><h4 id="2-响应成功-：表示动作被成功接收、理解和接受"><a href="#2-响应成功-：表示动作被成功接收、理解和接受" class="headerlink" title="2**(响应成功)：表示动作被成功接收、理解和接受"></a>2**(响应成功)：表示动作被成功接收、理解和接受</h4><pre><code>200——表明该请求被成功地完成，所请求的资源发送回客户端
201——提示知道新文件的URL
202——接受和处理、但处理未完成
203——返回信息不确定或不完整
204——请求收到，但返回信息为空
205——服务器完成了请求，用户代理必须复位当前已经浏览过的文件
206——服务器已经完成了部分用户的GET请求
</code></pre><h4 id="3-重定向类-：为了完成指定的动作，必须接受进一步处理"><a href="#3-重定向类-：为了完成指定的动作，必须接受进一步处理" class="headerlink" title="3**(重定向类)：为了完成指定的动作，必须接受进一步处理"></a>3**(重定向类)：为了完成指定的动作，必须接受进一步处理</h4><pre><code>300——请求的资源可在多处得到
301——本网页被永久性转移到另一个URL
302——请求的网页被转移到一个新的地址，但客户访问仍继续通过原始URL地址，重定向，新的URL会在response中的Location中返回，浏览器将会使用新的URL发出新的Request。
303——建议客户访问其他URL或访问方式
304——自从上次请求后，请求的网页未修改过，服务器返回此响应时，不会返回网页内容，代表上次的文档已经被缓存了，还可以继续使用
305——请求的资源必须从服务器指定的地址得到
306——前一版本HTTP中使用的代码，现行版本中不再使用
307——申明请求的资源临时性删除
</code></pre><h4 id="4-客户端错误类-：请求包含错误语法或不能正确执行"><a href="#4-客户端错误类-：请求包含错误语法或不能正确执行" class="headerlink" title="4**(客户端错误类)：请求包含错误语法或不能正确执行"></a>4**(客户端错误类)：请求包含错误语法或不能正确执行</h4><pre><code>400——客户端请求有语法错误，不能被服务器所理解
401——请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用
HTTP 401.1 - 未授权：登录失败
　　HTTP 401.2 - 未授权：服务器配置问题导致登录失败
　　HTTP 401.3 - ACL 禁止访问资源
　　HTTP 401.4 - 未授权：授权被筛选器拒绝
HTTP 401.5 - 未授权：ISAPI 或 CGI 授权失败
402——保留有效ChargeTo头响应
403——禁止访问，服务器收到请求，但是拒绝提供服务
HTTP 403.1 禁止访问：禁止可执行访问
　　HTTP 403.2 - 禁止访问：禁止读访问
　　HTTP 403.3 - 禁止访问：禁止写访问
　　HTTP 403.4 - 禁止访问：要求 SSL
　　HTTP 403.5 - 禁止访问：要求 SSL 128
　　HTTP 403.6 - 禁止访问：IP 地址被拒绝
　　HTTP 403.7 - 禁止访问：要求客户证书
　　HTTP 403.8 - 禁止访问：禁止站点访问
　　HTTP 403.9 - 禁止访问：连接的用户过多
　　HTTP 403.10 - 禁止访问：配置无效
　　HTTP 403.11 - 禁止访问：密码更改
　　HTTP 403.12 - 禁止访问：映射器拒绝访问
　　HTTP 403.13 - 禁止访问：客户证书已被吊销
　　HTTP 403.15 - 禁止访问：客户访问许可过多
　　HTTP 403.16 - 禁止访问：客户证书不可信或者无效
HTTP 403.17 - 禁止访问：客户证书已经到期或者尚未生效
404——一个404错误表明可连接服务器，但服务器无法取得所请求的网页，请求资源不存在。eg：输入了错误的URL
405——用户在Request-Line字段定义的方法不允许
406——根据用户发送的Accept拖，请求资源不可访问
407——类似401，用户必须首先在代理服务器上得到授权
408——客户端没有在用户指定的饿时间内完成请求
409——对当前资源状态，请求不能完成
410——服务器上不再有此资源且无进一步的参考地址
411——服务器拒绝用户定义的Content-Length属性请求
412——一个或多个请求头字段在当前请求中错误
413——请求的资源大于服务器允许的大小
414——请求的资源URL长于服务器允许的长度
415——请求资源不支持请求项目格式
416——请求中包含Range请求头字段，在当前请求资源范围内没有range指示值，请求也不包含If-Range请求头字段
417——服务器不满足请求Expect头字段指定的期望值，如果是代理服务器，可能是下一级服务器不能满足请求长。
</code></pre><h4 id="5-服务端错误类-：服务器不能正确执行一个正确的请求"><a href="#5-服务端错误类-：服务器不能正确执行一个正确的请求" class="headerlink" title="5**(服务端错误类)：服务器不能正确执行一个正确的请求"></a>5**(服务端错误类)：服务器不能正确执行一个正确的请求</h4><pre><code>  HTTP 500 - 服务器遇到错误，无法完成请求
  　　HTTP 500.100 - 内部服务器错误 - ASP 错误
  　　HTTP 500-11 服务器关闭
  　　HTTP 500-12 应用程序重新启动
  　　HTTP 500-13 - 服务器太忙
  　　HTTP 500-14 - 应用程序无效
  　　HTTP 500-15 - 不允许请求 global.asa
  　　Error 501 - 未实现
HTTP 502 - 网关错误
HTTP 503：由于超载或停机维护，服务器目前无法使用，一段时间后可能恢复正常
</code></pre><hr>
<h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><h2 id="什么是事务？"><a href="#什么是事务？" class="headerlink" title="什么是事务？"></a>什么是事务？</h2><ul>
<li>事务就是被绑定在一起作为一个逻辑工作单元的SQL语句分组，如果任何一个语句操作失败那么整个操作就被失败，以后操作就会回滚到操作前状态，或者是上有个节点。为了确保要么执行，要么不执行，就可以使用事务。要将有组语句作为事务考虑，就需要通过ACID测试，即原子性，一致性，隔离性和持久性。<h2 id="数据库有哪几种事务"><a href="#数据库有哪几种事务" class="headerlink" title="数据库有哪几种事务"></a>数据库有哪几种事务</h2><h2 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h2>答：视图是一种虚拟的表，具有和物理表相同的功能。可以对视图进行增，改，查，操作，视图通常是有一个表或者多个表的行或列的子集。对视图的修改不影响基本表。它使得我们获取数据更容易，相比多表查询<h2 id="mysql的left-join，inner-join，right-join"><a href="#mysql的left-join，inner-join，right-join" class="headerlink" title="mysql的left join，inner join，right join;"></a>mysql的left join，inner join，right join;</h2></li>
<li>Inner Join:内连接是最常见的一种连接，只连接匹配的行。它又分为等值连接（连接条件运算符为”=”）和不等值连接（连接条件运算符不为”=”，例如between…and）。</li>
<li>Outer Join：它除了显示符合连接条件的记录以外，还会显示所有左表中的记录（右外连接就是所有右表中的记录）<ul>
<li>A FULL OUTER JOIN B：产生A和B的并集<br>*A Left Outer Join B：产生表A的完全集，而B表中匹配的则有值，没有匹配的则以null值取代。</li>
<li>A Right Outer Join B：是后面的表为基础<h2 id="mysql的索引"><a href="#mysql的索引" class="headerlink" title="mysql的索引;"></a>mysql的索引;</h2><h2 id="索引的作用？和它的优点缺点是什么？"><a href="#索引的作用？和它的优点缺点是什么？" class="headerlink" title="索引的作用？和它的优点缺点是什么？"></a>索引的作用？和它的优点缺点是什么？</h2>答：索引就一种特殊的查询表，数据库的搜索引擎可以利用它加速对数据的检索。它很类似与现实生活中书的目录，不需要查询整本书内容就可以找到想要的数据。索引可以是唯一的，创建索引允许指定单个列或者是多个列。缺点是它减慢了数据录入的速度，同时也增加了数据库的尺寸大小。<h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><h2 id="进程和线程有什么区别？"><a href="#进程和线程有什么区别？" class="headerlink" title="进程和线程有什么区别？"></a>进程和线程有什么区别？</h2></li>
</ul>
</li>
<li>进程和线程都是CPU工作时间段的描述。</li>
<li>进程是cpu资源分配的最小单位，线程是cpu调度的最小单位</li>
<li>线程的划分尺度小于进程，使得多线程程序的并发性高。</li>
<li>线程执行开销小，但不利于资源的管理和保护；</li>
<li>一个进程可以有多个线程</li>
<li>进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路径。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个线程死掉就等于整个进程死掉，所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要差一些.<h2 id="什么是死锁，死锁产生的4个条件"><a href="#什么是死锁，死锁产生的4个条件" class="headerlink" title="什么是死锁，死锁产生的4个条件"></a>什么是死锁，死锁产生的4个条件</h2><h3 id="死锁定义："><a href="#死锁定义：" class="headerlink" title="死锁定义："></a>死锁定义：</h3>　在两个或多个并发进程中，如果每个进程持有某种资源而又都等待别的进程释放它或它们现在保持着的资源，在未改变这种状态之前都不能向前推进，称这一组进程产生了死锁。通俗地讲，就是两个或多个进程被无限期地阻塞、相互等待的一种状态。<h3 id="产生条件："><a href="#产生条件：" class="headerlink" title="产生条件："></a>产生条件：</h3></li>
<li>1：互斥条件        – 一个资源一次只能被一个进程使用</li>
<li>2：请求保持条件 – 一个进程因请求资源而阻塞时，对已经获得资源保持不放 </li>
<li>3：不可抢占条件 – 进程已获得的资源在未使用完之前不能强行剥夺</li>
<li>4：循环等待条件 – 若干进程之间形成一种头尾相接的循环等待资源的关系</li>
</ul>
<h2 id="预防避免死锁的方法"><a href="#预防避免死锁的方法" class="headerlink" title="预防避免死锁的方法"></a>预防避免死锁的方法</h2><ul>
<li>1：破坏“请求和保持”条件：规定所有进程在开始运行之前，都必须一次性的申请其在整个运行过程所需要的全部资源。<ul>
<li>优点：简单，安全。 <ul>
<li>缺点：资源严重浪费，恶化了系统的利用率；</li>
</ul>
</li>
</ul>
</li>
<li>2：破坏“不剥夺”条件：进程逐个的提出资源请求，当一个已经保持了某些资源的进程，再提出新的资源请求而不能立即得到满足时，必须释放它已经保持了的所有资源，待以后需要时再重新申请。<ul>
<li>缺点：实现复杂，代价大，反复地申请和释放资源，而使进程的执行无限的推迟、延长了进程的周转时间增加系统开销、降低系统吞吐量。</li>
</ul>
</li>
<li>3：破坏“环路等待”条件：将所有的资源按类型进行线性排队，并赋予不同的序号。所有进程请求资源必须按照资源递增的次序提出，防止出现环路。 <ul>
<li>缺点：<ul>
<li>1、序号必须相对稳定，限制了新设备类型的增加</li>
<li>2、作业（进程）使用资源顺序和系统规定的顺序不同而造成资源的浪费</li>
<li>3、限制了用户编程 </li>
</ul>
</li>
</ul>
</li>
</ul>
<p>　　注意：由于互斥条件是非共享设备所必需的，不能改变</p>
<hr>
<h1 id="JQUERY"><a href="#JQUERY" class="headerlink" title="JQUERY"></a>JQUERY</h1><h2 id="1-你在公司是怎么用jquery的？"><a href="#1-你在公司是怎么用jquery的？" class="headerlink" title="1 你在公司是怎么用jquery的？"></a>1 你在公司是怎么用jquery的？</h2><p>答：在项目中是怎么用的是看看你有没有项目经验(根据自己的实际情况来回答) 你用过的选择器啊，复选框啊，表单啊，ajax啊，事件等配置<a href="http://lib.csdn.net/base/jquery">jQuery</a>环境 下载jquery类库 在jsp页面引用jquery类库即可</p>
<p><script type="text/[JavaScript](http://lib.csdn.net/base/javascript)" src="jquery/jquery-1.7.2.min.js"/>接下来通过在<script> $(function(){ }); </script></p>
<h2 id="2-你为什么要使用jquery？"><a href="#2-你为什么要使用jquery？" class="headerlink" title="2 你为什么要使用jquery？"></a>2 你为什么要使用jquery？</h2><p>答：因为jQuery是轻量级的框架，大小不到30kb,它有强大的选择器，出色的DOM操作的封装，有可靠的事件处理机制(jQuery在处理事件绑定的时候相当的可靠)，完善的ajax(它的ajax封装的非常的好，不需要考虑复杂浏览器的兼容性和XMLHttpRequest对象的创建和使用的问题。) 出色的浏览器的兼容性。 而且支持链式操作，隐式迭代。行为层和结构层的分离，还支持丰富的插件，jquery的文档也非常的丰富。</p>
<h2 id="3-你觉得jquery有哪些好处？-答案同上"><a href="#3-你觉得jquery有哪些好处？-答案同上" class="headerlink" title="3 你觉得jquery有哪些好处？ 答案同上"></a>3 你觉得jquery有哪些好处？ 答案同上</h2><h2 id="4-你使用jquery遇到过哪些问题，你是怎么解决的？"><a href="#4-你使用jquery遇到过哪些问题，你是怎么解决的？" class="headerlink" title="4 你使用jquery遇到过哪些问题，你是怎么解决的？"></a>4 你使用jquery遇到过哪些问题，你是怎么解决的？</h2><p>答：这个答案是开发的，看你是否有相关的项目经验。例前台拿不到值，JSON 可是出现的错误(多了一个空格等)这编译是不会报错的 jquery库与其他库冲突：1&gt;如果其他库在jquery库之前导入的话1.我们可以通过jquery.noconflict()将变量的$的控制权过度给其他库2.自定义快捷键,用一个变量接住jquery.noconflict()3.通过函数传参2&gt;如果jquery库在其他库之前导入就直接使用jquery今天在处理一个数据问题时，发现jQuery.ajax()方法返回的值一直有问题，清除缓存后数据无误，多次<a href="http://lib.csdn.net/base/softwaretest" target="_blank" rel="external">测试</a>后发现返回的值都是之前的值，并且一直未执行url(后台为<a href="http://lib.csdn.net/base/javase" target="_blank" rel="external">Java</a>，设置断点一直未进入)。在网上查找下,发现是未设置type的原因。 如果没设置jQuery.ajax的type=”Post”，那么ajax就会默认type=”Get”，这就会导致之前数据被缓存起来。加上type=”Post”，问题解决！</p>
<h2 id="5-你知道jquery中的选择器吗，请讲一下有哪些选择器？"><a href="#5-你知道jquery中的选择器吗，请讲一下有哪些选择器？" class="headerlink" title="5 你知道jquery中的选择器吗，请讲一下有哪些选择器？"></a>5 你知道jquery中的选择器吗，请讲一下有哪些选择器？</h2><p>答 ：jQuery中的选择器大致分为:基本选择器，层次选择器，过滤选择器，表单选择器</p>
<h2 id="6-jquery中的选择器-和-css中的选择器有区别吗？"><a href="#6-jquery中的选择器-和-css中的选择器有区别吗？" class="headerlink" title="6 jquery中的选择器 和 css中的选择器有区别吗？"></a>6 jquery中的选择器 和 css中的选择器有区别吗？</h2><p>答：jQuery选择器支持CSS里的选择器，jQuery选择器可用来添加样式和添加相应的行为CSS 中的选择器是只能添加相应的样式</p>
<h2 id="7-你觉得jquery中的选择器有什么优势？"><a href="#7-你觉得jquery中的选择器有什么优势？" class="headerlink" title="7 你觉得jquery中的选择器有什么优势？"></a>7 你觉得jquery中的选择器有什么优势？</h2><p>答：简单的写法 $(‘ID’) 来代替 document.getElementById()函数支持CSS1 到<a href="http://lib.csdn.net/base/css3" target="_blank" rel="external">CSS3</a> 选择器完善的处理机制(就算写错了id也不会报错)</p>
<h2 id="8-你在使用选择器的时候有有没有什么觉得要注意的地方？"><a href="#8-你在使用选择器的时候有有没有什么觉得要注意的地方？" class="headerlink" title="8 你在使用选择器的时候有有没有什么觉得要注意的地方？"></a>8 你在使用选择器的时候有有没有什么觉得要注意的地方？</h2><p>答: 1 选择器中含有”.”,”#”,”[“ 等特殊字符的时候需要进行转译2 属性选择器的引号问题3 选择器中含有空格的注意事项</p>
<h2 id="9-jquery对象和dom对象是怎样转换的？"><a href="#9-jquery对象和dom对象是怎样转换的？" class="headerlink" title="9 jquery对象和dom对象是怎样转换的？"></a>9 jquery对象和dom对象是怎样转换的？</h2><p>答 ：jquery转DOM对象:jQuery 对象是一个数组对象，可以通过[index]的丰富得到相应的DOM对象还可以通过get[index]去得到相应的DOM对象。DOM对象转jQuery对象:$(DOM对象)</p>
<h2 id="10-你是如何使用jquery中的ajax的？"><a href="#10-你是如何使用jquery中的ajax的？" class="headerlink" title="10 你是如何使用jquery中的ajax的？"></a>10 你是如何使用jquery中的ajax的？</h2><p>答: 如果是一些常规的ajax程序的话，使用load(),$.get(),$.post(),就可以搞定了，一般我会使用的是$.post() 方法。如果需要设定beforeSend(提交前回调函数),error(失败后处理),success(成功后处理)及complete(请求完成后处理)回调函数等，这个时候我会使用$.ajax()</p>
<h2 id="11-你觉得jquery中的ajax好用吗，为什么？"><a href="#11-你觉得jquery中的ajax好用吗，为什么？" class="headerlink" title="11 你觉得jquery中的ajax好用吗，为什么？"></a>11 你觉得jquery中的ajax好用吗，为什么？</h2><p>答: 好用的。 因为jQuery提供了一些日常开发中夙瑶的快捷操作，例 load，ajax，get，post等等，所以使用jQuery开发ajax将变得极其简单，我们就可以集中精力在业务和用户的体验上，不需要去理会那些繁琐的XMLHttpRequest对象了。</p>
<h2 id="12-jquery中-get-提交和-post-提交有区别吗？"><a href="#12-jquery中-get-提交和-post-提交有区别吗？" class="headerlink" title="12 jquery中$.get()提交和$.post()提交有区别吗？"></a>12 jquery中$.get()提交和$.post()提交有区别吗？</h2><p>答: 1 $.get() 方法使用GET方法来进行异步请求的。$.post() 方法使用POST方法来进行异步请求的。2 get请求会将参数跟在URL后进行传递，而POST请求则是作为HTTP消息的实体内容发送给Web服务器的，这种传递是对用户不可见的。3 get方式传输的数据大小不能超过2KB 而POST要大的多4 GET 方式请求的数据会被浏览器缓存起来，因此有安全问题。</p>
<h2 id="13-jquery中的load方法一般怎么用的？"><a href="#13-jquery中的load方法一般怎么用的？" class="headerlink" title="13 jquery中的load方法一般怎么用的？"></a>13 jquery中的load方法一般怎么用的？</h2><p>答：load方法一般在 载入远程HTML 代码并插入到DOM中的时候用，通常用来从Web服务器上获取静态的数据文件。如果要传递参数的话，可以使用$.get() 或 $.post()。</p>
<h2 id="14-在jquery中你是如何去操作样式的？"><a href="#14-在jquery中你是如何去操作样式的？" class="headerlink" title="14 在jquery中你是如何去操作样式的？"></a>14 在jquery中你是如何去操作样式的？</h2><p>答: addClass() 来追加样式 ，removeClass() 来删除样式，toggle() 来切换样式</p>
<h2 id="15-简单的讲叙一下jquery是怎么处理事件的，你用过哪些事件？"><a href="#15-简单的讲叙一下jquery是怎么处理事件的，你用过哪些事件？" class="headerlink" title="15 简单的讲叙一下jquery是怎么处理事件的，你用过哪些事件？"></a>15 简单的讲叙一下jquery是怎么处理事件的，你用过哪些事件？</h2><p>答: 首先去装载文档，在页面家在完毕后，浏览器会通过javascript 为DOM元素添加事件。</p>
<h2 id="16-你使用过jquery中的动画吗，是怎样用的？"><a href="#16-你使用过jquery中的动画吗，是怎样用的？" class="headerlink" title="16 你使用过jquery中的动画吗，是怎样用的？"></a>16 你使用过jquery中的动画吗，是怎样用的？</h2><p>答:使用过。hide() 和 show() 同时修改多个样式属性。像高度，宽度，不透明度。 fadeIn() 和fadeOut() fadeTo() 只改变不透明度slideUp() 和 slideDown() slideToggle() 只改变高度animate() 属于自定义动画的方法.</p>
<h2 id="17-你使用过jquery中的插件吗？-答-看个人的实力和经验来回答了。"><a href="#17-你使用过jquery中的插件吗？-答-看个人的实力和经验来回答了。" class="headerlink" title="17 你使用过jquery中的插件吗？ 答:看个人的实力和经验来回答了。"></a>17 你使用过jquery中的插件吗？ 答:看个人的实力和经验来回答了。</h2><h2 id="18-你一般用什么去提交数据，为什么？"><a href="#18-你一般用什么去提交数据，为什么？" class="headerlink" title="18 你一般用什么去提交数据，为什么？"></a>18 你一般用什么去提交数据，为什么？</h2><p>答:一般我会使用的是$.post() 方法。如果需要设定beforeSend(提交前回调函数),error(失败后处理),success(成功后处理及complete(请求完成后处理)回调函数等，这个时候我会使用$.ajax()</p>
<h2 id="19-在jquery中引入css有几种方式？"><a href="#19-在jquery中引入css有几种方式？" class="headerlink" title="19 在jquery中引入css有几种方式？"></a>19 在jquery中引入css有几种方式？</h2><p>答:四种 行内式，内嵌式，导入式，链接式</p>
<h2 id="20-你在jquery中使用过哪些插入节点的方法，它们的区别是什么？"><a href="#20-你在jquery中使用过哪些插入节点的方法，它们的区别是什么？" class="headerlink" title="20 你在jquery中使用过哪些插入节点的方法，它们的区别是什么？"></a>20 你在jquery中使用过哪些插入节点的方法，它们的区别是什么？</h2><p>答:append(),appendTo(),prepend(),prependTo(),after(),insertAfter()，before(),insertBefore() 大致可以分为 内部追加和外部追加append() 表式向每个元素内部追加内容。appendTo()表示 讲所有的元素追加到指定的元素中。例$(A)appendTo(B) 是将A追加到B中下面的方法解释类似。</p>
<h2 id="21-你使用过包裹节点的方法吗，包裹节点有方法有什么好处？"><a href="#21-你使用过包裹节点的方法吗，包裹节点有方法有什么好处？" class="headerlink" title="21 你使用过包裹节点的方法吗，包裹节点有方法有什么好处？"></a>21 你使用过包裹节点的方法吗，包裹节点有方法有什么好处？</h2><p>答: wrapAll(),wrap(), wrapInner() 需要在文档中插入额外的结构化标记的时候可以使用这些包裹的方法应为它不会帛画原始文档的语义</p>
<h2 id="22-jquery中如何来获取或和设置属性？"><a href="#22-jquery中如何来获取或和设置属性？" class="headerlink" title="22 jquery中如何来获取或和设置属性？"></a>22 jquery中如何来获取或和设置属性？</h2><p>jQuery中可以用attr()方法来获取和设置元素属性removeAttr() 方法来删除元素属性</p>
<h2 id="23-如何来设置和获取HTML-和文本的值？"><a href="#23-如何来设置和获取HTML-和文本的值？" class="headerlink" title="23 如何来设置和获取HTML 和文本的值？"></a>23 如何来设置和获取HTML 和文本的值？</h2><p>答：html()方法 类似于innerHTML属性 可以用来读取或者设置某个元素中的HTML内容注意：html() 可以用于xhtml文档 不能用于xml文档text() 类似于innerText属性 可以用来读取或设置某个元素中文本内容。val() 可以用来设置和获取元素的值</p>
<h2 id="24-你jquery中有哪些方法可以遍历节点？"><a href="#24-你jquery中有哪些方法可以遍历节点？" class="headerlink" title="24 你jquery中有哪些方法可以遍历节点？"></a>24 你jquery中有哪些方法可以遍历节点？</h2><p>答 ：children() 取得匹配元素的子元素集合,只考虑子元素不考虑后代元素 next() 取得匹配元素后面紧邻的同辈元素prev() 取得匹配元素前面紧邻的同辈元素siblings() 取得匹配元素前后的所有同辈元素closest() 取得最近的匹配元素find() 取得匹配元素中的元素集合 包括子代和后代</p>
<h2 id="25-子元素选择器-和后代选择器元素有什么区别？"><a href="#25-子元素选择器-和后代选择器元素有什么区别？" class="headerlink" title="25 子元素选择器 和后代选择器元素有什么区别？"></a>25 子元素选择器 和后代选择器元素有什么区别？</h2><p>答:子代元素是找子节点下的所有元素,后代元素是找子节点或子节点的子节点中的元素</p>
<h2 id="26-在jquery中可以替换节点吗？"><a href="#26-在jquery中可以替换节点吗？" class="headerlink" title="26 在jquery中可以替换节点吗？"></a>26 在jquery中可以替换节点吗？</h2><p>答：可以 在jQuery中有两者替换节点的方式 replaceWith() 和 replaceAll()例如在</p><p title="hao are you">hao are you</p>替换成<strong>I am fine</strong>$(‘p’).replaceWith(‘<strong>I am fine</strong>‘); replaceAll 与replaceWith的用法前后调换一下即可。<em>**</em><p></p>
<h2 id="27-你觉得beforeSend方法有什么用？"><a href="#27-你觉得beforeSend方法有什么用？" class="headerlink" title="27 你觉得beforeSend方法有什么用？"></a>27 你觉得beforeSend方法有什么用？</h2><p>答：发送请求前可以修改XMLHttpRequest对象的函数，在beforeSend中如果返回false 可以取消本次的Ajax请求。XMLHttpRequest对象是唯一的参数所以在这个方法里可以做验证</p>
<h2 id="28-siblings-方法-和-‘prev-div’-选择器是一样的嘛？"><a href="#28-siblings-方法-和-‘prev-div’-选择器是一样的嘛？" class="headerlink" title="28 siblings() 方法 和 $(‘prev~div’)选择器是一样的嘛？"></a>28 siblings() 方法 和 $(‘prev~div’)选择器是一样的嘛？</h2><p>答: $(‘prev~div’) 只能选择’#prev’元素后面的同辈<div>元素而siblings()方法与前后的文职无关，只要是同辈节点就都能匹配。</div></p>
<h2 id="29-你在ajax中使用过JSON吗，你是如何用的？"><a href="#29-你在ajax中使用过JSON吗，你是如何用的？" class="headerlink" title="29 你在ajax中使用过JSON吗，你是如何用的？"></a>29 你在ajax中使用过JSON吗，你是如何用的？</h2><p>答:使用过，在$.getJSON() 方法的时候就是。因为 $.getJSON() 就是用于加载JSON文件的</p>
<h2 id="30-有哪些查询节点的选择器？"><a href="#30-有哪些查询节点的选择器？" class="headerlink" title="30 有哪些查询节点的选择器？"></a>30 有哪些查询节点的选择器？</h2><p>答：我在公司使用过 :first 查询第一个，:last 查询最后一个，:odd查询奇数但是索引从0开始:even 查询偶数，:eq(index)查询相等的 ,:gt(index)查询大于index的 ,:lt查询小于index:header 选取所有的标题等</p>
<h2 id="31-nextAll-能-替代-‘prev-siblindgs’-选择器吗？"><a href="#31-nextAll-能-替代-‘prev-siblindgs’-选择器吗？" class="headerlink" title="31 nextAll() 能 替代$(‘prev~siblindgs’)选择器吗？"></a>31 nextAll() 能 替代$(‘prev~siblindgs’)选择器吗？</h2><p>答:能。 使用nextAll() 和使用$(‘prev~siblindgs’) 是一样的</p>
<h2 id="32-jQuery中有几种方法可以来设置和获取样式"><a href="#32-jQuery中有几种方法可以来设置和获取样式" class="headerlink" title="32 jQuery中有几种方法可以来设置和获取样式"></a>32 jQuery中有几种方法可以来设置和获取样式</h2><p>答 ：addClass() 方法，attr() 方法</p>
<h2 id="33-document-ready-方法和window-onload有什么区别？"><a href="#33-document-ready-方法和window-onload有什么区别？" class="headerlink" title="33 $(document).ready()方法和window.onload有什么区别？"></a>33 $(document).ready()方法和window.onload有什么区别？</h2><p>答: 两个方法有相似的功能，但是在实行时机方面是有区别的。 1window.onload方法是在网页中所有的元素(包括元素的所有关联文件)完全加载到浏览器后才执行的。2 $(document).ready() 方法可以在DOM载入就绪时就对其进行操纵，并调用执行绑定的函数。</p>
<h2 id="34-jQuery是如何处理缓存的？"><a href="#34-jQuery是如何处理缓存的？" class="headerlink" title="34 jQuery是如何处理缓存的？"></a>34 jQuery是如何处理缓存的？</h2><p>答 ：要处理缓存就是禁用缓存.1 通过$.post() 方法来获取数据，那么默认就是禁用缓存的。2 通过$.get()方法 来获取数据，可以通过设置时间戳来避免缓存。可以在URL后面加上+(+new Date)例 $.get(‘ajax.xml?’+(+new Date),function () { //内容 }); 3 通过$.ajax 方法来获取数据，只要设置cache:false即可。</p>
<h2 id="35-getScript-方法-和-getJson-方法有什么区别？"><a href="#35-getScript-方法-和-getJson-方法有什么区别？" class="headerlink" title="35 $.getScript()方法 和 $.getJson() 方法有什么区别？"></a>35 $.getScript()方法 和 $.getJson() 方法有什么区别？</h2><p>答: 1 $.getScript() 方法可以直接加载.js文件，并且不需要对javascript文件进行处理，javascript文件会自动执行。2 $.getJson() 是用于加载JSON 文件的 ，用法和$.getScript()</p>

      
    </div>

    <div>
      
        
      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2016/06/27/ms/" rel="next" title="ms">
                <i class="fa fa-chevron-left"></i> ms
              </a>
            
          </div>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2016/07/02/hexo-gihubpages-搭建博客/" rel="prev" title="最详尽-hexo+GithubPages搭建博客">
                最详尽-hexo+GithubPages搭建博客 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
        
<script>
  with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?cdnversion='+~(-new Date()/36e5)];
</script>

      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
      <div class="ds-thread" data-thread-key="2016/06/28/book/"
           data-title="book" data-url="http://carryguan.com/2016/06/28/book/">
      </div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/me2.jpg"
               alt="Carry Guan" />
          <p class="site-author-name" itemprop="name">Carry Guan</p>
          <p class="site-description motion-element" itemprop="description">写写代码，看看韩剧.好开心呀，又吃成长快乐了 ^~^.</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">16</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">51</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/sunningcarryhaha" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/5048785433/profile?topnav=1&wvr=6&is_all=1" target="_blank" title="Weibo">
                  
                    <i class="fa fa-fw fa-weibo"></i>
                  
                  Weibo
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://www.zhihu.com/people/guan-kai-li-88" target="_blank" title="ZhiHu">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  ZhiHu
                </a>
              </span>
            
          
        </div>

        
        

        
        
          <div class="links-of-blogroll motion-element links-of-blogroll-inline">
            <div class="links-of-blogroll-title">
              <i class="fa  fa-fw fa-globe"></i>
              Links
            </div>
            <ul class="links-of-blogroll-list">
              
                <li class="links-of-blogroll-item">
                  <a href="https://www.betterwill.me" title="LiuXiaojian" target="_blank">LiuXiaojian</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="http://yuanguangxin.me" title="Yuanguangxin" target="_blank">Yuanguangxin</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="http://huangxuan.me" title="Nanshen" target="_blank">Nanshen</a>
                </li>
              
            </ul>
          </div>
        

      </section>

      
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">
            
              
            
            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#HTML-amp-CSS"><span class="nav-text">HTML&CSS</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#常见的行内元素与块级元素都有哪些，分别举例-，并说一说区别5"><span class="nav-text">常见的行内元素与块级元素都有哪些，分别举例 ，并说一说区别5%</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#margin"><span class="nav-text">margin</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#居中的常见方法-水平，竖直-5"><span class="nav-text">居中的常见方法(水平，竖直) 5%</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-水平居中"><span class="nav-text">1.水平居中</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-水平居中-父元素-text-align：center；"><span class="nav-text">2.水平居中 父元素 text-align：center；</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#水平垂直居中（一）"><span class="nav-text">水平垂直居中（一）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#水平垂直居中（三）绝对定位和transfrom"><span class="nav-text">水平垂直居中（三）绝对定位和transfrom</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#水平垂直居中（二）"><span class="nav-text">水平垂直居中（二）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#水平垂直居中（四）diplay：table-cell"><span class="nav-text">水平垂直居中（四）diplay：table-cell</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#水平垂直居中（五）flexBox居中"><span class="nav-text">水平垂直居中（五）flexBox居中</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#常见的垂直居中的方式"><span class="nav-text">常见的垂直居中的方式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#如何让几行文本垂直居中？如何让一行文本进行垂直居中？"><span class="nav-text">如何让几行文本垂直居中？如何让一行文本进行垂直居中？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#flex弹性布局："><span class="nav-text">flex弹性布局：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#浮动"><span class="nav-text">浮动</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#说一下为什么要清除浮动以及常见的清除浮动的方法-4"><span class="nav-text">说一下为什么要清除浮动以及常见的清除浮动的方法 4%</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#方法一：在被清除浮动元素内部末尾添加新元素-、应用-clear：both"><span class="nav-text">方法一：在被清除浮动元素内部末尾添加新元素 、应用 clear：both</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#方法二：触发BFC"><span class="nav-text">方法二：触发BFC</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BFC"><span class="nav-text">BFC</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#介绍一下标准的CSS的盒子模型？低版本IE的盒子模型有什么不同的？"><span class="nav-text">介绍一下标准的CSS的盒子模型？低版本IE的盒子模型有什么不同的？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#position-的几种值-，详细说明一下每种的区别-3"><span class="nav-text">position 的几种值 ，详细说明一下每种的区别 3%</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#如果position设置成absolute属性该元素的display属性会变成什么"><span class="nav-text">如果position设置成absolute属性该元素的display属性会变成什么</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#display-有几个值-3"><span class="nav-text">display 有几个值  3%</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#伪类-伪元素"><span class="nav-text">伪类 伪元素</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CSS3新增伪类有那些？"><span class="nav-text">CSS3新增伪类有那些？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CSS选择器有哪些？哪些属性可以继承？"><span class="nav-text">CSS选择器有哪些？哪些属性可以继承？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CSS优先级算法如何计算？"><span class="nav-text">CSS优先级算法如何计算？</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#同权重"><span class="nav-text">同权重</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#属性选择器的权重问题"><span class="nav-text">属性选择器的权重问题:</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#页面导入样式时，使用link和-import有什么区别？"><span class="nav-text">页面导入样式时，使用link和@import有什么区别？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#引入css的几种方式-2"><span class="nav-text">引入css的几种方式 2%</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-行内样式"><span class="nav-text">1.行内样式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-内嵌样式"><span class="nav-text">2.内嵌样式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-链接样式"><span class="nav-text">3.链接样式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-导入样式（不建议使用）"><span class="nav-text">4.导入样式（不建议使用）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#四种CSS引入方式的优先级"><span class="nav-text">四种CSS引入方式的优先级</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#锚点-1"><span class="nav-text">锚点 1%</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#两栏布局（左固定，右自适应）"><span class="nav-text">两栏布局（左固定，右自适应）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-float-margin"><span class="nav-text">1:float+margin</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2：float-BFC"><span class="nav-text">2：float+BFC</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-left-0-left-左宽-right-0"><span class="nav-text">3:left:0,left:-左宽,right:0;</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#三个元素都浮动，左定宽高，右宽-cal-100-x"><span class="nav-text">三个元素都浮动，左定宽高，右宽 cal(100%-x)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#实现三列布局（两边固定，中间自适应）"><span class="nav-text">实现三列布局（两边固定，中间自适应）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BFC的通俗理解："><span class="nav-text">BFC的通俗理解：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BFC规范中的定义："><span class="nav-text">BFC规范中的定义：</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#BFC的特性"><span class="nav-text">BFC的特性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#BFC的常见应用"><span class="nav-text">BFC的常见应用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#常见的浏览器端的存储技术都有哪些，以及他们的优缺点和使用场景？"><span class="nav-text">常见的浏览器端的存储技术都有哪些，以及他们的优缺点和使用场景？</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#cookie"><span class="nav-text">cookie</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Flash-ShareObject"><span class="nav-text">Flash ShareObject</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#sessionStorage"><span class="nav-text">sessionStorage</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#localStorage"><span class="nav-text">localStorage</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#globalStorage"><span class="nav-text">globalStorage</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Google-Gear"><span class="nav-text">Google Gear</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#userData"><span class="nav-text">userData</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#请描述一下-cookies，sessionStorage-和-localStorage-的区别？"><span class="nav-text">请描述一下 cookies，sessionStorage 和 localStorage 的区别？</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#存储大小："><span class="nav-text">存储大小：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#有期时间："><span class="nav-text">有期时间：</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#HTML5"><span class="nav-text">HTML5</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#新特性"><span class="nav-text">新特性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-标签语义化，"><span class="nav-text">1:标签语义化，</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2、音视频元素，"><span class="nav-text">2、音视频元素，</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3、新增很多api，"><span class="nav-text">3、新增很多api，</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#、websocket"><span class="nav-text">、websocket</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#、HTML5-能够本地存储数据，在之前都是使用-cookies-使用的。"><span class="nav-text">、HTML5 能够本地存储数据，在之前都是使用 cookies 使用的。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#：请描述一下-cookies，sessionStorage-和-localStorage-的区别？"><span class="nav-text">：请描述一下 cookies，sessionStorage 和 localStorage 的区别？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#、应用程序缓存："><span class="nav-text">、应用程序缓存：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#、web-worker，web-worker"><span class="nav-text">、web worker，web worker</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#CSS3"><span class="nav-text">CSS3</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#媒体查询具体到语句-5"><span class="nav-text">媒体查询具体到语句 5%</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#响应式布局meta-scale-怎样使用media"><span class="nav-text">响应式布局meta,scale 怎样使用media?</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#meta-scale"><span class="nav-text">meta,scale</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#第二步：媒体查询-语句"><span class="nav-text">第二步：媒体查询 语句</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#css-伪类-5"><span class="nav-text">css 伪类 5%</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#伪类选择器"><span class="nav-text">伪类选择器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#伪类-伪元素-1"><span class="nav-text">伪类 伪元素</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#说一下flex-3"><span class="nav-text">说一下flex 3%</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#请解释一下CSS3的Flexbox（弹性盒布局模型）-以及适用场景？"><span class="nav-text">请解释一下CSS3的Flexbox（弹性盒布局模型）,以及适用场景？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#动画-2"><span class="nav-text">动画 2%</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#css3动画卡了"><span class="nav-text">css3动画卡了</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#移动端"><span class="nav-text">移动端</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#移动端适配："><span class="nav-text">移动端适配：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#自适应，响应式布局："><span class="nav-text">自适应，响应式布局：</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#JS"><span class="nav-text">JS</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#js数据类型有哪些-5"><span class="nav-text">js数据类型有哪些 5%</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#null-和undefined"><span class="nav-text">null 和undefined</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#简单说一下作用域与作用域链-5"><span class="nav-text">简单说一下作用域与作用域链 5%</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#作用域和作用域链"><span class="nav-text">作用域和作用域链</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#谈一下关于作用域"><span class="nav-text">谈一下关于作用域</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#原型-原型链-原型继承（说一下原型-原型链，考了几道题-让你现在作答）-5"><span class="nav-text">原型 原型链 原型继承（说一下原型 原型链，考了几道题 让你现在作答） 5%</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#原型"><span class="nav-text">原型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#原型链"><span class="nav-text">原型链</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#继承"><span class="nav-text">继承</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#闭包"><span class="nav-text">闭包</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#a：说一下什么是闭包"><span class="nav-text">a：说一下什么是闭包?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#b-闭包的原理（深刻一点，包括作用域链，垃圾回收机制）"><span class="nav-text">b:闭包的原理（深刻一点，包括作用域链，垃圾回收机制）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#c-你是如何应用闭包的"><span class="nav-text">c:你是如何应用闭包的?</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-模拟块级作用域（私有变量和作用域）"><span class="nav-text">1:模拟块级作用域（私有变量和作用域）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2：构造模式，定义接口，让外界可以访问函数的私有变量"><span class="nav-text">2：构造模式，定义接口，让外界可以访问函数的私有变量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3：原型模式-私有作用域-定义接口"><span class="nav-text">3：原型模式 私有作用域 定义接口</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4：模块化"><span class="nav-text">4：模块化</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#d-使用闭包应该注意？"><span class="nav-text">d:使用闭包应该注意？</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-闭包只能取某变量的最后一个值（for循环中的匿名函数）"><span class="nav-text">1:闭包只能取某变量的最后一个值（for循环中的匿名函数）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-闭包中的this指向-window"><span class="nav-text">2:闭包中的this指向 window</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#d-闭包的优缺点"><span class="nav-text">d:闭包的优缺点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#f-如何创建闭包"><span class="nav-text">f:如何创建闭包</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#作用域和作用域链-1"><span class="nav-text">作用域和作用域链</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#内存泄露，垃圾回收机制"><span class="nav-text">内存泄露，垃圾回收机制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#函数声明与函数表达式"><span class="nav-text">函数声明与函数表达式</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#js事件-5"><span class="nav-text">js事件 5%</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#事件模型"><span class="nav-text">事件模型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#事件委托"><span class="nav-text">事件委托</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#浏览器对事件的处理过"><span class="nav-text">浏览器对事件的处理过</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#垃圾回收"><span class="nav-text">垃圾回收?</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#为什么要垃圾回收？"><span class="nav-text">* 为什么要垃圾回收？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#垃圾回收的基本方法？"><span class="nav-text">* 垃圾回收的基本方法？</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1、标记清除（mark-and-sweep）"><span class="nav-text">1、标记清除（mark and sweep）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2。标记清除"><span class="nav-text">2。标记清除</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#减少垃圾回收？"><span class="nav-text">* 减少垃圾回收？</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#原生js的-增-删-改-5"><span class="nav-text">原生js的(增 删 改) 5%</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#增"><span class="nav-text">增</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#删"><span class="nav-text">删</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#改"><span class="nav-text">改</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#查"><span class="nav-text">查</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#jq增删改查"><span class="nav-text">jq增删改查</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#深拷贝与浅拷贝"><span class="nav-text">深拷贝与浅拷贝</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#数组深拷贝"><span class="nav-text">数组深拷贝</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-使用slice，concat进行数组拷贝"><span class="nav-text">1.使用slice，concat进行数组拷贝</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-使用循环遍历拷贝"><span class="nav-text">2.使用循环遍历拷贝</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-ES6拷贝数组Array-from，-…oldArr"><span class="nav-text">3. ES6拷贝数组Array.from， […oldArr]</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#对象深拷贝"><span class="nav-text">对象深拷贝</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#JSON对象的parse和stringify"><span class="nav-text">JSON对象的parse和stringify</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#jQuery中的extend复制方法"><span class="nav-text">jQuery中的extend复制方法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#自己实现深拷贝"><span class="nav-text">自己实现深拷贝</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#new"><span class="nav-text">new</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#New一共做了几个操作步骤，要求具体说明"><span class="nav-text">New一共做了几个操作步骤，要求具体说明</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#new一个对象-执行了什么过程？，那-return-‘-’，null-undefined会怎样？"><span class="nav-text">new一个对象 执行了什么过程？，那 return ‘ ’，null,undefined会怎样？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#如何判定js一个变量值的类型（至少3种）3"><span class="nav-text">如何判定js一个变量值的类型（至少3种）3%</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数组和字符串的转换-3"><span class="nav-text">数组和字符串的转换 3%</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#arguments"><span class="nav-text">arguments</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#是啥？"><span class="nav-text">是啥？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#转为数组？"><span class="nav-text">转为数组？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#arguments其他用法？"><span class="nav-text">arguments其他用法？</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#利用arguments-callee实现递归"><span class="nav-text">利用arguments.callee实现递归</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#递归"><span class="nav-text">递归</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-arguments-callee"><span class="nav-text">1.arguments.callee</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-使用函数命名表达式"><span class="nav-text">2.使用函数命名表达式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-递归性能上的分析？优化？用es6优化？"><span class="nav-text">3.递归性能上的分析？优化？用es6优化？</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#使用尾调递归优化递归"><span class="nav-text">使用尾调递归优化递归</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ES6尾调用"><span class="nav-text">ES6尾调用</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#字符串和json的转换3"><span class="nav-text">字符串和json的转换3%</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#eval"><span class="nav-text">eval()</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#typeof-输出"><span class="nav-text">typeof 输出</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#链式调用"><span class="nav-text">链式调用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-方法中直接-return-this"><span class="nav-text">1.方法中直接 return this</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#跨域"><span class="nav-text">跨域</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#如何解决ajax跨域"><span class="nav-text">如何解决ajax跨域</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-CROS方式（跨域资源共享）"><span class="nav-text">1.CROS方式（跨域资源共享）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-JSONP方式"><span class="nav-text">2.JSONP方式</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-你为什么要使用jquery？"><span class="nav-text">2 你为什么要使用jquery？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-你觉得jquery有哪些好处？-答案同上"><span class="nav-text">3 你觉得jquery有哪些好处？ 答案同上</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-你使用jquery遇到过哪些问题，你是怎么解决的？"><span class="nav-text">4 你使用jquery遇到过哪些问题，你是怎么解决的？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-你知道jquery中的选择器吗，请讲一下有哪些选择器？"><span class="nav-text">5 你知道jquery中的选择器吗，请讲一下有哪些选择器？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-jquery中的选择器-和-css中的选择器有区别吗？"><span class="nav-text">6 jquery中的选择器 和 css中的选择器有区别吗？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-你觉得jquery中的选择器有什么优势？"><span class="nav-text">7 你觉得jquery中的选择器有什么优势？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-你在使用选择器的时候有有没有什么觉得要注意的地方？"><span class="nav-text">8 你在使用选择器的时候有有没有什么觉得要注意的地方？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9-jquery对象和dom对象是怎样转换的？"><span class="nav-text">9 jquery对象和dom对象是怎样转换的？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#10-你是如何使用jquery中的ajax的？"><span class="nav-text">10 你是如何使用jquery中的ajax的？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#11-你觉得jquery中的ajax好用吗，为什么？"><span class="nav-text">11 你觉得jquery中的ajax好用吗，为什么？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#12-jquery中-get-提交和-post-提交有区别吗？"><span class="nav-text">12 jquery中$.get()提交和$.post()提交有区别吗？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#13-jquery中的load方法一般怎么用的？"><span class="nav-text">13 jquery中的load方法一般怎么用的？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#14-在jquery中你是如何去操作样式的？"><span class="nav-text">14 在jquery中你是如何去操作样式的？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#15-简单的讲叙一下jquery是怎么处理事件的，你用过哪些事件？"><span class="nav-text">15 简单的讲叙一下jquery是怎么处理事件的，你用过哪些事件？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#16-你使用过jquery中的动画吗，是怎样用的？"><span class="nav-text">16 你使用过jquery中的动画吗，是怎样用的？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#17-你使用过jquery中的插件吗？-答-看个人的实力和经验来回答了。"><span class="nav-text">17 你使用过jquery中的插件吗？ 答:看个人的实力和经验来回答了。</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#18-你一般用什么去提交数据，为什么？"><span class="nav-text">18 你一般用什么去提交数据，为什么？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#19-在jquery中引入css有几种方式？"><span class="nav-text">19 在jquery中引入css有几种方式？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#20-你在jquery中使用过哪些插入节点的方法，它们的区别是什么？"><span class="nav-text">20 你在jquery中使用过哪些插入节点的方法，它们的区别是什么？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#21-你使用过包裹节点的方法吗，包裹节点有方法有什么好处？"><span class="nav-text">21 你使用过包裹节点的方法吗，包裹节点有方法有什么好处？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#22-jquery中如何来获取或和设置属性？"><span class="nav-text">22 jquery中如何来获取或和设置属性？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#23-如何来设置和获取HTML-和文本的值？"><span class="nav-text">23 如何来设置和获取HTML 和文本的值？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#24-你jquery中有哪些方法可以遍历节点？"><span class="nav-text">24 你jquery中有哪些方法可以遍历节点？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#25-子元素选择器-和后代选择器元素有什么区别？"><span class="nav-text">25 子元素选择器 和后代选择器元素有什么区别？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#26-在jquery中可以替换节点吗？"><span class="nav-text">26 在jquery中可以替换节点吗？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#27-你觉得beforeSend方法有什么用？"><span class="nav-text">27 你觉得beforeSend方法有什么用？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#28-siblings-方法-和-‘prev-div’-选择器是一样的嘛？"><span class="nav-text">28 siblings() 方法 和 $(‘prev~div’)选择器是一样的嘛？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#29-你在ajax中使用过JSON吗，你是如何用的？"><span class="nav-text">29 你在ajax中使用过JSON吗，你是如何用的？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#30-有哪些查询节点的选择器？"><span class="nav-text">30 有哪些查询节点的选择器？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#31-nextAll-能-替代-‘prev-siblindgs’-选择器吗？"><span class="nav-text">31 nextAll() 能 替代$(‘prev~siblindgs’)选择器吗？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#32-jQuery中有几种方法可以来设置和获取样式"><span class="nav-text">32 jQuery中有几种方法可以来设置和获取样式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#33-document-ready-方法和window-onload有什么区别？"><span class="nav-text">33 $(document).ready()方法和window.onload有什么区别？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#34-jQuery是如何处理缓存的？"><span class="nav-text">34 jQuery是如何处理缓存的？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#35-getScript-方法-和-getJson-方法有什么区别？"><span class="nav-text">35 $.getScript()方法 和 $.getJson() 方法有什么区别？</span></a></li></ol></li></ol></div>
            
          </div>
        </section>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy;  2016 - 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Carry Guan</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.0.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.0.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"carryguan"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
      
      <script src="/vendors/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
      <script src="/js/src/hook-duoshuo.js"></script>
    
  






  
  
  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length == 0) {
       search_path = "search.xml";
    }
    var path = "/" + search_path;
    // monitor main search box;

    function proceedsearch() {
      $("body").append('<div class="popoverlay">').css('overflow', 'hidden');
      $('.popup').toggle();

    }
    // search function;
    var searchFunc = function(path, search_id, content_id) {
    'use strict';
    $.ajax({
        url: path,
        dataType: "xml",
        async: true,
        success: function( xmlResponse ) {
            // get the contents from search data
            isfetched = true;
            $('.popup').detach().appendTo('.header-inner');
            var datas = $( "entry", xmlResponse ).map(function() {
                return {
                    title: $( "title", this ).text(),
                    content: $("content",this).text(),
                    url: $( "url" , this).text()
                };
            }).get();
            var $input = document.getElementById(search_id);
            var $resultContent = document.getElementById(content_id);
            $input.addEventListener('input', function(){
                var matchcounts = 0;
                var str='<ul class=\"search-result-list\">';                
                var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                $resultContent.innerHTML = "";
                if (this.value.trim().length > 1) {
                // perform local searching
                datas.forEach(function(data) {
                    var isMatch = true;
                    var content_index = [];
                    var data_title = data.title.trim().toLowerCase();
                    var data_content = data.content.trim().replace(/<[^>]+>/g,"").toLowerCase();
                    var data_url = data.url;
                    var index_title = -1;
                    var index_content = -1;
                    var first_occur = -1;
                    // only match artiles with not empty titles and contents
                    if(data_title != '' && data_content != '') {
                        keywords.forEach(function(keyword, i) {
                            index_title = data_title.indexOf(keyword);
                            index_content = data_content.indexOf(keyword);
                            if( index_title < 0 && index_content < 0 ){
                                isMatch = false;
                            } else {
                                if (index_content < 0) {
                                    index_content = 0;
                                }
                                if (i == 0) {
                                    first_occur = index_content;
                                }
                            }
                        });
                    }
                    // show search results
                    if (isMatch) {
                        matchcounts += 1;
                        str += "<li><a href='"+ data_url +"' class='search-result-title'>"+ data_title +"</a>";
                        var content = data.content.trim().replace(/<[^>]+>/g,"");
                        if (first_occur >= 0) {
                            // cut out 100 characters
                            var start = first_occur - 20;
                            var end = first_occur + 80;
                            if(start < 0){
                                start = 0;
                            }
                            if(start == 0){
                                end = 50;
                            }
                            if(end > content.length){
                                end = content.length;
                            }
                            var match_content = content.substring(start, end);
                            // highlight all keywords
                            keywords.forEach(function(keyword){
                                var regS = new RegExp(keyword, "gi");
                                match_content = match_content.replace(regS, "<b class=\"search-keyword\">"+keyword+"</b>");
                            });
                            
                            str += "<p class=\"search-result\">" + match_content +"...</p>"
                        }
                        str += "</li>";
                    }
                })};
                str += "</ul>";
                if (matchcounts == 0) { str = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>' }
                if (keywords == "") { str = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>' }
                $resultContent.innerHTML = str;
            });
            proceedsearch();
        }
    });}

    // handle and trigger popup window;
    $('.popup-trigger').mousedown(function(e) {
      e.stopPropagation();
      if (isfetched == false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };

    });

    $('.popup-btn-close').click(function(e){
      $('.popup').hide();
      $(".popoverlay").remove();
      $('body').css('overflow', '');
    });
    $('.popup').click(function(e){
      e.stopPropagation();
    });
  </script>

  

  

  

</body>
</html>
