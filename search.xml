<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[a]]></title>
      <url>http://carryguan.com/2017/09/17/a/</url>
      <content type="html"></content>
    </entry>
    
    <entry>
      <title><![CDATA[隐藏元素display与visibility的区别]]></title>
      <url>http://carryguan.com/2017/07/07/%E9%9A%90%E8%97%8F%E5%85%83%E7%B4%A0/</url>
      <content type="html"><![CDATA[<p>最近项目中涉及到节点隐藏的问题，发现自己不太了解，趁热打铁，我们一起来学习一下吧！<br>着重讲一下 display和visibility在隐藏元素时候的区别:</p>
<h1 id="属性说明"><a href="#属性说明" class="headerlink" title="属性说明"></a>属性说明</h1><ul>
<li>display:none<br>隐藏元素时：渲染树不构建元素，通俗说，页面没有这个节点，所以其不占位置空间<a id="more"></a></li>
<li>visibility:hidden<br> 隐藏元素时：渲染树构建元素（页面有这个节点）但是不渲染出来，页面上不可见这个元素，但是会占空间</li>
</ul>
<hr>
<h1 id="例如"><a href="#例如" class="headerlink" title="例如"></a>例如</h1><p><img src="http://upload-images.jianshu.io/upload_images/2377897-15007a1f549aa94e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h2 id="点击display-none-红色方块不见了"><a href="#点击display-none-红色方块不见了" class="headerlink" title="点击display:none,红色方块不见了"></a>点击display:none,红色方块不见了</h2><p><img src="http://upload-images.jianshu.io/upload_images/2377897-8b5de54bf8f747c4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h2 id="点击-visibility"><a href="#点击-visibility" class="headerlink" title="点击 visibility"></a>点击 visibility</h2><p><img src="http://upload-images.jianshu.io/upload_images/2377897-71652ba59b060d9e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<hr>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>如果想让某一段代码在前台不显示，最简单的方法是用css的display:none,这样，下边的内容就自动填补这个空隙。但是在一些特殊的情况下，我们只需要隐藏这个元素，但它的位置不能被占用了，那么，visibility:hidden就可以实现这个要求。</p>
<hr>
<h1 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line"> &lt;html&gt;</span><br><span class="line">    &lt;head&gt;</span><br><span class="line">        &lt;title&gt;Hello, World&lt;/title&gt;</span><br><span class="line">        &lt;link rel=&quot;stylesheet&quot; href=&quot;/style.css&quot;&gt;</span><br><span class="line">    &lt;style type=&quot;text/css&quot;&gt;</span><br><span class="line">      #one&#123;</span><br><span class="line">        background-color: pink;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line">      #two&#123;</span><br><span class="line"></span><br><span class="line">        background-color: red;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line">      #three&#123;</span><br><span class="line"></span><br><span class="line">        background-color: blue;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line">       #four&#123;</span><br><span class="line"></span><br><span class="line">        background-color: green;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line">       #five&#123;</span><br><span class="line"></span><br><span class="line">        background-color: orange;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line">      .wh&#123;</span><br><span class="line">        width: 100px;</span><br><span class="line">        height: 100px;</span><br><span class="line">        margin: 20px;</span><br><span class="line">      &#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">    &lt;/head&gt;</span><br><span class="line">    &lt;body&gt;</span><br><span class="line">   &lt;div id = &quot;one&quot; class=&quot;wh&quot;&gt;这是第一个&lt;/div&gt;</span><br><span class="line">   &lt;div id = &quot;two&quot; class=&quot;wh&quot;&gt;被隐藏方式为：display = &quot;none&quot;&lt;/div&gt;</span><br><span class="line">   &lt;div id = &quot;three&quot; class=&quot;wh&quot;&gt;第三个&lt;/div&gt;</span><br><span class="line">   &lt;div id = &quot;four&quot; class=&quot;wh&quot;&gt;被隐藏2方式为：visibility = &quot;hidden&quot;&lt;/div&gt;</span><br><span class="line">   &lt;div id = &quot;five&quot; class=&quot;wh&quot;&gt;第三个&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">   &lt;button id = &quot;btn1&quot;&gt;display:none&lt;/button&gt;</span><br><span class="line">   &lt;button id = &quot;btn2&quot;&gt;visibility:hidden&lt;/button&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &lt;/body&gt;</span><br><span class="line">  &lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">    var btn1 = document.getElementById(&quot;btn1&quot;);</span><br><span class="line">    var btn2 = document.getElementById(&quot;btn2&quot;);</span><br><span class="line">    var two = document.getElementById(&quot;two&quot;);</span><br><span class="line">    var four = document.getElementById(&quot;four&quot;);</span><br><span class="line"></span><br><span class="line">    btn1.onclick = function()&#123;</span><br><span class="line">      if(two.style.display === &quot;none&quot;)&#123;</span><br><span class="line">        two.style.display = &quot;block&quot;;</span><br><span class="line">      &#125;else&#123;</span><br><span class="line">        two.style.display = &quot;none&quot;;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    btn2.onclick = function()&#123;</span><br><span class="line">      if(four.style.visibility === &quot;visible&quot;)&#123;</span><br><span class="line">        four.style.visibility = &quot;hidden&quot;;</span><br><span class="line">      &#125;else&#123;</span><br><span class="line">        four.style.visibility = &quot;visible&quot;;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &lt;/script&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[动态生成dom事件失效]]></title>
      <url>http://carryguan.com/2017/06/03/%E5%8A%A8%E6%80%81%E7%94%9F%E6%88%90dom%E4%BA%8B%E4%BB%B6%E5%A4%B1%E6%95%88/</url>
      <content type="html"><![CDATA[<p><img src="http://upload-images.jianshu.io/upload_images/2377897-6150a13b12b6623a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h2 id="问题来由"><a href="#问题来由" class="headerlink" title="问题来由"></a>问题来由</h2><p>最近在项目中有涉及到排序后回写按钮元素，按钮的事件失效。<br>这可以分为一类问题：重写元素/动态生成元素后，事件的失效。<br>想给每一行的 td&gt;button添加点击事件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;td class=&quot;action&quot;&gt;</span><br><span class="line">     &lt;button class=&quot;mark&quot; name=&quot;ignore&quot; &gt; &lt;/button&gt;       </span><br><span class="line">&lt;/td&gt;</span><br></pre></td></tr></table></figure></p>
<p>给表格数据排序后，表格中的按钮事件失效。追溯了一下原因，排序后，初始化事件无法获取到button.<br>类似问题：</p>
<ul>
<li>动态增加删除子节点</li>
<li>表格排序后的节点<a id="more"></a>
<h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2></li>
</ul>
<blockquote>
<p>原理是利用冒泡实现事件委托，也就是给生成节点的父节点预先绑定事件。</p>
</blockquote>
<h3 id="jq的解决办法："><a href="#jq的解决办法：" class="headerlink" title="jq的解决办法："></a>jq的解决办法：</h3><p>$(‘.tablesort’).on(‘click’,’.mark’,function () {})<br>这里提一下：<br>早期对页面上后期加载的动态元素,赋事件或值的时候,是使用live的.<br> 由于效率比较低(其实数据不多也感觉不出来),后面使用delegate委托来代替了,<br>再后面,1.7以后使用on 来代替delegate了. live,delegate在新版本中都还可以用<br>网上有很多教程是利用 $(‘.action .mark’).live(‘click’,function () {})，但是现在不建议使用<br><a href="http://www.jb51.net/article/105869.htm" target="_blank" rel="external">参考</a></p>
<h3 id="原生js"><a href="#原生js" class="headerlink" title="原生js"></a>原生js</h3><p><a href="http://www.jianshu.com/p/88164e43d7b3" target="_blank" rel="external">http://www.jianshu.com/p/88164e43d7b3</a></p>
<ul>
<li>使用这个事件对象给父节点绑定事件</li>
<li>当事件触发的时候判断事件源对象是否是按钮</li>
<li>如果是按钮的话再执行事件行为</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[git常用命令]]></title>
      <url>http://carryguan.com/2017/04/27/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
      <content type="html"><![CDATA[<p><img src="http://upload-images.jianshu.io/upload_images/2377897-a8c62584774ba542.JPG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="A7BB8518D944E893213CFB6274266A8D.JPG"></p>
<h1 id="git-流程"><a href="#git-流程" class="headerlink" title="git 流程"></a>git 流程</h1><p>git status<br>git add .<br>git commit<br>git pull<br>git push origin branchName:refs/for/branchName<br>git pull<br><a id="more"></a></p>
<h1 id="create-branch"><a href="#create-branch" class="headerlink" title="create branch"></a>create branch</h1><p>git checkout -b featureOne<br>git push —set-upstream origin featureOne<br>git add .<br>git commit -m ‘msg’<br>git pull<br>git push origin featureOne:refs/for/featureOne<br>git pull</p>
<h1 id="merge-to-master"><a href="#merge-to-master" class="headerlink" title="merge to master"></a>merge to master</h1><p>git checkout master<br>git merge featureOne<br>git add .<br>git commit -m ‘merge’<br>git pull<br>git push origin master:refs/for/master<br>git pull</p>
<p>done</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[操作系统实验]]></title>
      <url>http://carryguan.com/2017/03/20/os/</url>
      <content type="html"><![CDATA[<h1 id="操作系统实验总结"><a href="#操作系统实验总结" class="headerlink" title="操作系统实验总结"></a>操作系统实验总结</h1><h2 id="实验源码"><a href="#实验源码" class="headerlink" title="实验源码"></a><a href="https://github.com/sunningcarryhaha" target="_blank" rel="external">实验源码</a></h2><ul>
<li>实验一 进程控制 processProject </li>
<li>实验二  分页式存储管理 changeAdress</li>
<li>实验三 页面置换算法 pageDispatch</li>
<li>实验四  进程调度算法 dispachPro</li>
</ul>
<hr>
<h2 id="实验一：进程调度-processProject"><a href="#实验一：进程调度-processProject" class="headerlink" title="实验一：进程调度 processProject"></a>实验一：进程调度 processProject</h2><p><img src="http://upload-images.jianshu.io/upload_images/2377897-b6aaedeba9ad2a15.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<h3 id="实验过程："><a href="#实验过程：" class="headerlink" title="实验过程："></a>实验过程：</h3><ul>
<li>定义数据结构pcb和相应的队列（入，出，显示）操作</li>
<li>编写函数：<pre><code>创建进程（-就绪），
进程调度（就绪-执行），
进程阻塞（执行-阻塞），
进程激活（阻塞-就绪），
时间片用完（执行-就绪）
</code></pre></li>
<li>输入相应的字母，进行相应操作</li>
</ul>
<a id="more"></a>
<p><img src="http://upload-images.jianshu.io/upload_images/2377897-d3abb5576e2dae6b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<h3 id="运行代码-实验源码"><a href="#运行代码-实验源码" class="headerlink" title="运行代码 实验源码"></a>运行代码 <a href="https://github.com/sunningcarryhaha" target="_blank" rel="external">实验源码</a></h3><p>命令行输入 </p>
<h4 id="node-test3-js"><a href="#node-test3-js" class="headerlink" title="node test3.js"></a>node test3.js</h4><hr>
<h2 id="实验二：分页式存储管理-changeAdress"><a href="#实验二：分页式存储管理-changeAdress" class="headerlink" title="实验二：分页式存储管理 changeAdress"></a>实验二：分页式存储管理 changeAdress</h2><h3 id="目的"><a href="#目的" class="headerlink" title="目的 :"></a>目的 :</h3><p>分页式存储管理系统是内存非连续存储管理中基本的方法，可以通过把一个作业分成多个页面分配到不连续的内存块中去。实验可以通过位示图的方式来模拟内存的使用情况，为每个作业建立页表用于完成正确的地址转换。</p>
<h3 id="内容和步骤："><a href="#内容和步骤：" class="headerlink" title="内容和步骤："></a>内容和步骤：</h3><p>利用键盘输入本模拟系统的物理块的大小，作业的页表中的块号；完成逻辑地址转换成相应的物理地址的过程。</p>
<h3 id="具体过程："><a href="#具体过程：" class="headerlink" title="具体过程："></a>具体过程：</h3><ul>
<li>建立一张位示图，用来模拟内存的分配情况，利用随机数产生一组0和1的数对应内存的使用情况。</li>
<li>输入块（页）的大小，通过模拟位示图为本作业分配内存空间建立相应的页表（长度不定）；</li>
<li>录入逻辑地址转换成相应的物理地址</li>
</ul>
<h3 id="运行代码-实验源码-1"><a href="#运行代码-实验源码-1" class="headerlink" title="运行代码 实验源码"></a>运行代码 <a href="https://github.com/sunningcarryhaha" target="_blank" rel="external">实验源码</a></h3><p>命令行输入</p>
<h4 id="node-main-js"><a href="#node-main-js" class="headerlink" title="node main.js"></a>node main.js</h4><p><img src="http://upload-images.jianshu.io/upload_images/2377897-80700832d08db17d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<hr>
<h2 id="实验三-页面置换算法-pageDispatch"><a href="#实验三-页面置换算法-pageDispatch" class="headerlink" title="实验三 页面置换算法 pageDispatch"></a>实验三 页面置换算法 pageDispatch</h2><h3 id="目的："><a href="#目的：" class="headerlink" title="目的："></a>目的：</h3><p>实现请求页式地址转换中出现的缺页现象中，用到的先进先出FIFO、最近最久未使用LRU、最佳OPT置换算法。熟悉文件的基本操作（读、写）。</p>
<h3 id="内容和步骤：-1"><a href="#内容和步骤：-1" class="headerlink" title="内容和步骤："></a>内容和步骤：</h3><p>利用键盘输入本模拟系统分配给作业的内存物理块个数，作业在执行过程中的页面调度次序。计算出三种算法的缺页次数和缺页率。</p>
<h3 id="OPT-FIFO-LRU"><a href="#OPT-FIFO-LRU" class="headerlink" title="OPT ,FIFO ,LRU"></a>OPT ,FIFO ,LRU</h3><ul>
<li>OPT :(最佳置换算法) 将内存块里面找到未来最晚出现的值（某值将来第一次出现的下标）,删掉</li>
<li>FIFO：（first in first out）将内存块中最早进的最早删了</li>
<li>LRU：(least recently used) 最近最少使用</li>
</ul>
<h3 id="具体过程：-1"><a href="#具体过程：-1" class="headerlink" title="具体过程："></a>具体过程：</h3><p>１、输入分配给本作业的块数，模拟作业执行的逻辑地址转换成页面调度次序；<br>２、分别采用OPT、FIFO、LRU置换算法，利用堆栈结构完成页面置换；记录被换出的页面和新换入的页面。<br>３、将得到的结果写入到文本文件中。</p>
<h3 id="执行结果"><a href="#执行结果" class="headerlink" title="执行结果"></a>执行结果</h3><p><img src="http://upload-images.jianshu.io/upload_images/2377897-ae8ad77a4cd48b5b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/2377897-aa36a5dc63ad68e9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<hr>
<h2 id="实验四-进程调度算法-dispachPro"><a href="#实验四-进程调度算法-dispachPro" class="headerlink" title="实验四  进程调度算法 dispachPro"></a>实验四  进程调度算法 dispachPro</h2><h3 id="目的：-1"><a href="#目的：-1" class="headerlink" title="目的："></a>目的：</h3><p>在实验一的基础上实现先来先服务FCFS、短作业优先ＳＪＦ以及时间片轮转调度算法。<br>（五）实验内容与步骤：<br>我们可以根据创建进程的系统时钟，取相对时钟作为进程的到达时间，利用随机数产生每个进程的估计运行时间。利用模拟系统中提供的算法分别计算其相应的周转时间和带权周转时间。</p>
<h3 id="过程："><a href="#过程：" class="headerlink" title="过程："></a>过程：</h3><ul>
<li>利用绝对时间和相对时钟产生一组进程的到达时刻和运行时间。</li>
<li>实现FCFS算法：(First Come First Served )先来先服务</li>
<li>实现ＳＪＦ算法：（Shortest Job First）短工作优先</li>
<li>实现时间片轮转算法：首先要求确定时间片的大小，依据进程的到达时间依次加入队列，每次分配一个时间片大小的时间，如果没有完成参与下一次的竞争，当最后需要一个小于等于时间片的时间时本进程完成，同时退出队列。</li>
<li>计算每种算法调度后，系统的平均周转时间和平均带权周转时间。<h3 id="执行"><a href="#执行" class="headerlink" title="执行"></a>执行</h3></li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/2377897-e28908a8a5d10683.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/2377897-a8c0d09589d38630.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/2377897-ed7ca4d9e4dd5843.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<hr>
<blockquote>
<p>希望有更多小胖友提出宝贵意见,若有关于前端的问题，或者关于大学方面的感想可以私聊我(^~^)：<br><a href="https://github.com/sunningcarryhaha" target="_blank" rel="external">github</a><br><a href="https://www.zhihu.com/people/guan-kai-li-88" target="_blank" rel="external">知乎</a><br><a href="http://www.jianshu.com/users/0293a04839f0/latest_articles" target="_blank" rel="external">简书</a><br><a href="https://carryguan.me/" target="_blank" rel="external">个人博客</a><br><a href="http://weibo.com/u/5048785433/home?wvr=5" target="_blank" rel="external">微博</a></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[playFair算法-古典密码学]]></title>
      <url>http://carryguan.com/2017/02/20/playFair/</url>
      <content type="html"><![CDATA[<blockquote>
<p>Playfair密码（英文：Playfair cipher 或 Playfair square）是一种替换密码，1854年由查尔斯·惠斯通（Charles Wheatstone）的英国人发明。经莱昂·普莱费尔提倡在英国军地和政府使用。　</p>
</blockquote>
<p>   PlayFair算法是古典密码学中的多表代替算法.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># PlayFair算法分以下几步：</span><br><span class="line">1：将给出的密钥去重与26个字母拼接成后，生成5X5的矩阵也称作密码表（矩阵中I和J位置相同）</span><br><span class="line">2：将明文两个两个为一对儿</span><br><span class="line">3：利用加密方法来将明文加密</span><br></pre></td></tr></table></figure></p>
<p>加密方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">P1、P2同行：</span><br><span class="line">对应的C1和C2分别是紧靠P1、P2右端的字母。其中第一列被看作是最后一列的右方。（解密时反向）</span><br><span class="line">P1、P2同列：</span><br><span class="line">对应的C1和C2分别是紧靠P1、P2下方的字母。其中第一行看作是最后一行的下方。（解密时反向）</span><br><span class="line">P1、P2不同行、不同列：</span><br><span class="line">C1和C2是由P1和P2确定的矩形的其它两角的字母，并且C1和P1、C2和P2同行。（解密时处理方法相同）</span><br><span class="line">P1＝P2：</span><br><span class="line">则插入一个字母于重复字母之间，并用前述方法处理</span><br><span class="line">若明文字母数为奇数时：</span><br><span class="line">则在明文的末端添加某个事先约定的字母作为填充</span><br></pre></td></tr></table></figure></p>
<a id="more"></a>
<h1 id="举例说明"><a href="#举例说明" class="headerlink" title="举例说明"></a>举例说明</h1><p><img src="http://upload-images.jianshu.io/upload_images/2377897-12c2fb222130656b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<h2 id="这是demo-可以点击"><a href="#这是demo-可以点击" class="headerlink" title="这是demo,可以点击"></a>这是demo,可以点击</h2><h2 id="demo"><a href="#demo" class="headerlink" title="demo"></a><a href="http://carryguan.me/PlayFair/first.html" target="_blank" rel="external">demo</a></h2><h1 id="实验代码"><a href="#实验代码" class="headerlink" title="实验代码"></a>实验代码</h1><h2 id="JS"><a href="#JS" class="headerlink" title="JS"></a>JS</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br></pre></td><td class="code"><pre><span class="line">var skid = document.getElementById(&quot;secretKey&quot;);</span><br><span class="line">var secretKey = &apos; &apos;;</span><br><span class="line">var arr = new Array();//拆分密钥字符串</span><br><span class="line">var sk = new Array();</span><br><span class="line">var keyTable = new Array();</span><br><span class="line">var ekid = document.getElementById(&quot;expressWords&quot;);</span><br><span class="line">var expressKey = ekid.value</span><br><span class="line">var arrEK = new Array();</span><br><span class="line">var secretWords = new Array();</span><br><span class="line">/*</span><br><span class="line">第一步：定义密钥一维数组，并将密钥去重</span><br><span class="line">*/</span><br><span class="line">//去重函数</span><br><span class="line">Array.prototype.unique = function()</span><br><span class="line">&#123;</span><br><span class="line">  var n = &#123;&#125;,r=[]; //n为键值对集合，r为临时数组</span><br><span class="line">  for(var i = 0; i &lt; this.length; i++) //遍历当前数组</span><br><span class="line">  &#123;</span><br><span class="line">    if (!n[this[i]]) //如果表中没有当前项</span><br><span class="line">    &#123;</span><br><span class="line">      n[this[i]] = true; //存入表</span><br><span class="line">      r.push(this[i]); //把当前数组的当前项push到临时数组里面</span><br><span class="line">      //console.log(n);</span><br><span class="line">      sk.push(this[i]);   </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  return r;   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">第二步，创建密码表,用去重后的密钥和26个英文字母创建</span><br><span class="line">*/</span><br><span class="line">function createKey(sk)&#123;</span><br><span class="line">    //字母顺序数组</span><br><span class="line">    var allChars = [&apos;A&apos;,&apos;B&apos;,&apos;C&apos;,&apos;D&apos;,&apos;E&apos;,&apos;F&apos;,&apos;G&apos;,&apos;H&apos;,&apos;I&apos;||&apos;J&apos;,&apos;K&apos;,&apos;L&apos;,&apos;M&apos;,&apos;N&apos;,&apos;O&apos;,&apos;P&apos;,&apos;Q&apos;,&apos;R&apos;,&apos;S&apos;,&apos;T&apos;,&apos;U&apos;,&apos;V&apos;,&apos;W&apos;,&apos;X&apos;,&apos;Y&apos;,&apos;Z&apos;];</span><br><span class="line">    //删除去重后的密钥在26字母中的值</span><br><span class="line">    for(var i = 0 ;i&lt;sk.length;i++)&#123;</span><br><span class="line">        var index = allChars.indexOf(sk[i]);</span><br><span class="line">        if (index &gt; -1) &#123;</span><br><span class="line">            allChars.splice(index, 1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //将未出现过的26个字母与去重密钥合并成密码表一维数组</span><br><span class="line">    allChars = sk.concat(allChars);</span><br><span class="line">    //将一维数组转成二维</span><br><span class="line">    for(var i = 0 ; i&lt;5 ; i++)&#123;</span><br><span class="line">        keyTable[i] = new Array();</span><br><span class="line">        for(var j = 0;j&lt;5;j++)&#123;</span><br><span class="line">            keyTable[i][j] = allChars[i*5+j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   // console.log(&apos;keyTablellll:&apos;+keyTable[3][3]);</span><br><span class="line">&#125;    </span><br><span class="line">/*</span><br><span class="line">第三步：处理明文  ，将明文两个两个为一对,并且将明文中的J换成I</span><br><span class="line">*/</span><br><span class="line">function produceExpress(e)&#123;</span><br><span class="line">    //console.log(&apos;e：&apos;+e);</span><br><span class="line">    var arr = e.split(&apos;&apos;);</span><br><span class="line">    if(arr.length%2==0)&#123;</span><br><span class="line">        for(var i=0 ; i&lt;arr.length;i++)&#123;</span><br><span class="line">          if(arr[i] == &apos;J&apos;)&#123;</span><br><span class="line">            arr[i] = &apos;I&apos;;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for(var i=0 ; i&lt;arr.length;i++)&#123;</span><br><span class="line">          arrEK.push([arr[i],arr[i+1]]);</span><br><span class="line">          i = i+1;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        arrEK.push(&apos;X&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">    for(var i = 0;i&lt;7;i++)&#123;</span><br><span class="line">        console.log(&apos;arrEKllll:&apos;+arrEK[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> 第四步：利用playfair算法，求出密文</span><br><span class="line">*/</span><br><span class="line">function getSecret(a,b)&#123;</span><br><span class="line">    //a为密码表</span><br><span class="line">    //b为分组后的明文</span><br><span class="line">    var secretTable = [];</span><br><span class="line">    var express = [];</span><br><span class="line">    secretTable = a;</span><br><span class="line">    express = b;</span><br><span class="line">    var p1,p2,c1,c2;</span><br><span class="line">    var row1,col1,row2,col2;</span><br><span class="line">    for(var k =0;k&lt;express.length;k++)&#123;</span><br><span class="line">        for(var i = 0;i&lt;secretTable.length;i++)&#123;</span><br><span class="line">          for(var j=0;j&lt;secretTable[i].length;j++)&#123;</span><br><span class="line">            if(express[k][0] == secretTable[i][j])&#123;</span><br><span class="line">                row1=i;</span><br><span class="line">                col1=j;</span><br><span class="line">            &#125;</span><br><span class="line">            if(express[k][1] == secretTable[i][j])&#123;</span><br><span class="line">                row2=i;</span><br><span class="line">                col2=j;</span><br><span class="line">            &#125; </span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(row1 == row2)&#123;</span><br><span class="line">            secretWords.push(secretTable[row1][(col1+1)%5]);</span><br><span class="line">            secretWords.push(secretTable[row1][(col2+1)%5])</span><br><span class="line">        &#125;else if (col1 == col2)&#123;</span><br><span class="line">            secretWords.push(secretTable[(row1+1)%5][col1]);</span><br><span class="line">            secretWords.push(secretTable[(row2+1)%5][col1]);</span><br><span class="line"></span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            //不同行不同列</span><br><span class="line">            secretWords.push(secretTable[row1][col2]);</span><br><span class="line">            secretWords.push(secretTable[row2][col1]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function main()&#123;</span><br><span class="line">    var a = document.getElementById(&apos;secretWords&apos;);</span><br><span class="line">    var btn = document.getElementById(&apos;button&apos;);</span><br><span class="line">    btn.addEventListener(&apos;click&apos;,function()&#123;</span><br><span class="line">        //a.value = secretWords.toString();</span><br><span class="line">        if(skid.value!= &apos; &apos;)&#123;</span><br><span class="line">           secretKey =  skid.value.toUpperCase();</span><br><span class="line">           arr = secretKey.split(&apos;&apos;);</span><br><span class="line">        &#125;</span><br><span class="line">        if(ekid.value!= &apos; &apos;)&#123;</span><br><span class="line">           expressKey = ekid.value.toUpperCase();</span><br><span class="line">        &#125;</span><br><span class="line">        arr.unique();</span><br><span class="line">        console.log(&apos;quchonghou:&apos;+sk);</span><br><span class="line">        //创建密码表为keyTable</span><br><span class="line">        createKey(sk);</span><br><span class="line">        console.log(&apos;-----------------------------&apos;);</span><br><span class="line">        for(var i = 0;i&lt;5;i++)&#123;</span><br><span class="line">           console.log(&apos;keyTable:&apos;+keyTable[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        console.log(&apos;-----------------------------&apos;);</span><br><span class="line">        //处理明文后为arrEK</span><br><span class="line">        produceExpress(expressKey);</span><br><span class="line">        console.log(&apos;mingwen:&apos;+arrEK);</span><br><span class="line">        //求密文secretWords</span><br><span class="line">        getSecret(keyTable,arrEK);</span><br><span class="line">        console.log(&apos;secretWords:&apos;+secretWords);</span><br><span class="line">        a.value = secretWords.toString();</span><br><span class="line"></span><br><span class="line">    &#125;);</span><br><span class="line">        </span><br><span class="line">&#125;</span><br><span class="line">main();</span><br></pre></td></tr></table></figure>
<h2 id="html"><a href="#html" class="headerlink" title="html"></a>html</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html &gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;playfair加密算法&lt;/title&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">      body&#123;</span><br><span class="line">            font-family: &apos;Open Sans&apos;, sans-serif;</span><br><span class="line">            font-size: 20px;</span><br><span class="line">            line-height: 1.42857143;</span><br><span class="line">            color: #fff;</span><br><span class="line">            background-color: #F39D7C;</span><br><span class="line">      &#125;</span><br><span class="line">      #container&#123;</span><br><span class="line">        width: 500px;</span><br><span class="line">        height: 500px;</span><br><span class="line">        margin:0 auto;</span><br><span class="line">        background-color: #2A1106;</span><br><span class="line">        border-radius: 50px;</span><br><span class="line">        margin-top:100px;</span><br><span class="line">        box-shadow: 0 0 15px #F13006;</span><br><span class="line">        </span><br><span class="line">       &#125;</span><br><span class="line">       #container&#123;</span><br><span class="line">          display: flex;</span><br><span class="line">          flex-direction: column;</span><br><span class="line">          justify-content: space-between;</span><br><span class="line">          align-items: center;</span><br><span class="line">       &#125;</span><br><span class="line">       input&#123;</span><br><span class="line">        width: 200px;</span><br><span class="line">        height: 30px;</span><br><span class="line">       &#125;</span><br><span class="line">       #button&#123;</span><br><span class="line">        width: 80px;</span><br><span class="line">        height: 35px;</span><br><span class="line">        background: #ef9a79;</span><br><span class="line">        font-size: 15px;</span><br><span class="line">        border:none; </span><br><span class="line">        border-radius: 3px;</span><br><span class="line">       &#125;</span><br><span class="line">       #button:hover&#123;</span><br><span class="line">          background: #f47c20;</span><br><span class="line">       &#125;</span><br><span class="line">      </span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;!-- top-start --&gt;</span><br><span class="line">    &lt;div id=&quot;container&quot;&gt;</span><br><span class="line">        &lt;h1&gt;playFair加密算法&lt;/h1&gt;  </span><br><span class="line">        &lt;span&gt;输入密钥:&lt;/span&gt;&lt;input type=&quot;text&quot; id=&quot;secretKey&quot; name=&quot;secretKey&quot; value=&quot;&quot;&gt;</span><br><span class="line"></span><br><span class="line">        &lt;span&gt;输入明文:&lt;/span&gt;</span><br><span class="line">        &lt;input type=&quot;text&quot; id=&quot;expressWords&quot; name=&quot;expressWords&quot; value=&quot;&quot;&gt;</span><br><span class="line">        &lt;span&gt;输出密文:&lt;/span&gt;</span><br><span class="line">        &lt;input type=&quot;text&quot; id=&quot;secretWords&quot; name=&quot;secretWords&quot;value=&quot;&quot;&gt;</span><br><span class="line">        &lt;button id =&quot;button&quot; type=&quot;submit&quot; &gt;加密&lt;/button&gt;</span><br><span class="line">        &lt;p id=&quot;demo&quot;&gt;&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">     &lt;script src=&quot;first.js&quot; &gt;</span><br><span class="line"></span><br><span class="line">     &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[JS进阶以及重要知识点]]></title>
      <url>http://carryguan.com/2016/12/05/js%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
      <content type="html"><![CDATA[<p><img src="http://upload-images.jianshu.io/upload_images/2377897-2a12c8caef6e4f37.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>(原谅博主carry比较变态，在博文加了歌曲，不想听歌的小胖友们可以到博文底部关闭 ^~^)</p>
<h2 id="前端进阶-（以下是豪大大的干货）"><a href="#前端进阶-（以下是豪大大的干货）" class="headerlink" title="前端进阶: （以下是豪大大的干货）"></a>前端进阶: （以下是豪大大的干货）</h2><p><a href="http://www.cnblogs.com/jikey/p/3600308.html" target="_blank" rel="external">第一阶段</a><br><a href="http://www.cnblogs.com/jikey/p/3601666.html" target="_blank" rel="external">第二阶段</a><br><a href="http://www.cnblogs.com/jikey/p/3604459.html" target="_blank" rel="external">第三阶段</a><br><a href="http://www.cnblogs.com/jikey/p/3607133.html" target="_blank" rel="external">第四阶段</a><br><a href="http://www.cnblogs.com/jikey/p/3611394.html" target="_blank" rel="external">第五阶段</a><br><a href="http://www.cnblogs.com/jikey/p/3632392.html" target="_blank" rel="external">第六阶段</a><br><a id="more"></a></p>
<hr>
<p>本文目前依据是菜鸟教程：<br><a href="http://www.runoob.com/js/js-functions.html" target="_blank" rel="external">JS菜鸟</a><br><a href="http://www.w3school.com.cn/js/index.asp" target="_blank" rel="external">JSw3c</a></p>
<hr>
<h2 id="JS基本编程语法"><a href="#JS基本编程语法" class="headerlink" title="JS基本编程语法"></a>JS基本编程语法</h2><p>变量<br>运算<br>流程控制<br>数组<br>调用函数<br>自定义函数<br>自定义对象<br>string对象原型(prototype)<br>this事件<br>json</p>
<hr>
<h2 id="JS函数"><a href="#JS函数" class="headerlink" title="JS函数"></a>JS函数</h2><p>函数定义<br>函数调用<br>函数的参数<br>闭包</p>
<hr>
<h2 id="JS-HTML-DOM"><a href="#JS-HTML-DOM" class="headerlink" title="JS HTML DOM"></a>JS HTML DOM</h2><p>目前来看都要</p>
<hr>
<h2 id="JS高级教程"><a href="#JS高级教程" class="headerlink" title="JS高级教程"></a>JS高级教程</h2><p>string,prototype<br>array<br>regExp<br>Boolean</p>
<hr>
<p>js继承(call,prototype,apply)//红皮书第六章<br>js的执行顺序<br>js事件机制(委托，绑定，监听，冒泡和阻止冒泡，兼容性)//红皮书13章<br>了解ajax的xmlhttprequest及其创建方法(多浏览器兼容)，跨域，明白其工作原理，http协议(get,post;如何传递参数，设置cookie)</p>
<hr>
<h2 id="前端学习计划推荐："><a href="#前端学习计划推荐：" class="headerlink" title="前端学习计划推荐："></a>前端学习计划推荐：</h2><blockquote>
<p>以下都是我从知乎里面找到的干货<br><img src="http://upload-images.jianshu.io/upload_images/2377897-e5c3d5a2eed28410.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
</blockquote>
<p>计算机行业很多都符合82定律，也就是20%的东西的使用频率占到80%，所以很适合囫囵吞枣，我们的重点就是把这20%学起来，而首先要做的就是把这20%的东西找出来。<br>在我看来前端这20%的东西大概就是常用的html标签，css的盒子模型，基本的原生js，以及熟练使用jquery，ajax，常见浏览器的兼容。<br>拿下这些东西意义非凡，一方面证明你适合做前端这份工作，另一方面这些技能能让你找到一份工作。让你能够从容地去学习剩下的80%。<br>总之就是专心对付最重要的东西，那些什么less、sass、angular这类的东西，当你把我之前说的基础打好之后，学习起来畅通无阻，随学随用。<br>最后我觉得最难的就是实践，只有实践才能学到真正的技术，新人很难参与一些有价值有意义的项目，没有这些项目又很难成长，所以自己有项目可参与应该珍惜，没项目应该多造一些有价值的轮子。</p>
<p>1.html的语法、格式，常用的标签极其作用，理解标签的嵌套，学习使用firefox+firebug或者chrom的调试工具，能够使用这些工具调试html、css、js、断点调试、抓包</p>
<p>2.如何引入css、js（有多少种方法，各种方法有什么区别），理解id、class属性的区别，学会css的常用选择器，理解盒子模型（padding，margin，border，width，height，），css坐标系，css布局（position的absolute、relative 、fixed、static），css浮动（float：left、right ）和清除浮动（clear）,display:inline、block、inline-block、flex</p>
<p>3.js的执行顺序，基本的编程基础（变量、运算、流程控制、数组、调用函数、自定义函数、对象）、json、js的dom操作、js的事件机制（委托、绑定、监听，冒泡和阻止冒泡，兼容性），了解ajax的xmlhttprequest及其创建方法（多浏览器兼容）、跨域，明白其工作原理，评论里有朋友说http协议，确实是我疏忽，在学习ajax这部分免不了需要懂点http协议，比如什么是get和post，这两种如何传递参数，设置cookie等</p>
<p>4、使用jquery解放你的开发工作，学会jq选择器，修改属性、监听事件、修改css，学会写jquery插件。这一步我觉得可以和第3步穿插学习</p>
<p>5、搭建服务器，弄个傻瓜服务器比如wamp，phpstudy等软件，可以一键建立一个apache+php+mysql的服务器，前期可以把你的静态页发布到本地服务器，使用本地服务器配合ajax学习。</p>
<p>6、学点服务器端，建议php+mysql  (博主学的是nodejs+mysql)<br>服务器端脚本其实很简单，总结起来就是4个东西：SESSION、COOKIE、Request、Response，结合http协议理解如何从Request取得数据，经过处理后Response给客户端。这就是整个过程。<br>至于mysql也就是基本的sql语句。如何使用php进行CURD操作。这块其实很难总结，基本上以实现业务为主。</p>
<p>7、来点框架，理解MVC模式、推荐个比较流行的MVC框架：ThinkPHP，简洁好用不解释，国人弄的，文档和例子什么的非常丰富。</p>
<hr>
<h2 id="博主感想"><a href="#博主感想" class="headerlink" title="博主感想"></a>博主感想</h2><p>希望有更多小胖友提出宝贵意见,若有关于前端的问题，或者关于大学方面的感想可以私聊我(^~^)：</p>
<p><a href="https://github.com/sunningcarryhaha" target="_blank" rel="external">github</a><br><a href="https://www.zhihu.com/people/guan-kai-li-88" target="_blank" rel="external">知乎</a><br><a href="http://www.jianshu.com/users/0293a04839f0/latest_articles" target="_blank" rel="external">简书</a><br><a href="http://weibo.com/u/5048785433/home?wvr=5" target="_blank" rel="external">微博</a></p>
<hr>
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="http://music.163.com/outchain/player?type=2&id=32737469&auto=1&height=66"></iframe>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Mysql-sql语法(入门)]]></title>
      <url>http://carryguan.com/2016/11/21/mysql%E8%AF%AD%E6%B3%95/</url>
      <content type="html"><![CDATA[<p><img src="http://ww2.sinaimg.cn/large/005vGbJ7jw1f671ikpgnhj30s20as0v3.jpg" alt="young"></p>
<ul>
<li>mysql-sql 语句  </li>
<li>字符集选utf-8</li>
<li>我需要学增删改查, 事物, 联合</li>
</ul>
<hr>
<h2 id="启动数据库"><a href="#启动数据库" class="headerlink" title="启动数据库"></a>启动数据库</h2><pre><code>
mysql -u root -p（root是用户名）
</code></pre>

<h2 id="查看数据库（所有）"><a href="#查看数据库（所有）" class="headerlink" title="查看数据库（所有）"></a>查看数据库（所有）</h2><pre><code>
show databases
</code></pre>
<a id="more"></a>

## 进入数据库
<pre><code>
use one ;
</code></pre>

<h2 id="展示当前数据库的所有表"><a href="#展示当前数据库的所有表" class="headerlink" title="展示当前数据库的所有表"></a>展示当前数据库的所有表</h2><pre><code>
show tables;
</code></pre>

<h2 id="创建个名为user的表的结构"><a href="#创建个名为user的表的结构" class="headerlink" title="创建个名为user的表的结构"></a>创建个名为user的表的结构</h2><pre><code>
create table user(
id int,
name  varchar(30),
pass varchar(30)
);（字符串长度最长是30）
</code></pre>

<h2 id="查看表结构"><a href="#查看表结构" class="headerlink" title="查看表结构"></a>查看表结构</h2><pre><code>
desc user; 
</code></pre>

<h2 id="查看数据从表里面"><a href="#查看数据从表里面" class="headerlink" title="查看数据从表里面"></a>查看数据从表里面</h2><pre><code>
select * from user;
</code></pre>

<h2 id="insert-增（我可以随意增加，插入数据到表中）"><a href="#insert-增（我可以随意增加，插入数据到表中）" class="headerlink" title="insert 增（我可以随意增加，插入数据到表中）"></a>insert 增（我可以随意增加，插入数据到表中）</h2><pre><code>
 insert into table(ct1,ct2,ct3) values(num,"str","str")
 insert into user(id,name,pass) values(1,"leiwei","123")
</code></pre>

<h2 id="形成了下表"><a href="#形成了下表" class="headerlink" title="形成了下表"></a>形成了下表</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from user;</span><br><span class="line">+------+-----------+------+</span><br><span class="line">| id   | name      | pass |</span><br><span class="line">+------+-----------+------+</span><br><span class="line">|    1 | leiwei    | 123  |</span><br><span class="line">|    2 | yujie     | 13   |</span><br><span class="line">|    3 | qiancheng | 456  |</span><br><span class="line">+------+-----------+------+</span><br><span class="line">3 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>
<h2 id="select-查（我可以随意查找-select-from-table-where…）"><a href="#select-查（我可以随意查找-select-from-table-where…）" class="headerlink" title="select 查（我可以随意查找 select from table where…）"></a>select 查（我可以随意查找 select from table where…）</h2><pre><code>
select * from user where id=2;
select * from user where pass=13;
</code></pre>

<h2 id="select-like-子段（-我可以随意选取子字段-）"><a href="#select-like-子段（-我可以随意选取子字段-）" class="headerlink" title="select like 子段（ 我可以随意选取子字段 ）"></a>select like 子段（ 我可以随意选取子字段 ）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">select * from user where name like &apos;%carry%&apos;;//选取中间含有carry字段的数据</span><br><span class="line">+------+----------+------+</span><br><span class="line">| id   | name     | pass |</span><br><span class="line">+------+----------+------+</span><br><span class="line">|    5 | carryone | 123  |</span><br><span class="line">|    2 | carry    | 571  |</span><br><span class="line">+------+----------+------+</span><br></pre></td></tr></table></figure>
<h3 id="选取以one结束的字段"><a href="#选取以one结束的字段" class="headerlink" title="选取以one结束的字段"></a>选取以one结束的字段</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">select * from user where name like &apos;%one&apos;;//</span><br><span class="line">+------+----------+------+</span><br><span class="line">| id   | name     | pass |</span><br><span class="line">+------+----------+------+</span><br><span class="line">|    5 | carryone | 123  |</span><br><span class="line">+------+----------+------+</span><br></pre></td></tr></table></figure>
<h2 id="select-order-by（排序我们可以随意排序数据）"><a href="#select-order-by（排序我们可以随意排序数据）" class="headerlink" title="select order by（排序我们可以随意排序数据）"></a>select order by（排序我们可以随意排序数据）</h2><pre><code>
        select * from user order by name; //默认是升序  
         select * from user order by id desc;//desc为降序排列
</code></pre>

<h2 id="delete-删-（我可以随意删除-delete-from-table-where…）"><a href="#delete-删-（我可以随意删除-delete-from-table-where…）" class="headerlink" title="delete 删 （我可以随意删除 delete from table where…）"></a>delete 删 （我可以随意删除 delete from table where…）</h2><pre><code>
delete from user where name="yujie";
delete from user where id=3;
</code></pre>

<h2 id="update-我可以随意更改-update-user-set-charct-where-…"><a href="#update-我可以随意更改-update-user-set-charct-where-…" class="headerlink" title="update (我可以随意更改 update user set charct where ….)"></a>update (我可以随意更改 update user set charct where ….)</h2><p><pre><code><br>update user set name=”billin” where id=1;<br>update user set id=5 where name=”billin”;<br></code></pre></p>
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="http://music.163.com/outchain/player?type=2&id=5179544&auto=1&height=66"></iframe>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[前端攻城狮的标准]]></title>
      <url>http://carryguan.com/2016/10/28/%E5%89%8D%E7%AB%AF%E6%94%BB%E5%9F%8E%E7%8B%AE%E7%9A%84%E6%A0%87%E5%87%86/</url>
      <content type="html"><![CDATA[<p><img src="http://upload-images.jianshu.io/upload_images/2377897-df83d5ec13fe30e8.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="logo"><br><a id="more"></a></p>
<h1 id="前端工程师该达到的要求"><a href="#前端工程师该达到的要求" class="headerlink" title="前端工程师该达到的要求"></a>前端工程师该达到的要求</h1><h2 id="1-基本功"><a href="#1-基本功" class="headerlink" title="1 基本功"></a>1 基本功</h2><p>HTML、CSS、JavaScript基本功，数学、算法、数据结构、操作系统、编译原理基本功。</p>
<h2 id="2-资源请求"><a href="#2-资源请求" class="headerlink" title="2 资源请求"></a>2 资源请求</h2><p>了解 DNS 解析，充分利用 CDN，使用多个域名来完成资源的请求以缩短加载时间；</p>
<p>##3 http<br>设置 HTTP Headers（Expires, Cache-Control, If-Modified-Since）；</p>
<h2 id="4-遵循hpw规则"><a href="#4-遵循hpw规则" class="headerlink" title="4 遵循hpw规则"></a>4 遵循hpw规则</h2><p>遵循 Steve Souders 给出的全部规则（High Performance Websites）</p>
<h2 id="5-解决显示的问题"><a href="#5-解决显示的问题" class="headerlink" title="5 解决显示的问题"></a>5 解决显示的问题</h2><p>知道如何解决 PageSpeed、YSlow、Chrome Dev Tools Audit、Chrome Dev Tools Timeline 显示的所有问题；</p>
<h2 id="6-服务端与客户端"><a href="#6-服务端与客户端" class="headerlink" title="6 服务端与客户端"></a>6 服务端与客户端</h2><p>知道什么任务该放在服务端，什么任务该放在客户端；</p>
<h2 id="7-缓存"><a href="#7-缓存" class="headerlink" title="7 缓存"></a>7 缓存</h2><p>知道使用缓存，DNS 预取和资源预加载技巧；</p>
<h2 id="8-js良好学习与利用能力"><a href="#8-js良好学习与利用能力" class="headerlink" title="8 js良好学习与利用能力"></a>8 js良好学习与利用能力</h2><p>精通 JavaScript，知道何时自己写何时借组别人的框架或代码，优劣明辨；</p>
<h2 id="9-框架，库，工具"><a href="#9-框架，库，工具" class="headerlink" title="9 框架，库，工具"></a>9 框架，库，工具</h2><p>熟练使用现代 MVC JavaScript 框架（例如 AngularJS EmberJS React 等），图形库（D3、SnapSVG 等），DOM 操作类库（jQuery、Zepto 等），惰性加载或者模块管理类库（例如 RequireJS、CommonJS 等），任务调用工具（例如 Grunt Gulp 等），包管理工具（Bower Componentjs）以及测试工具（Protractor、Selenium 等）；</p>
<h2 id="10-图片"><a href="#10-图片" class="headerlink" title="10 图片"></a>10 图片</h2><p>掌握图片的格式，每种格式的优点，适用的场景；知道图片优化技巧以及加载策略（雪碧图、懒加载、缓存刷新以及 PNG 交错）；</p>
<h2 id="11-css"><a href="#11-css" class="headerlink" title="11:css"></a>11:css</h2><p>熟悉 CSS 标准、最新的转换工具积极策略规范（比如 BEM、SMACSS、OOCSS 等）；</p>
<h2 id="12：js-的计算机科学"><a href="#12：js-的计算机科学" class="headerlink" title="12：js 的计算机科学"></a>12：js 的计算机科学</h2><p>JavaScript 的计算机科学（内存管理、单进程特性、垃圾回收算法、定时器、作用域、提升以及设计模式）。</p>
<h2 id="13-Web前端开发标准"><a href="#13-Web前端开发标准" class="headerlink" title="13 Web前端开发标准"></a>13 Web前端开发标准</h2><p><a href="http://codecloud.net/5622.html" target="_blank" rel="external">web前端开发标准</a></p>
<hr>
<p> #博主感想</p>
<p>希望有更多小胖友提出宝贵意见,若有关于前端的问题，或者关于大学方面的感想可以私聊我(^~^)：<br><a href="http://carryguan.me/" target="_blank" rel="external">个人网站</a><br><a href="https://github.com/sunningcarryhaha" target="_blank" rel="external">github</a><br><a href="https://www.zhihu.com/people/guan-kai-li-88" target="_blank" rel="external">知乎</a><br><a href="http://www.jianshu.com/users/0293a04839f0/latest_articles" target="_blank" rel="external">简书</a><br><a href="http://weibo.com/u/5048785433/home?wvr=5" target="_blank" rel="external">微博</a></p>
<hr>
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="http://music.163.com/outchain/player?type=2&id=408332973&auto=1&height=66"></iframe>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[最流行的Javascript都能做什么？]]></title>
      <url>http://carryguan.com/2016/09/08/%E6%9C%80%E7%81%AB%E7%9A%84Javascript%E9%83%BD%E8%83%BD%E5%81%9A%E4%BB%80%E4%B9%88%EF%BC%9F/</url>
      <content type="html"><![CDATA[<p>JS的应用场景</p>
<ul>
<li><strong>数据可视化</strong></li>
<li><strong>移动应用</strong></li>
<li><strong>服务端</strong></li>
<li><strong>桌面应用</strong></li>
<li><strong>游戏</strong></li>
<li><strong>VR</strong></li>
<li><strong>AR</strong></li>
<li><strong>物联网</strong></li>
<li><strong>硬件</strong></li>
<li><strong>操作系统</strong></li>
</ul>
<hr>
<p>若图片无法加载请点击<a href="http://www.jianshu.com/p/66e05cc8201d" target="_blank" rel="external">图片爸爸</a><br><img src="http://upload-images.jianshu.io/upload_images/2377897-bc22cd5fcf7b236a.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br><a id="more"></a></p>
<h1 id="数据可视化"><a href="#数据可视化" class="headerlink" title="数据可视化"></a>数据可视化</h1><h2 id="processing-js"><a href="#processing-js" class="headerlink" title="processing.js"></a>processing.js</h2><p>Processing.js作者是John Resig，这是继Jquery之后，他的第二个力作。<br>Processing.js使用JavaScript绘制形状sharp和操作HTML5 canvas元素产生图像动画。<br>Processing.js是轻量，易于了解掌握，并提出一个理想的工具，可视化的数据，创建用户界面和开发基于Web的游戏。<br><a href="http://blog.jobbole.com/1525/" target="_blank" rel="external">processing.js简介</a><br><a href="http://blog.csdn.net/bugknightyyp/article/details/8666831" target="_blank" rel="external">processing.js快速入门</a></p>
<h2 id="D3-js"><a href="#D3-js" class="headerlink" title="D3.js"></a>D3.js</h2><p>D3.js是一个JavaScript库，它可以通过数据来操作文档。D3可以通过使用HTML、SVG和CSS把数据鲜活形象地展现出来。D3严格遵循Web标准，因而可以让你的程序轻松兼容现代主流浏览器并避免对特定框架的依赖。同时，它提供了强大的可视化组件，可以让使用者以数据驱动的方式去操作DOM。<br><a href="http://www.jianshu.com/p/c3800c61d2fb" target="_blank" rel="external">D3.js入门指南</a><br><a href="http://javascript.ruanyifeng.com/library/d3.html" target="_blank" rel="external">D3.js入门教程</a></p>
<h1 id="移动应用"><a href="#移动应用" class="headerlink" title="移动应用"></a>移动应用</h1><h2 id="Cordova-phoneGap-ionic"><a href="#Cordova-phoneGap-ionic" class="headerlink" title="Cordova+phoneGap+ionic"></a>Cordova+phoneGap+ionic</h2><h3 id="Cordova"><a href="#Cordova" class="headerlink" title="Cordova"></a>Cordova</h3><p>Cordova提供了一组设备相关的API，通过这组API，移动应用能够以JavaScript访问原生的设备功能，如摄像头、麦克风等。<br>Cordova还提供了一组统一的JavaScript类库，以及为这些类库所用的设备相关的原生后台代码。<br><a href="http://www.zhoujingen.cn/blog/7027.html" target="_blank" rel="external"> Cordova教程</a></p>
<h3 id="phoneGap"><a href="#phoneGap" class="headerlink" title="phoneGap"></a>phoneGap</h3><p>PhoneGap是一个用基于<a href="http://baike.baidu.com/view/692.htm" target="_blank" rel="external">HTML</a>，<a href="http://baike.baidu.com/subview/15916/5236733.htm" target="_blank" rel="external">CSS</a>和<a href="http://baike.baidu.com/view/16168.htm" target="_blank" rel="external">JavaScript</a>的，创建移动跨平台移动应用程序的<a href="http://baike.baidu.com/view/4112052.htm" target="_blank" rel="external">快速开发平台</a>。它使开发者能够利用<a href="http://baike.baidu.com/view/158983.htm" target="_blank" rel="external">IOS</a>，Android，<a href="http://baike.baidu.com/view/27225.htm" target="_blank" rel="external">Palm</a>，<a href="http://baike.baidu.com/view/10708.htm" target="_blank" rel="external">Symbian</a>,WP7,<a href="http://baike.baidu.com/view/7261507.htm" target="_blank" rel="external">WP8</a>,<a href="http://baike.baidu.com/subview/76548/9852892.htm" target="_blank" rel="external">Bada</a>和<a href="http://baike.baidu.com/view/88648.htm" target="_blank" rel="external">Blackberry</a>智能手机的核心功能——包括地理定位，加速器，联系人，声音和振动等，此外PhoneGap拥有丰富的<a href="http://baike.baidu.com/view/18979.htm" target="_blank" rel="external">插件</a>，可以调用。<br><a href="http://www.phonegap100.com/article-462-1.html" target="_blank" rel="external">PhoneGap官网以及教程</a></p>
<h2 id="React-Native"><a href="#React-Native" class="headerlink" title="React Native"></a><strong>React Native</strong></h2><h1 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h1><h2 id="node-js"><a href="#node-js" class="headerlink" title="node.js"></a>node.js</h2><p>正是V8的性能将JavaScript带到了一个新的高度，于是Node.js诞生了——前端、后台都可以用JavaScript，一个JavaScript的全栈时代。<br><img src="http://upload-images.jianshu.io/upload_images/2377897-66ff0354fe02535a.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<hr>
<p>此篇文章依据<a href="https://www.zhihu.com/people/phodal" target="_blank" rel="external">phodal</a>大神的<a href="https://zhuanlan.zhihu.com/p/21911003" target="_blank" rel="external">文章</a></p>
<h1 id="桌面应用"><a href="#桌面应用" class="headerlink" title="桌面应用"></a>桌面应用</h1><h2 id="NW-js"><a href="#NW-js" class="headerlink" title="NW.js"></a>NW.js</h2><p>NW.js 是基于 Chromium 和 Node.js 运行的， 它们可以让我们用HTML和JavaScript来制作桌面应用。</p>
<h2 id="Electron"><a href="#Electron" class="headerlink" title="Electron"></a>Electron</h2><p>除了NW.js还有最近比较火的Electron，Atom编辑器的</p>
<h2 id="全平台应用"><a href="#全平台应用" class="headerlink" title="全平台应用"></a>全平台应用</h2><p><img src="http://upload-images.jianshu.io/upload_images/2377897-7766c666972e76e0.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br><a href="http://www.jianshu.com/p/a7cb1d8cffa7/comments/1430104" target="_blank" rel="external">全平台应用</a></p>
<h1 id="游戏"><a href="#游戏" class="headerlink" title="游戏"></a>游戏</h1><h2 id="WebGL"><a href="#WebGL" class="headerlink" title="WebGL"></a>WebGL</h2><p><a href="http://www.hewebgl.com/code/show/2.html" target="_blank" rel="external">炫酷的效果展示-旋转纽约</a><br><a href="http://www.hewebgl.com/code/show/4.html" target="_blank" rel="external">炫酷的效果展示-高科技感元素周期表</a><br><a href="http://hewebgl.com/" target="_blank" rel="external">webGL官网以及教程</a></p>
<h1 id="VR"><a href="#VR" class="headerlink" title="VR"></a><strong>VR</strong></h1><p><a href="https://www.phodal.com/blog/why-javascript-will-use-vr-world/" target="_blank" rel="external">vr介绍</a></p>
<h1 id="AR"><a href="#AR" class="headerlink" title="AR"></a>AR</h1><p><a href="http://www.tuicool.com/articles/EJfymiz" target="_blank" rel="external">介绍以及教程</a></p>
<h1 id="物联网"><a href="#物联网" class="headerlink" title="物联网"></a><strong>物联网</strong></h1><p><a href="https://zhuanlan.zhihu.com/p/21911003" target="_blank" rel="external">js与物联网</a></p>
<h1 id="硬件"><a href="#硬件" class="headerlink" title="硬件"></a>硬件</h1><p>这里不多介绍</p>
<h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><p>也不错介绍</p>
<hr>
<p>本文基于<a href="https://zhuanlan.zhihu.com/phodal" target="_blank" rel="external">Phodal</a>大神的<a href="https://zhuanlan.zhihu.com/p/21911003" target="_blank" rel="external">文章</a></p>
<hr>
<p> #博主感想</p>
<p>希望有更多小胖友提出宝贵意见,若有关于前端的问题，或者关于大学方面的感想可以私聊我(^~^)：<br><a href="http://carryguan.me/" target="_blank" rel="external">个人网站</a><br><a href="https://github.com/sunningcarryhaha" target="_blank" rel="external">github</a><br><a href="https://www.zhihu.com/people/guan-kai-li-88" target="_blank" rel="external">知乎</a><br><a href="http://www.jianshu.com/users/0293a04839f0/latest_articles" target="_blank" rel="external">简书</a><br><a href="http://weibo.com/u/5048785433/home?wvr=5" target="_blank" rel="external">微博</a></p>
<hr>
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="http://music.163.com/outchain/player?type=2&id=29436904&auto=1&height=66"></iframe>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Cookie和Session]]></title>
      <url>http://carryguan.com/2016/08/28/Cookie%E5%92%8CSession/</url>
      <content type="html"><![CDATA[<p><img src="http://upload-images.jianshu.io/upload_images/2377897-144ce8776fdd3f93.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h2 id="来由"><a href="#来由" class="headerlink" title="来由"></a>来由</h2><p>http协议是stateless的,一旦和后台响应了，就断开了和请求的连接，这时若我们想要了解哪个客户发来的请求，这就需要借助服务器端的session,和浏览器端的cookie  –（可以用express中间件）<br><a id="more"></a></p>
<h3 id="1：cookie-amp-session"><a href="#1：cookie-amp-session" class="headerlink" title="1：cookie&amp;session"></a>1：cookie&amp;session</h3><p><a href="http://blog.csdn.net/fangaoxin/article/details/6952954" target="_blank" rel="external">cookie,session</a>会话跟踪是Web程序中常用的技术，用来<strong>跟踪用户的整个会话</strong>。常用的会话跟踪技术是Cookie与Session。<strong>Cookie通过在客户端记录信息确定用户身份</strong>，<strong>Session通过在服务器端记录信息确定用户身份</strong>。</p>
<h3 id="2：Cookie"><a href="#2：Cookie" class="headerlink" title="2：Cookie"></a>2：Cookie</h3><p>Cookie实际上是一小段的文本信息。客户端请求服务器，如果服务器需要记录该用户状态，就使用response向客户端浏览器颁发一个Cookie。客户端浏览器会把Cookie保存起来。当浏览器再请求该网站时，浏览器把请求的网址连同该Cookie一同提交给服务器。服务器检查该Cookie，以此来辨认用户状态。服务器还可以根据需要修改Cookie的内容。</p>
<h3 id="3：-Session"><a href="#3：-Session" class="headerlink" title="3： Session"></a>3： Session</h3><p>Session是另一种记录客户状态的机制，不同的是Cookie保存在客户端浏览器中，而Session保存在服务器上。客户端浏览器访问服务器的时候，服务器把客户端信息以某种形式记录在服务器上。这就是Session。客户端浏览器再次访问时只需要从该Session中查找该客户的状态就可以了。<br>如果说Cookie机制是通过检查客户身上的“通行证”来确定客户身份的话，那么Session机制就是通过检查服务器上的“客户明细表”来确认客户身份。Session相当于程序在服务器上建立的一份客户档案，客户来访的时候只需要查询客户档案表就可以了。</p>
<hr>
<p> #博主感想</p>
<p>希望有更多小胖友提出宝贵意见,若有关于前端的问题，或者关于大学方面的感想可以私聊我(^~^)：<br><a href="http://carryguan.me/" target="_blank" rel="external">个人网站</a><br><a href="https://github.com/sunningcarryhaha" target="_blank" rel="external">github</a><br><a href="https://www.zhihu.com/people/guan-kai-li-88" target="_blank" rel="external">知乎</a><br><a href="http://www.jianshu.com/users/0293a04839f0/latest_articles" target="_blank" rel="external">简书</a><br><a href="http://weibo.com/u/5048785433/home?wvr=5" target="_blank" rel="external">微博</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[MyVocation]]></title>
      <url>http://carryguan.com/2016/08/16/MyVocation/</url>
      <content type="html"><![CDATA[<h1 id="一共四周："><a href="#一共四周：" class="headerlink" title="一共四周："></a>一共四周：</h1><p>第一周：了解一下做的是啥，学习mysql,node.js,coffeescript,socket<br>第二周 : 写了缺货提醒的接口(warehouse-coffee-lib–timer-newStocksInfor),获得缺货详细列表的接口(warehouse-coffee-lib-getStocksList)<br>第三周：写了获得缺货门店的信息接口(warehouse-coffee-lib-AreaLacks)<br>第四周：学express,node.js搭建网站，写后台<br><a id="more"></a></p>
<h1 id="后台工作流程："><a href="#后台工作流程：" class="headerlink" title="后台工作流程："></a>后台工作流程：</h1><h2 id="一：搭建服务器"><a href="#一：搭建服务器" class="headerlink" title="一：搭建服务器"></a>一：搭建服务器</h2><h2 id="二：数据处理："><a href="#二：数据处理：" class="headerlink" title="二：数据处理："></a>二：数据处理：</h2><p>数据库（mysql）,redis,memcache</p>
<h2 id="三：本机启动后台系统"><a href="#三：本机启动后台系统" class="headerlink" title="三：本机启动后台系统"></a>三：本机启动后台系统</h2><p>node main.js/supervisor main.js/NODE_ENV=DEV &amp;&amp;supervisor main.j</p>
<h2 id="四：与客户端的连接"><a href="#四：与客户端的连接" class="headerlink" title="四：与客户端的连接"></a>四：与客户端的连接</h2><h3 id="1"><a href="#1" class="headerlink" title="1:"></a>1:</h3><p>此客户端可以为android,ios,web前台（前端）</p>
<h3 id="2"><a href="#2" class="headerlink" title="2:"></a>2:</h3><p>客户端需要知道后台的ip,进行 ping连接</p>
<h3 id="3"><a href="#3" class="headerlink" title="3:"></a>3:</h3><p>客户端也需要知道与后台进行交互的那个接口</p>
<h2 id="五：和客户端的交互"><a href="#五：和客户端的交互" class="headerlink" title="五：和客户端的交互"></a>五：和客户端的交互</h2><p>后台需要写好接口功能，并把数据通过这个接口传输给客户端(socket.on)<br>后台自己定义好功能（一般是客户端的系统信息推送）自发起一个接口(socket.emit),客户端soket.on接口和数据</p>
<h2 id="六：注意"><a href="#六：注意" class="headerlink" title="六：注意"></a>六：注意</h2><p>从github拽下来的文件，需要进入其跟目录进行npm install,原因是将package.json中的dependencies依赖包进行下载；</p>
<h1 id="More"><a href="#More" class="headerlink" title="More"></a>More</h1><p>真的特别感谢公司给的这次机会，让我学到了好多新知识，还结交到了几位盆友，跟他们这样有多年开发经验的人沟通，了解了开发方式与模式，扩展了知识面</p>
<hr>
<h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p><a href="http://www.jianshu.com/p/25e89c1ad4ab" target="_blank" rel="external">图片爸爸加载</a><br>放一张我男神BI照片来开心一下（原谅博主少女心）<br><img src="http://upload-images.jianshu.io/upload_images/2377897-895ca3735e03828e.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>再放一张博主我的（表杀我，咩咩）<br><img src="http://upload-images.jianshu.io/upload_images/2377897-1e9289634631a1cc.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Github预览demo]]></title>
      <url>http://carryguan.com/2016/07/15/github%E9%A2%84%E8%A7%88demo/</url>
      <content type="html"><![CDATA[<p><img src="http://upload-images.jianshu.io/upload_images/2377897-fc915701514c515c.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="young"></p>
<ul>
<li>问题所在？</li>
<li>解决办法？</li>
<li>博主建议？<br>(原谅博主carry比较变态，在博文加了歌曲，不想听歌的小胖友们可以到博文底部关闭 ^~^)<br>图片无法加载可以点击<a href="http://www.jianshu.com/p/75e30889e70a" target="_blank" rel="external">图片爸爸</a></li>
</ul>
<hr>
<h2 id="一：问题的所在"><a href="#一：问题的所在" class="headerlink" title="一：问题的所在"></a>一：问题的所在</h2><p>相信很多小胖友们在把自己的网页上传到github仓库中，都会有一个疑问？是什么呢？<br>那就是上传完网页后，自己的仓库中是这个样子的<img src="http://upload-images.jianshu.io/upload_images/2377897-44104fdfe222e566.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="">，点进去相应的html文件是出来的是代码<img src="http://upload-images.jianshu.io/upload_images/2377897-933438f6e1551351.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>可是自己想在网上看到自己仓库中的demo(也就是网页的效果)<br>下面博猪为您解答 (^~^)</p>
<hr>
<a id="more"></a>
<h2 id="二：解决问题的方法"><a href="#二：解决问题的方法" class="headerlink" title="二：解决问题的方法"></a>二：解决问题的方法</h2><h4 id="1-使用-Githubpages"><a href="#1-使用-Githubpages" class="headerlink" title="1: 使用 Githubpages"></a>1: 使用 Githubpages</h4><p>   比如我要上传<img src="http://upload-images.jianshu.io/upload_images/2377897-5b4113b7f687b1e5.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>   按照如下四个步骤上传到名为:flexSupplement的仓库中</p>
<pre><code>git init (初始化本地仓库)
git add .  （将本地所有文件加到仓库里）
git commit -m &quot;message&quot; （设置提交信息）
git remote add origin   git@github.com:sunningcarryhaha/flexSupplement.git（本地仓库链接远程仓库）
git push -u origin master （push文件到仓库中）
</code></pre><p>上传成功后是这个效果<img src="" alt=""><br>重头戏来了哟！<br>我们现在点击这个html文件，出现的效果全是代码![]<img src="http://upload-images.jianshu.io/upload_images/2377897-933438f6e1551351.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="">()，没有咱们想要的demo效果<br>此时呢，应该植入咱们github爸爸的一个好东西，那就是-githubPages</p>
<h5 id="第一步：找到Settings"><a href="#第一步：找到Settings" class="headerlink" title="第一步：找到Settings"></a>第一步：找到Settings</h5><pre><code>![](http://upload-images.jianshu.io/upload_images/2377897-0a301fa6cbc3d33f.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
</code></pre><h5 id="第二布：找到githubPages"><a href="#第二布：找到githubPages" class="headerlink" title="第二布：找到githubPages"></a>第二布：找到githubPages</h5><p><img src="http://upload-images.jianshu.io/upload_images/2377897-5033f61187c659c7.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h5 id="第三步：预览githubPages"><a href="#第三步：预览githubPages" class="headerlink" title="第三步：预览githubPages"></a>第三步：预览githubPages</h5><p><img src="http://upload-images.jianshu.io/upload_images/2377897-794ba43a2fadab1d.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>小胖友们看到这里一定会有疑问，预览到的是githubpages的效果，并不是你自己网页的效果，没关系，我下面为你们解答</p>
<h5 id="第四步：查看你的分支"><a href="#第四步：查看你的分支" class="headerlink" title="第四步：查看你的分支"></a>第四步：查看你的分支</h5><p><img src="http://upload-images.jianshu.io/upload_images/2377897-2fdf9314d74b1a05.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>注意：我们生成githubPages的目的就是需要生成一个gh-pages分支(咱们正常情况下只有一个master分支)</p>
<h5 id="第五步：将远程仓库克隆到本地"><a href="#第五步：将远程仓库克隆到本地" class="headerlink" title="第五步：将远程仓库克隆到本地"></a>第五步：将远程仓库克隆到本地</h5><p><pre><code><br>$ git clone git@github.com:sunningcarryhaha/flexSupplement.git<br></code></pre></p>
<h5 id="第六步：将分支切换到gh-Pages"><a href="#第六步：将分支切换到gh-Pages" class="headerlink" title="第六步：将分支切换到gh-Pages"></a>第六步：将分支切换到gh-Pages</h5><p><pre><code><br>  $ cd flexSupplement （进入到你克隆仓库的本地文件夹）<br>  $ git checkout gh-pages（将master分支切换到gh-pages分支上）</code></pre></p>
<p></p>
<h6 id="第七步：并重新上传到github上"><a href="#第七步：并重新上传到github上" class="headerlink" title="第七步：并重新上传到github上"></a>第七步：并重新上传到github上</h6><p>将本地克隆的文件删了，只留下.git,然后把你想要展示demo页面相关的文件粘进去<br>接着，执行以下语句</p>
<p><pre><code><br> git add . （将本地所有文件加到仓库里）<br> git commit -m “message” （设置提交信息）<br> git remote add origin git@github.com:sunningcarryhaha/flexSupplement.git（本地仓库链接远程仓库）<br> git push -u origin gh-pages （push文件到仓库中）<br></code></pre></p>
<h5 id="第八步：修改地址"><a href="#第八步：修改地址" class="headerlink" title="第八步：修改地址"></a>第八步：修改地址</h5><p>我的GithubPages地址是这个：<a href="http://carryguan.me/flex-add" target="_blank" rel="external">http://carryguan.me/flex-add</a><br>我要预览flex-add中的fb1.html<br>我最后预览的地址应该是这个：<a href="http://carryguan.me/flex-add/fb1.html" target="_blank" rel="external">http://carryguan.me/flex-add/fb1.html</a></p>
<h5 id="第九步：添加read-me"><a href="#第九步：添加read-me" class="headerlink" title="第九步：添加read.me"></a>第九步：添加read.me</h5><p>把地址放到read.me中</p>
<p><pre><code><br>  flex-add<br>  这是一个关于flexbox基础的骰子布局<br>  <a href="http://carryguan.me/flex-add/fb1.html" target="_blank" rel="external">demo</a><br></code></pre></p>
<h4 id="2-增加路径前缀（不建议用，会自动更改css的样式）"><a href="#2-增加路径前缀（不建议用，会自动更改css的样式）" class="headerlink" title="2: 增加路径前缀（不建议用，会自动更改css的样式）"></a>2: 增加路径前缀（不建议用，会自动更改css的样式）</h4><p>在地址前加<a href="http://htmlpreview.github.io/?" target="_blank" rel="external">http://htmlpreview.github.io/?</a>前缀（不建议用这个，会更改css样式）<br>例如，你想预览这个：<br><br><a href="">https://github.com/aisinvon/aisinvon.github.io/blob/master/index.html</a><br><br><br>你在这个地址前加<a href="http://htmlpreview.github.io/?" target="_blank" rel="external">http://htmlpreview.github.io/?</a><br><br><br>最后预览demo地址是：<br><a href="http://htmlpreview.github.io/?https://github.com/aisinvon/aisinvon.github.io/blob/master/index.html" target="_blank" rel="external">http://htmlpreview.github.io/?https://github.com/aisinvon/aisinvon.github.io/blob/master/index.html</a></p>
<hr>
<p> 博主感想</p>
<p>希望有更多小胖友提出宝贵意见,若有关于前端的问题，或者关于大学方面的感想可以私聊我(^~^)：</p>
<p><a href="https://github.com/sunningcarryhaha" target="_blank" rel="external">github</a><br><a href="https://www.zhihu.com/people/guan-kai-li-88" target="_blank" rel="external">知乎</a><br><a href="http://www.jianshu.com/users/0293a04839f0/latest_articles" target="_blank" rel="external">简书</a><br><a href="http://weibo.com/u/5048785433/home?wvr=5" target="_blank" rel="external">微博</a></p>
<hr>
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="http://music.163.com/outchain/player?type=2&id=28756834&auto=1&height=66"></iframe>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[最详尽-hexo+GithubPages搭建博客]]></title>
      <url>http://carryguan.com/2016/07/02/hexo-gihubpages-%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/</url>
      <content type="html"><![CDATA[<p><img src="http://ww1.sinaimg.cn/large/005vGbJ7jw1f5ms460e6tj30zk0aqgn1.jpg" alt=""></p>
<ul>
<li>为什么选择hexo？</li>
<li>搭建博客的基本步骤</li>
<li>部署到Github Pages</li>
<li>域名解析<br>(原谅博主carry比较变态，在博文加了歌曲，不想听歌的小胖友们可以到博文底部关闭 )<br>图片无法加载可以点击<a href="http://www.jianshu.com/p/0321cb243963" target="_blank" rel="external">图片爸爸</a></li>
</ul>
<hr>
<h2 id="为什么选择hexo？"><a href="#为什么选择hexo？" class="headerlink" title="为什么选择hexo？"></a>为什么选择hexo？</h2><p>Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 <a href="http://daringfireball.net/projects/markdown/" target="_blank" rel="external">Markdown</a>（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</p>
<hr>
<h2 id="搭建博客的基本步骤"><a href="#搭建博客的基本步骤" class="headerlink" title="搭建博客的基本步骤"></a>搭建博客的基本步骤</h2><ul>
<li>购买域名</li>
<li>安装hexo</li>
<li>注册github</li>
</ul>
<h3 id="一：购买域名"><a href="#一：购买域名" class="headerlink" title="一：购买域名"></a>一：购买域名</h3><p>   若小胖友们想把个人博客挂到属于自己的域名上，博主在这里建议大家提前把域名买好。<br>博主购买域名的地方是<a href="https://wanwang.aliyun.com/" target="_blank" rel="external">万网</a>,注册登录后，填写你想要的域名<br><a id="more"></a><br><img src="http://upload-images.jianshu.io/upload_images/2377897-a9273887335cde2a.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>选择完自己域名后，付费就可以了！<br>(博主建议个人域名选择.me为后缀的较好-博主的域名就为<a href="http://carryguan.me" target="_blank" rel="external">carryguan.me</a>)</p>
<h3 id="二：安装hexo"><a href="#二：安装hexo" class="headerlink" title="二：安装hexo"></a>二：安装hexo</h3><p>  装 Hexo 相当简单。然而在安装前，您必须检查电脑中是否已安装下列应用程序：<br><a href="http://git-scm.com/" target="_blank" rel="external">Git</a><br><a href="http://nodejs.org/" target="_blank" rel="external">Node.js</a></p>
<p> 若你是IT小白，安装git/node没成功,博主carry给你个福利贴士<br> (博主就是这样一点点过来的 （＃￣▽￣＃）)<br><a href="http://jingyan.baidu.com/article/90895e0fb3495f64ed6b0b50.html" target="_blank" rel="external">windows安装git</a><br><a href="http://jingyan.baidu.com/article/b0b63dbfca599a4a483070a5.html" target="_blank" rel="external">windows安装node.js</a></p>
<blockquote>
<p>在这里建议小胖友们，先预习一下:<br>  <a href="http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000" target="_blank" rel="external">git入门教程</a><br><a href="https://www.zhihu.com/question/20070065" target="_blank" rel="external">github趣味详解</a></p>
</blockquote>
<p>如果您的电脑中已经安装上述必备程序，那么恭喜您！接下来只需要使用 npm 即可完成 Hexo 的安装。<br>先进入一个文件夹路径：例如我的<img src="http://ww3.sinaimg.cn/large/005vGbJ7jw1f5fbuje1hjj30l50bd75k.jpg" alt=""><br>再执行下面的命令:</p>
<pre><code>npm install -g hexo-cli</code></pre> 

<h3 id="初始化框架"><a href="#初始化框架" class="headerlink" title="初始化框架"></a>初始化框架</h3><h4 id="1执行如下语句"><a href="#1执行如下语句" class="headerlink" title="1执行如下语句"></a>1执行如下语句</h4><pre><code> hexo init blog</code></pre>

<p> (blog是我自己建立的用来装博客的文件夹)</p>
<h4 id="2：再执行"><a href="#2：再执行" class="headerlink" title="2：再执行"></a>2：再执行</h4><pre><code>cd blog</code></pre> 



<h4 id="3-最后执行"><a href="#3-最后执行" class="headerlink" title="3: 最后执行"></a>3: 最后执行</h4><pre><code>npm install</code></pre> 

<p>以上三条语句执行完毕后， 你会在blog文件夹里看到如下:<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">├── _config.yml //网站的配置信息，您可以在此配置大部分的参数。 </span><br><span class="line">├── package.json </span><br><span class="line">├── scaffolds //模版文件夹。当您新建文章时，Hexo 会根据 scaffold 来建立文件。 </span><br><span class="line">├── source //资源文件夹是存放用户资源的地方。</span><br><span class="line"> | ├── _drafts</span><br><span class="line"> | └── _posts </span><br><span class="line">└── themes //主题文件夹。Hexo会根据主题来生成静态页面。</span><br></pre></td></tr></table></figure></p>
<h4 id="最后看看你自己的个人网站："><a href="#最后看看你自己的个人网站：" class="headerlink" title="最后看看你自己的个人网站："></a>最后看看你自己的个人网站：</h4><p>在blog目录下执行gitbash命令:</p>
<p>1：新建一篇文章（我的第一篇文章）</p>
<pre><code>
 hexo new "我的第一篇文章"
</code></pre> 

<p>会在/source/_post里自动生成了“我的第一篇文章.md”文件，之后新建的文章都将存放在此目录下。编辑“我的第一篇文章.md”文件可修改内容。</p>
<p>2：生成网站</p>
<pre><code> 
hexo generate (可简写成 hexo g)
</code></pre> 

<p>3:启动本地服务器</p>
<pre><code> 
 hexo server (可简写成 hexo s)
</code></pre> 


<p>4:在浏览器输入<a href="http://localhost:4000/" target="_blank" rel="external">http://localhost:4000</a> 即可查看网站。</p>
<h3 id="三：注册github"><a href="#三：注册github" class="headerlink" title="三：注册github"></a>三：注册github</h3><p><a href="https://github.com/" target="_blank" rel="external">github</a><br>填写完相应信息，注册成功后，重新登录，进入到这个页面<br><img src="http://ww2.sinaimg.cn/large/005vGbJ7jw1f5md7zebr5j30wp0gnq5f.jpg" alt=""><br>点击图片中所圈位置出现了如下：<br><img src="http://ww4.sinaimg.cn/large/005vGbJ7jw1f5mdn65brmj30ng0h0dh1.jpg" alt=""></p>
<blockquote>
<p>Repository name里填写:你的用户名.github.io<br>(例如我的用户名是<a href="https://github.com/sunningcarryhaha" target="_blank" rel="external">sunningcarryhaha</a>,所以我的Repository name:sunningcarryhaha.github.io)<br>Description里随便填一下你的描述就好<br>Public选中<br>选中Initilize this respository with a README<br>最后点击绿色按钮创建</p>
</blockquote>
<p><img src="http://ww4.sinaimg.cn/large/005vGbJ7jw1f5mdofjeuij30pv0k9tab.jpg" alt=""><br>创建成功后<br>配置SSH-Key<br><a href="http://jingyan.baidu.com/article/a65957f4e91ccf24e77f9b11.html" target="_blank" rel="external">详细步骤请点击此文章</a></p>
<hr>
<h2 id="将blog部署到Github-Pages-上"><a href="#将blog部署到Github-Pages-上" class="headerlink" title="将blog部署到Github Pages 上"></a>将blog部署到Github Pages 上</h2><p><strong> 两种方法:</strong></p>
<ul>
<li>使用hexo deploy部署</li>
<li>使用git push 部署<h3 id="1：hexo-deploy部署"><a href="#1：hexo-deploy部署" class="headerlink" title="1：hexo deploy部署"></a>1：hexo deploy部署</h3><h4 id="配置deploy"><a href="#配置deploy" class="headerlink" title="配置deploy"></a>配置deploy</h4>找到blog目录下的配置文件_config.yml,用编辑器打开此文件<br>找到此文件中的deploy字段，按照以下配置<pre><code>deploy: 
 type: git 
 repo: git@github.com:sunningcarryhaha/sunningcarryhaha.github.io.git   
 branch: master
</code></pre><h4 id="注意需要提前安装一个扩展："><a href="#注意需要提前安装一个扩展：" class="headerlink" title="注意需要提前安装一个扩展："></a>注意需要提前安装一个扩展：</h4><pre><code>$ npm install hexo-deployer-git --save
</code></pre><h4 id="然后在命令行中执行"><a href="#然后在命令行中执行" class="headerlink" title="然后在命令行中执行"></a>然后在命令行中执行</h4><pre><code>hexo d
</code></pre><blockquote>
<p>不幸的是，上述命令虽然简单方便，但是偶尔会有莫名其妙的问题出现，因此，我们也可以追本溯源，使用git命令来完成部署的工作。</p>
</blockquote>
</li>
</ul>
<h3 id="2-使用gitbash，将public文件夹上传到自己的仓库中"><a href="#2-使用gitbash，将public文件夹上传到自己的仓库中" class="headerlink" title="2:使用gitbash，将public文件夹上传到自己的仓库中"></a>2:使用gitbash，将public文件夹上传到自己的仓库中</h3><h4 id="第一步：进入到你的blog目录"><a href="#第一步：进入到你的blog目录" class="headerlink" title="第一步：进入到你的blog目录"></a>第一步：进入到你的blog目录</h4><pre><code> 
 cd blog
</code></pre>

<h4 id="第二步-初始化博客"><a href="#第二步-初始化博客" class="headerlink" title="第二步 :初始化博客"></a>第二步 :初始化博客</h4><pre><code>
hexo g
</code></pre> 

<h4 id="第三步-把public文件夹上传到github仓库中"><a href="#第三步-把public文件夹上传到github仓库中" class="headerlink" title="第三步:把public文件夹上传到github仓库中"></a>第三步:把public文件夹上传到github仓库中</h4><pre><code> 
cd public
</code></pre> 

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git init (初始化本地仓库)</span><br><span class="line">git add .  （将本地文件加到仓库里）</span><br><span class="line">git commit -m &quot;message&quot; （设置提交信息）</span><br><span class="line">git remote add origin git@github.com:sunningcarryhaha/sunningcarryhaha.github.io.git（本地仓库链接远程仓库）</span><br><span class="line">git push origin master （push文件到仓库中）</span><br></pre></td></tr></table></figure>
<blockquote>
<p>git@github.com:sunningcarryhaha/sunningcarryhaha.github.io.git<br>解释一下   ：<br>sunningcarryhaha是用户名<br>sunningcarryhaha.github.io是仓库名称<br>.git是后缀</p>
</blockquote>
<p>详细的步骤可参考此<br><a href="http://blog.csdn.net/steven6977/article/details/10567719" target="_blank" rel="external">github push</a><br><a href="http://blog.csdn.net/chaihuasong/article/details/37911723" target="_blank" rel="external">git github 问题总结</a></p>
<p>部署成功以后，在浏览器中输入你的repository名字：例如我的<a href="https://github.com/sunningcarryhaha" target="_blank" rel="external">sunningcarryhaha.github.io</a></p>
<h4 id="就可以看到你的网站了"><a href="#就可以看到你的网站了" class="headerlink" title="就可以看到你的网站了"></a>就可以看到你的网站了</h4><hr>
<h2 id="域名解析"><a href="#域名解析" class="headerlink" title="域名解析"></a>域名解析</h2><ul>
<li>进入万网进行域名绑定</li>
<li>进入public,新建CNAME</li>
<li>把域名写到CNAME里</li>
<li>传到github仓库里<h3 id="1-进入万网进行域名绑定"><a href="#1-进入万网进行域名绑定" class="headerlink" title="1:进入万网进行域名绑定"></a>1:进入万网进行域名绑定</h3><img src="http://ww4.sinaimg.cn/large/005vGbJ7jw1f5feoitevaj30ah0bit9r.jpg" alt=""><br><img src="http://ww1.sinaimg.cn/large/005vGbJ7jw1f5fepmf432j31hb0jgthk.jpg" alt=""><br><img src="http://ww3.sinaimg.cn/large/005vGbJ7jw1f5fer7xepxj319r0d2gpx.jpg" alt=""><br>安照以上图片进行操作<br><strong> 尤其注意:记录值那里填写的是:sunningcarryhaha.github.io.，也就是你的仓库名字后还有个”.”  </strong><br>以上进行完毕后，接着下一步</li>
</ul>
<h3 id="2-进入blog下的public文件夹-新建-CNAME"><a href="#2-进入blog下的public文件夹-新建-CNAME" class="headerlink" title="2:进入blog下的public文件夹,新建 CNAME"></a>2:进入blog下的public文件夹,新建 CNAME</h3><p><img src="http://ww4.sinaimg.cn/large/005vGbJ7jw1f5fe1tnb1pj30rt0h5q7d.jpg" alt=""><br><img src="http://ww4.sinaimg.cn/large/005vGbJ7jw1f5feuzv6ncj30ip0e5gn3.jpg" alt=""></p>
<h3 id="3-将public文件夹下的CNAME上传到github仓库中"><a href="#3-将public文件夹下的CNAME上传到github仓库中" class="headerlink" title="3:将public文件夹下的CNAME上传到github仓库中"></a>3:将public文件夹下的CNAME上传到github仓库中</h3><p> <img src="http://ww2.sinaimg.cn/large/005vGbJ7jw1f5feyzubl7j30l50bdq5p.jpg" alt=""><br>如果上传成功的话，进入到你的github仓库中会看到CNAME文件<br><img src="http://ww3.sinaimg.cn/large/005vGbJ7jw1f5ff5aey6gj30sj0ndn3i.jpg" alt=""></p>
<h3 id="4-为了防止域名解析出问题"><a href="#4-为了防止域名解析出问题" class="headerlink" title="4:为了防止域名解析出问题"></a>4:为了防止域名解析出问题</h3><p>博主建议将blog下的public下的CNAME文件，复制到blog下的source文件夹里，这样更新public，不会出现CNAME文件丢失的情况</p>
<hr>
<p>如果以上步骤都进行完毕的话，博主carry恭喜你:bowtie:,小胖友你zen棒，现在在浏览器输入你的域名，就可以成功的看到你的个人网站啦！<br>当然这个网站还可以换主题，美化！这方面的文章敬请期待，博主会继续出博文的!</p>
<hr>
<h2 id="博主感想"><a href="#博主感想" class="headerlink" title="博主感想"></a>博主感想</h2><p>这个博客博主搭建了好久，走了好多弯路(原谅博主比较笨，呜呜！)<br>期间出了好多问题，最根本的原因是博主git方面不基础不好,所以建议小胖友们多练习一下git<br>这里推荐:<br>     <a href="http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000" target="_blank" rel="external">git入门教程</a><br>    <a href="http://www.runoob.com/nodejs/nodejs-install-setup.html" target="_blank" rel="external">node.js安装菜鸟教程</a><br>   <a href="https://hexo.io/zh-cn/docs/index.html" target="_blank" rel="external">hexo官网</a><br><a href="http://www.jianshu.com/p/1e402922ee32/" target="_blank" rel="external">markdown入门</a><br><a href="https://www.zhihu.com/question/24422335/answer/46357100" target="_blank" rel="external">hexo主题推荐</a><br><a href="http://theme-next.iissnan.com/" target="_blank" rel="external">next-hexo主题</a><br><a href="http://wp.huangshiyang.com/hexo%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88" target="_blank" rel="external">hexo常见问题解决方案</a></p>
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="http://music.163.com/outchain/player?type=2&id=3412579&auto=1&height=66"></iframe>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[book]]></title>
      <url>http://carryguan.com/2016/06/28/book/</url>
      <content type="html"><![CDATA[<h1 id="HTML-amp-CSS"><a href="#HTML-amp-CSS" class="headerlink" title="HTML&amp;CSS"></a>HTML&amp;CSS</h1><h2 id="常见的行内元素与块级元素都有哪些，分别举例-，并说一说区别5"><a href="#常见的行内元素与块级元素都有哪些，分别举例-，并说一说区别5" class="headerlink" title="常见的行内元素与块级元素都有哪些，分别举例 ，并说一说区别5%"></a>常见的行内元素与块级元素都有哪些，分别举例 ，并说一说区别5%</h2><ul>
<li>行内元素(inline)：a b span input select strong samll</li>
<li>块级元素(block)：p div ul ol li dl dt dd h1 table form center</li>
<li>行内块级元素(inline-block):img（可以设置宽高，多个元素占一行，可设置所有margin和padding）</li>
<li><p>常见的空元素：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;br/&gt; &lt;hr/&gt;  &lt;link/&gt; &lt;meta/&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>行内元素与块级元素的区别：</li>
<li>行内元素一行占好多个，块级元素独占一行</li>
<li>设置宽度width ,height 无效，可以通过line-height来设置。</li>
<li>设置左右margin/padding有效，上下margin/padding无效</li>
</ul>
</li>
</ul>
<hr>
<h2 id="margin"><a href="#margin" class="headerlink" title="margin"></a>margin</h2><p>margin :上   右   下   左<br>margin: 上  右  下<br>margin : 上下  左右</p>
<h2 id="居中的常见方法-水平，竖直-5"><a href="#居中的常见方法-水平，竖直-5" class="headerlink" title="居中的常见方法(水平，竖直) 5%"></a>居中的常见方法(水平，竖直) 5%</h2><h3 id="1-水平居中"><a href="#1-水平居中" class="headerlink" title="1.水平居中"></a>1.水平居中</h3><ul>
<li>自身宽高，块级元素</li>
<li>margin：0 auto; <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">.box&#123;</span><br><span class="line">    width: 300px;</span><br><span class="line">    height: 300px;</span><br><span class="line">    border: 3px solid red;</span><br><span class="line">&#125;</span><br><span class="line">img&#123;</span><br><span class="line">    display: block;</span><br><span class="line">    width: 100px;</span><br><span class="line">    height: 100px;</span><br><span class="line">    margin: 0 auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="2-水平居中-父元素-text-align：center；"><a href="#2-水平居中-父元素-text-align：center；" class="headerlink" title="2.水平居中 父元素 text-align：center；"></a>2.水平居中 父元素 text-align：center；</h3><p>子元素的display：inline-block；在不受float影响下进行<br>是在父元素上添加：text-align：center；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">.box&#123;</span><br><span class="line">    width: 300px;</span><br><span class="line">    height: 300px;</span><br><span class="line">    border: 3px solid red;</span><br><span class="line">    text-align: center;</span><br><span class="line">&#125;</span><br><span class="line">img&#123;</span><br><span class="line">    display: inline-block;</span><br><span class="line">    width: 100px;</span><br><span class="line">    height: 100px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="水平垂直居中（一）"><a href="#水平垂直居中（一）" class="headerlink" title="水平垂直居中（一）"></a>水平垂直居中（一）</h4><p> 自身宽高,position,left,top ,margin-left,top为自身宽高负值一半<br>(left,top,right,bottom使用要，在position ：relative/absolute)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">img&#123;</span><br><span class="line">    width: 100px;</span><br><span class="line">    height: 150px;</span><br><span class="line">    position: absolute;</span><br><span class="line">    top: 50%;</span><br><span class="line">    left: 50%;</span><br><span class="line">    margin-top: -75px;/*自身 高度的一半 */</span><br><span class="line">    margin-left: -50px;/*自身 宽度的一半 */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="水平垂直居中（三）绝对定位和transfrom"><a href="#水平垂直居中（三）绝对定位和transfrom" class="headerlink" title="水平垂直居中（三）绝对定位和transfrom"></a>水平垂直居中（三）绝对定位和transfrom</h3><p>不需要知道居中元素的宽高<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">img&#123;</span><br><span class="line">        position: absolute;</span><br><span class="line">        top: 50%;</span><br><span class="line">        left: 50%;</span><br><span class="line">        transform: translate(-50%,-50%);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="水平垂直居中（二）"><a href="#水平垂直居中（二）" class="headerlink" title="水平垂直居中（二）"></a>水平垂直居中（二）</h3><p>自身宽高，position,定位上下左右为0，margin:atuo（auto等分其余空间）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">img&#123;</span><br><span class="line">       width: 100px;</span><br><span class="line">       height: 150px;</span><br><span class="line">       position: absolute;</span><br><span class="line">       top: 0;</span><br><span class="line">       left: 0;</span><br><span class="line">       right: 0;</span><br><span class="line">       bottom: 0;</span><br><span class="line">       margin: auto;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="水平垂直居中（四）diplay：table-cell"><a href="#水平垂直居中（四）diplay：table-cell" class="headerlink" title="水平垂直居中（四）diplay：table-cell"></a>水平垂直居中（四）diplay：table-cell</h3><p>其实这个就是把其变成表格样式，再利用表格的样式来进行居中，很方便<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">box&#123;</span><br><span class="line">            width: 300px;</span><br><span class="line">            height: 300px;</span><br><span class="line">            background:#e9dfc7; </span><br><span class="line">            border:1px solid red;</span><br><span class="line"></span><br><span class="line">            display: table-cell;</span><br><span class="line">            vertical-align: middle;</span><br><span class="line">            text-align: center;</span><br><span class="line">        &#125;</span><br><span class="line">        img&#123;</span><br><span class="line">            width: 100px;</span><br><span class="line">            height: 150px;</span><br><span class="line">            /*margin: 0 auto;*/  这个也行</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="水平垂直居中（五）flexBox居中"><a href="#水平垂直居中（五）flexBox居中" class="headerlink" title="水平垂直居中（五）flexBox居中"></a>水平垂直居中（五）flexBox居中</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">.box&#123;</span><br><span class="line">            width: 300px;</span><br><span class="line">            height: 300px;</span><br><span class="line">            background:#e9dfc7; </span><br><span class="line">            border:1px solid red;</span><br><span class="line">            display: flex;</span><br><span class="line">            justify-content: center;</span><br><span class="line">            align-items:center;</span><br><span class="line">        &#125;</span><br><span class="line">        img&#123;</span><br><span class="line">            width: 150px;</span><br><span class="line">            height: 100px;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p><a href="http://www.jianshu.com/p/a7552ce07c88" target="_blank" rel="external">http://www.jianshu.com/p/a7552ce07c88</a></p>
<hr>
<h2 id="常见的垂直居中的方式"><a href="#常见的垂直居中的方式" class="headerlink" title="常见的垂直居中的方式"></a>常见的垂直居中的方式</h2><ul>
<li>vertical-align:middle(table)</li>
<li>translateY(-50%)<br>-webkit-transform: translateY(-50%);</li>
<li>css3 flex<br>不定宽高水平垂直居中<br>align-items:center;//子元素垂直居中<br>justify-content:center;//子元素水平居中<br>display:-webkit-flex;</li>
</ul>
<hr>
<h2 id="如何让几行文本垂直居中？如何让一行文本进行垂直居中？"><a href="#如何让几行文本垂直居中？如何让一行文本进行垂直居中？" class="headerlink" title="如何让几行文本垂直居中？如何让一行文本进行垂直居中？"></a>如何让几行文本垂直居中？如何让一行文本进行垂直居中？</h2><ul>
<li>一行文本垂直居中：height = line-height</li>
<li>多行文本固定高度垂直居中：vertical-align（兼容IE7及IE7）<br>因为想使用vertical-align:middle，就要模拟表格：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">父元素:</span><br><span class="line">display:table</span><br><span class="line">子元素：</span><br><span class="line">display:table-cell</span><br><span class="line">vertical-align:middle;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li>多行文本垂直居中：vertical-align+（兼容IE6以上）<br>在IE6中对父元素进行定位后，如果再对子元素进行百分比计算时，计算的基础似乎是有继承性的（使用百分比计算的基础将不再是该元素的高度，而从父元素继承来的定位高度）。<br>父亲元素的外层： display:table;<br>父亲：top:50%<br>孩子：top:-50%<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">.wrap&#123;  </span><br><span class="line">    display:table;  </span><br><span class="line">    position:relative;  </span><br><span class="line">    overflow:hidden;  </span><br><span class="line">&#125;  </span><br><span class="line">父亲元素</span><br><span class="line">.subwrap&#123;  </span><br><span class="line">    vertical-align:middle;  </span><br><span class="line">    display:table-cell;  </span><br><span class="line">    position:absolute;  </span><br><span class="line">    top:50%;  </span><br><span class="line">&#125;  </span><br><span class="line">子元素 ：</span><br><span class="line">.content&#123;  </span><br><span class="line">    position:relative;  </span><br><span class="line">    top:-50%;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h2 id="flex弹性布局："><a href="#flex弹性布局：" class="headerlink" title="flex弹性布局："></a>flex弹性布局：</h2><ul>
<li>flex布局好处？不需要再给子元素设置定位，使用flex属性就可以让浏览器自己计算位置</li>
<li>父块元素：display: flex;</li>
<li>父行级元素：display: inline-flex;</li>
<li>设置了flex布局后，子元素的float、clear和vertical-align属性就会失效</li>
<li>具体描述：<br>设置了 flex的父亲成为：flex容器，孩子成为flex项目<ul>
<li>父亲容器属性：<ul>
<li>flex-direction(孩子横向还是竖向)：row(孩子水平)| row-reverse | column(孩子竖直) | column-reverse;</li>
<li>flex-wrap(孩子换行)：nowrap | wrap | wrap-reverse;</li>
<li>justify-content（孩子对齐方式）: flex-start | flex-end | center | space-between | space-around;</li>
<li>align-items: stretch|center|flex-start|flex-end|baseline|initial|inherit;</li>
<li>孩子項目屬性：<ul>
<li>order ：属性定义项目的排列顺序。数值越小，排列越靠前，默认为0</li>
<li>flex-grow：设置或检索弹性盒的扩展比率。根据弹性盒子元素所设值作为比率来分配剩余空间。</li>
<li>flex-shrink：属性定义了项目的缩小比例，默认为1，如果没有显示定义该属性，将会自动按照默认值1在所有因子相加之后计算比率来进行空间收缩。</li>
</ul>
</li>
<li>flex-basis：设置或检索弹性盒伸缩基准值，如果所有子元素的基准值之和大于剩余空间，则会根据每项设置的基准值，按比率伸缩剩余空间。<ul>
<li>align-self：属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>【问题】：<br>flex弹性盒模型，主轴有几个方向？后代 flex：1代表什么？</p>
<p>【答案】：</p>
<ul>
<li>flex 是 flex-grow、flex-shrink、flex-basis的缩写。故其取值可以考虑以下情况：</li>
<li>flex 的默认值是 0 1 auto</li>
<li>flex : none，则计算值为 0 0 auto</li>
<li>flex : auto，则计算值为 1 1 auto</li>
<li>flex :非负值，则该数字为 flex-grow 值，flex-shrink 取 1，flex-basis 取 0%</li>
<li>flex 长度或百分比，则视为 flex-basis 值，flex-grow 取 1，flex-shrink 取 1</li>
<li>flex : 非负值　非负值，则分别视为 flex-grow 和 flex-shrink 的值，flex-basis 取 0%，如下是等同的：</li>
</ul>
<hr>
<h2 id="浮动"><a href="#浮动" class="headerlink" title="浮动"></a>浮动</h2><ul>
<li>浮动元素会脱离文档流并向左/向右浮动（不在正常位置，并且他后面的不浮动元素会占他的位置），浮动直到碰到父元素或者另一个浮动元素。</li>
<li>浮动不会影响同级别普通元素的布局，同时也存在盖住普通元素的风险。</li>
<li>clear属性不允许被清除浮动的元素的左边/右边挨着浮动元素，底层原理是在被清除浮动的元素上边或者下边添加足够的清除空间。<br><img src="http://upload-images.jianshu.io/upload_images/2377897-a0f4eff0c7cd5c66.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></li>
</ul>
<h2 id="说一下为什么要清除浮动以及常见的清除浮动的方法-4"><a href="#说一下为什么要清除浮动以及常见的清除浮动的方法-4" class="headerlink" title="说一下为什么要清除浮动以及常见的清除浮动的方法 4%"></a>说一下为什么要清除浮动以及常见的清除浮动的方法 4%</h2><p>当一个内层元素是浮动的时候，如果没有关闭浮动时，其父元素也就不会再包含这个浮动的内层元素，因为此时浮动元素已经脱离了文档流。也就是为什么外层不能被撑开了！<br>（2）：边框不能撑开 （3）：margin ,padding设置值不能正确显示（1）：背景不能显示</p>
<h3 id="方法一：在被清除浮动元素内部末尾添加新元素-、应用-clear：both"><a href="#方法一：在被清除浮动元素内部末尾添加新元素-、应用-clear：both" class="headerlink" title="方法一：在被清除浮动元素内部末尾添加新元素 、应用 clear：both"></a>方法一：在被清除浮动元素内部末尾添加新元素 、应用 clear：both</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">div class=&quot;outer&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;div1&quot;&gt;1&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;div2&quot;&gt;2&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;div3&quot;&gt;3&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;clear&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">.clear&#123;clear:both; height: 0; line-height: 0; font-size: 0&#125;</span><br></pre></td></tr></table></figure>
<h3 id="方法二：触发BFC"><a href="#方法二：触发BFC" class="headerlink" title="方法二：触发BFC"></a>方法二：触发BFC</h3><p>父级div定义 overflow: hidden（hidden可以兼容IE，就是对seo不太友好,auto不可以兼容IE）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">父亲 </span><br><span class="line">.over-flow&#123;</span><br><span class="line">    overflow: hidden; // 是在处理兼容性问题</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>###方法三： clearfix:before,after<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 全浏览器通用的clearfix方案【推荐】</span><br><span class="line">// 同时加入:before以解决现代浏览器上边距折叠的问题</span><br><span class="line">.clearfix:before,</span><br><span class="line">.clearfix:after &#123;</span><br><span class="line">    display: table;//block</span><br><span class="line">    content: &quot; &quot;;// &apos;.&apos;</span><br><span class="line">&#125;</span><br><span class="line">.clearfix:after &#123;</span><br><span class="line">    clear: both;</span><br><span class="line">&#125;</span><br><span class="line">.clearfix&#123;</span><br><span class="line">    *zoom: 1;//引入了zoom以支持IE6/7</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><a href="https://my.oschina.net/leipeng/blog/221125" target="_blank" rel="external">https://my.oschina.net/leipeng/blog/221125</a><br><a href="http://www.jianshu.com/p/5138706046b1" target="_blank" rel="external">http://www.jianshu.com/p/5138706046b1</a><br><a href="http://www.jianshu.com/p/09bd5873bed4" target="_blank" rel="external">http://www.jianshu.com/p/09bd5873bed4</a></p>
<hr>
<h2 id="BFC"><a href="#BFC" class="headerlink" title="BFC"></a>BFC</h2><p>BFC可以做:BFC清除浮动，BFC解决垂直边距折叠<br>BFC全称是块状格式化上下文，它是按照块级盒子布局的。我们了解他的特征、触发方式、常见使用场景这些就够了。</p>
<p>BFC的主要特征</p>
<p>✦ BFC容器是一个隔离的容器，和其他元素互不干扰；所以我们可以用触发两个元素的BFC来解决垂直边距折叠问题。<br>✦ BFC可以包含浮动；通常用来解决浮动父元素高度坍塌的问题。</p>
<p>其中，BFC清除浮动就是用的“包含浮动”这条特性。<br>那么，怎样才能触发BFC呢？</p>
<p>BFC的触发方式</p>
<p>我们可以给父元素添加以下属性来触发BFC(一下任意一条就可以)：<br>✦ float 为 left | right(不为none)<br>✦ overflow 为 hidden | auto | scorll(不为visible   )<br>✦ display 为 table-cell | table-caption | inline-block | flex | inline-flex<br>✦ position 为 absolute | fixed</p>
<hr>
<h2 id="介绍一下标准的CSS的盒子模型？低版本IE的盒子模型有什么不同的？"><a href="#介绍一下标准的CSS的盒子模型？低版本IE的盒子模型有什么不同的？" class="headerlink" title="介绍一下标准的CSS的盒子模型？低版本IE的盒子模型有什么不同的？"></a>介绍一下标准的CSS的盒子模型？低版本IE的盒子模型有什么不同的？</h2><p>每个HTML元素都是长方形盒子。<br>  （1）有两种， IE 盒子模型、W3C 盒子模型；<br>  （2）盒模型： 内容(content)、填充(padding)、边界(margin)、 边框(border)；<br>  （3）区  别：<br> 标准盒模型的width为内容区的width，盒子总宽度：width+padding+border+margin<br> IE的width是内容区宽度+padding+border，盒子总宽度：width+margin</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2377897-2fc97e71155223a0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/2377897-502ce3aaecc4b38b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<hr>
<h2 id="position-的几种值-，详细说明一下每种的区别-3"><a href="#position-的几种值-，详细说明一下每种的区别-3" class="headerlink" title="position 的几种值 ，详细说明一下每种的区别 3%"></a>position 的几种值 ，详细说明一下每种的区别 3%</h2><ul>
<li>static    默认。位置设置为 static 的元素，它始终会处于页面流给予的位置（static 元素会忽略任何 top、bottom、left 或 right 声明）。</li>
<li>relative    位置被设置为 relative 的元素，可将其移至相对于其正常位置的地方，因此 “left:20” 会将元素移至元素正常位置左边 20 个像素的位置。</li>
<li>absolute    位置设置为 absolute 的元素，可定位于相对于包含它的元素的指定坐标。此元素的位置可通过 “left”、”top”、”right” 以及 “bottom” 属性来规定。</li>
<li>fixed    位置被设置为 fixed 的元素，可定位于相对于浏览器窗口的指定坐标。此元素的位置可通过 “left”、”top”、”right” 以及”bottom” 属性来规定。不论窗口滚动与否，元素都会留在那个位置。工作于 IE7（strict 模式）。</li>
</ul>
<hr>
<h2 id="如果position设置成absolute属性该元素的display属性会变成什么"><a href="#如果position设置成absolute属性该元素的display属性会变成什么" class="headerlink" title="如果position设置成absolute属性该元素的display属性会变成什么"></a>如果position设置成absolute属性该元素的display属性会变成什么</h2><ul>
<li>position: absolute,float会隐式的改变display类型， 不论之前是什么类型的元素（ display: none除外），<ul>
<li>只要设置了position: absolute或float， 都会让元素以display: inline - block的方式显示， 可以设置长宽，</li>
</ul>
</li>
<li>就算是显示的设置display: inline或display: block， 仍然无效。</li>
</ul>
<hr>
<h2 id="display-有几个值-3"><a href="#display-有几个值-3" class="headerlink" title="display 有几个值  3%"></a>display 有几个值  3%</h2><p>每个元素都有display属性，确定该元素的类型，<br>每个元素都有默认的display值，<br>如div的display默认值为“block”，则为“块级”元素；<br>span默认display属性值为“inline”，是“行内”元素。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2377897-0a9d9c4eb7fc996e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<hr>
<h2 id="伪类-伪元素"><a href="#伪类-伪元素" class="headerlink" title="伪类 伪元素"></a>伪类 伪元素</h2><p>伪类是给元素模拟添加类 ，来实现某种效果（：）<br>常见伪类：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2377897-394530a71e54ed9f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<p>伪元素是模拟添加个元素来实现效果（::）(css3出现后做的区分)<br>常见伪元素：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2377897-e655b83124da94d9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<p><a href="http://web.jobbole.com/86181/" target="_blank" rel="external">http://web.jobbole.com/86181/</a></p>
<hr>
<h2 id="CSS3新增伪类有那些？"><a href="#CSS3新增伪类有那些？" class="headerlink" title="CSS3新增伪类有那些？"></a>CSS3新增伪类有那些？</h2><pre><code>举例：
  p:first-of-type    选择属于其父元素的首个 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。
  p:last-of-type    选择属于其父元素的最后 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。
  p:only-of-type    选择属于其父元素唯一的 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。
  p:only-child        选择属于其父元素的唯一子元素的每个 &lt;p&gt; 元素。
  p:nth-child(2)    选择属于其父元素的第二个子元素的每个 &lt;p&gt; 元素。

 inptut
    :enabled          
   :disabled         控制表单控件的禁用状态。
  :checked        单选框或复选框被选中。
</code></pre><hr>
<h2 id="CSS选择器有哪些？哪些属性可以继承？"><a href="#CSS选择器有哪些？哪些属性可以继承？" class="headerlink" title="CSS选择器有哪些？哪些属性可以继承？"></a>CSS选择器有哪些？哪些属性可以继承？</h2><pre><code> 1.id选择器（ # myid）
2.类选择器（.myclassname）
3.标签选择器（div, h1, p）
4.相邻选择器（h1 + p）
5.子选择器（ul &gt; li）
6.后代选择器（li a）
7.通配符选择器（ * ）
8.属性选择器（a[rel = &quot;external&quot;]）
9.伪类选择器（a:hover, li:nth-child）
</code></pre><ul>
<li><p>可继承的样式： font-size font-family color, UL LI DL DD DT;</p>
</li>
<li><p>不可继承的样式：border padding margin width height ;</p>
</li>
</ul>
<hr>
<h2 id="CSS优先级算法如何计算？"><a href="#CSS优先级算法如何计算？" class="headerlink" title="CSS优先级算法如何计算？"></a>CSS优先级算法如何计算？</h2><ul>
<li>优先级就近原则，同权重情况下样式定义最近者为准;</li>
<li>载入样式以最后载入的定位为准;<h3 id="同权重"><a href="#同权重" class="headerlink" title="同权重"></a>同权重</h3><ul>
<li>1、 位于 &lt; head / &gt; 标签里的 &lt; style / &gt; 中所定义的CSS拥有最高级的优先权。　　</li>
<li>2、 第二级的优先属性由位于 &lt; style / &gt; 标签中的 @import 引入样式表所定义。　　</li>
<li>3、 第三级的优先属性由 &lt; link / &gt; 标签所引入的样式表定义。</li>
<li>4、 第四级的优先属性由 &lt; link / &gt; 标签所引入的样式表内的 @import 导入样式表定义。　　</li>
<li>5、 第五级优先的样式有用户设定。　　 最低级的优先权由浏览器默认。 </li>
</ul>
</li>
</ul>
<p>权重的进制是256</p>
<h3 id="属性选择器的权重问题"><a href="#属性选择器的权重问题" class="headerlink" title="属性选择器的权重问题:"></a>属性选择器的权重问题:</h3><pre><code>// !important ---------&gt;   无穷
// 行间样式-------------&gt;   1000
// id------------------&gt;   100
// class|属性|伪类------&gt;   10
// 标签|伪元素 ---------&gt;    1
// 通配符---------------&gt;   0
</code></pre><hr>
<h2 id="页面导入样式时，使用link和-import有什么区别？"><a href="#页面导入样式时，使用link和-import有什么区别？" class="headerlink" title="页面导入样式时，使用link和@import有什么区别？"></a>页面导入样式时，使用link和@import有什么区别？</h2><p>1 : 属于link属于xml 标签，除了加载css以外，还能定义rss和rel等 。@import是css提供的，只能用于加载css<br>2 :页面加载页面在加载时候，link同时被加载；而@import引用的css等页面加载完毕再加载<br>3：兼容性@import是CSS2.1 提出的，只在IE5以上才能被识别，而link是XHTML标签，无兼容问题;<br>4：link方式的样式权重高于@import的权重。<br>5：使用dom控制样式时的差别。当使用javascript控制dom去改变样式的时候，只能使用link标签，因为@import不是dom可以控制的。<br>6：. 最后一个很有意思， @import url有最大次数的限制， IE6最多引入31次， firefox并没有发现<br>7： @import的优点： 多个样式表导入一个样式表中， 页面只需要引入一个即可</p>
<hr>
<h2 id="引入css的几种方式-2"><a href="#引入css的几种方式-2" class="headerlink" title="引入css的几种方式 2%"></a>引入css的几种方式 2%</h2><h3 id="1-行内样式"><a href="#1-行内样式" class="headerlink" title="1.行内样式"></a>1.行内样式</h3><p>最直接最简单的一种，直接对HTML标签使用style=””，例如：</p>
<p style="color:#F00; "></p>

<p>缺点：HTML页面不纯净，文件体积大，不利于蜘蛛爬行，后期维护不方便。</p>
<h3 id="2-内嵌样式"><a href="#2-内嵌样式" class="headerlink" title="2.内嵌样式"></a>2.内嵌样式</h3><p>内嵌样式就是将CSS代码写在<head></head>之间，并且用<style></style>进行声明，例如：</p>
<style type="text/css">

body,div,a,img,p{margin:0; padding:0;}

</style>

<p>优缺点：页面使用公共CSS代码，也是每个页面都要定义的，如果一个网站有很多页面，每个文件都会变大，后期维护难度也大，如果文件很少，CSS代码也不多，这种样式还是很不错的。</p>
<h3 id="3-链接样式"><a href="#3-链接样式" class="headerlink" title="3.链接样式"></a>3.链接样式</h3><p>链接样式是使用频率最高，最实用的样式，只需要在<head></head>之间加上<link…>就可以了，如下：</link…></p>
<link type="text/css" rel="stylesheet" href="style.css">

<p>优缺点：实现了页面框架代码与表现CSS代码的完全分离，使得前期制作和后期维护都十分方便</p>
<h3 id="4-导入样式（不建议使用）"><a href="#4-导入样式（不建议使用）" class="headerlink" title="4.导入样式（不建议使用）"></a>4.导入样式（不建议使用）</h3><p>导入样式和链接样式比较相似，采用@import样式导入CSS样式表，在HTML初始化时，会被导入到HTML或者CSS文件中，成为文件的一部分，类似第二种内嵌样式。</p>
<ul>
<li>@import在html中使用，如下：</li>
</ul>
<style type="text/css">
@import url(style.css);
</style>

<ul>
<li>@import在CSS中使用，如下：</li>
</ul>
<p>@import url(style.css);</p>
<h3 id="四种CSS引入方式的优先级"><a href="#四种CSS引入方式的优先级" class="headerlink" title="四种CSS引入方式的优先级"></a>四种CSS引入方式的优先级</h3><p>1.就近原则<br>2.理论上：行内&gt;内嵌&gt;链接&gt;导入<br>3.实际上：内嵌、链接、导入在同一个文件头部，谁离相应的代码近，谁的优先级高</p>
<hr>
<h2 id="锚点-1"><a href="#锚点-1" class="headerlink" title="锚点 1%"></a>锚点 1%</h2><p>html 锚点 到底是干吗的？<br>通俗简单地说，比如一篇很长的文章，你想按分段精确来看，那就可以用到锚点了<br>代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href=&quot;#001&quot;&gt;跳到001&lt;/a&gt;</span><br><span class="line">...文字省略</span><br><span class="line">&lt;a name=&quot;001&quot; id=&quot;001&quot; &gt;&lt;/a&gt;</span><br><span class="line">...文字省略</span><br></pre></td></tr></table></figure></p>
<p>(兼容到ie8)<br>其实锚点只需name就可以可，加id是为了让它兼容性更好.<br>href的值要跟name \ i d 一致，前面必须加”#”，以上代码在ie6/7,ff中都可以兼容，但在ie8中就不行。<br>因为我们锚点的<a></a>值为空，为不影响美观我们加个空格就行了,</p>
<p>另一问题，想显示某页面(如：123.html)的某锚点内容呢？ </p>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">代码如下</span><br><span class="line">&lt;a href=&quot;123.html#001&quot;&gt;跳到001&lt;/a&gt;</span><br><span class="line">...文字省略</span><br><span class="line">&lt;a name=&quot;001&quot; id=&quot;001&quot; &gt; &lt;/a&gt;</span><br><span class="line">...文字省略</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="两栏布局（左固定，右自适应）"><a href="#两栏布局（左固定，右自适应）" class="headerlink" title="两栏布局（左固定，右自适应）"></a>两栏布局（左固定，右自适应）</h2><h3 id="1-float-margin"><a href="#1-float-margin" class="headerlink" title="1:float+margin"></a>1:float+margin</h3><p>左定宽高左浮动， 右设置margin - left:左边宽<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.left &#123;</span><br><span class="line">    width: 100 px;</span><br><span class="line">    height: 100 px;</span><br><span class="line">    float: left;</span><br><span class="line">&#125;</span><br><span class="line">.right &#123;</span><br><span class="line">    height: 100 px;</span><br><span class="line">    margin - left: 100 px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="2：float-BFC"><a href="#2：float-BFC" class="headerlink" title="2：float+BFC"></a>2：float+BFC</h3><p>左定宽高左浮动，右触发BFC</p>
<h3 id="3-left-0-left-左宽-right-0"><a href="#3-left-0-left-左宽-right-0" class="headerlink" title="3:left:0,left:-左宽,right:0;"></a>3:left:0,left:-左宽,right:0;</h3><p>左定宽高 ,设置定位position absolute, left 0 ;<br>        .left {<br>            width: 100 px;<br>            height: 100 px;<br>            background - color: red;<br>            position: absolute;<br>            left: 0;<br>        }<br>        .right {<br>            height: 100 px;<br>            background - color: green;<br>            right: 0;<br>        }</p>
<h3 id="三个元素都浮动，左定宽高，右宽-cal-100-x"><a href="#三个元素都浮动，左定宽高，右宽-cal-100-x" class="headerlink" title="三个元素都浮动，左定宽高，右宽 cal(100%-x)"></a>三个元素都浮动，左定宽高，右宽 cal(100%-x)</h3><hr>
<h2 id="实现三列布局（两边固定，中间自适应）"><a href="#实现三列布局（两边固定，中间自适应）" class="headerlink" title="实现三列布局（两边固定，中间自适应）"></a>实现三列布局（两边固定，中间自适应）</h2><p>1：绝对定位法：左右绝对定位，left:0,right:0,中间margin: 0 x;<br>此方法的优点是，理解容易，上手简单，受内部元素影响而破坏布局的概率低，就是比较经得起折腾。<br>缺点在于：如果中间栏含有最小宽度限制.布局可能受内部影响。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">.con &#123;</span><br><span class="line">       overflow: hidden;</span><br><span class="line">       height: 500px;</span><br><span class="line">   &#125;</span><br><span class="line">   .left,.right &#123;</span><br><span class="line">       width: 200px;</span><br><span class="line">       height: 100%;</span><br><span class="line">       position: absolute;</span><br><span class="line">       top: 0;//为了防止将后一个块级元素挤下去</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   .left &#123;</span><br><span class="line">       left: 0;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   .right &#123;</span><br><span class="line">       right: 0；</span><br><span class="line">   &#125;</span><br><span class="line">.main &#123;</span><br><span class="line">       margin: 0 210px;</span><br><span class="line">       overflow: hidden;</span><br><span class="line">       height: 100%;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>2：浮动方法：左右各浮动+中设margin<br>简便，但是灵活性低下<br>dom顺序有限制：因为左右浮动的缘故，只能将mid放在左右后面<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">    .con &#123;</span><br><span class="line">        overflow: hidden;</span><br><span class="line">        height: 500px;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    .main &#123;</span><br><span class="line">        height: 100%;</span><br><span class="line">        margin: 0 210px;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    .left,</span><br><span class="line">    .right &#123;</span><br><span class="line">        width: 200px;</span><br><span class="line">        height: 100%;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    .left &#123;</span><br><span class="line">        float: left;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    .right &#123;</span><br><span class="line">        float: right;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">    &lt;div class=&quot;con&quot;&gt;</span><br><span class="line"></span><br><span class="line">        &lt;div class=&quot;left&quot;&gt;我是左边&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">        &lt;div class=&quot;right&quot;&gt;我是右边&lt;/div&gt;</span><br><span class="line">        &lt;div class=&quot;main&quot;&gt;</span><br><span class="line"></span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure></p>
<p>3:flex，将mid设置属性flex:1<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">.con &#123;</span><br><span class="line">        height: 500px;</span><br><span class="line">        display: flex;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    .main &#123;</span><br><span class="line">        height: 100%;</span><br><span class="line">        flex: 1;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    .left,</span><br><span class="line">    .right &#123;</span><br><span class="line">        width: 200px;</span><br><span class="line">        height: 100%;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>4：圣杯布局：三个都浮动+左右margin负值<br>优点：三栏相互关联，可谓真正意义上的自适应，有一定的抗性——布局不易受内部影响。<br>缺点：相对比较难理解些，上手不容易，代码相对复杂。出现百分比宽度，过多的负值定位，如果出现布局的bug，排查不易。<br>【dom结构】：先自适应的div，然后再左右顺序可以不定<br>mid外层: width:100%，float:left<br>mid :margin 0 x;<br>左右 左浮动<br>第一个兄弟：margin-left:-100%<br>第二个兄弟：margin-left:-xpx;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;con&quot;&gt;</span><br><span class="line">        &lt;div class=&quot;main&quot;&gt;</span><br><span class="line">            &lt;div class=&quot;main-con&quot;&gt;</span><br><span class="line">                我是中间</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">        &lt;div class=&quot;left&quot;&gt;我是左边&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">        &lt;div class=&quot;right&quot;&gt;我是右边&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">    &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">.con &#123;</span><br><span class="line">        overflow: hidden;</span><br><span class="line">        height: 500px;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    .mid-wraper &#123;</span><br><span class="line">        width: 100%;</span><br><span class="line">        height: 100%;</span><br><span class="line">        float: left;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    .mid &#123;</span><br><span class="line">        margin: 0 210px;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    .left,</span><br><span class="line">    .right &#123;</span><br><span class="line">        width: 200px;</span><br><span class="line">        height: 100%;</span><br><span class="line">        float: left;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    .left &#123;</span><br><span class="line">        margin-left: -100%</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    .right &#123;</span><br><span class="line">        margin-left: -220px;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="BFC的通俗理解："><a href="#BFC的通俗理解：" class="headerlink" title="BFC的通俗理解："></a>BFC的通俗理解：</h2><ul>
<li>Block Formatting Context（ 块级格式化上下文） 是W3C CSS 2.1 规范中的一个概念， 它决定了元素如何对其内容进行定位， 以及与其他元素的关系和相互作用。 简单来讲， 我们可以把它理解为， 我们在进行盒模型布局的时候， 如果一个元素符合了成为BFC的条件，<ul>
<li>该元素成为一个隔离了的独立容器， 元素内部元素会垂直的沿着其父元素的边框排列， 和外部元素互不影响。 比如浮动元素会触发BFC，<br>浮动元素内部的子元素主要受到该浮动元素的影响， 而两个浮动元素之间是互不影响的。</li>
<li>在CSS3 中， BFC 叫做Flow Root。 在早期的ie中也有类似的概念haslayout IE6、 7 的很多布局产生的bug（ 如3px间隙、 绝对定位的继承宽度）都可以通过触发hasLayout修复， 比较推荐的方法为zoom: 1 与height: 1 % ，不会破坏已有的样式， 相信大家对它并不陌生。</li>
<li>同样的以往集中在float、 绝对定位、 margin collaspe中的很多困惑， 在理解了bfc后， 都能够被我们一一解除。<h2 id="BFC规范中的定义："><a href="#BFC规范中的定义：" class="headerlink" title="BFC规范中的定义："></a>BFC规范中的定义：</h2>w3c规范对BFC的解释：</li>
<li>浮动元素和绝对定位元素， 不是块级盒子的块容器（ 如 inline - blocks, table - cells, 和 table - captions）， 以及设置了overflow属性（ 除了visible）的块级盒子， 都会为他们的内容创建新的BFC（ 块级格式上下文）。<ul>
<li>在BFC中， 盒子从顶端开始垂直地 一个接一个地排列， 两个盒子之间的垂直的间隙是由他们的margin 值所决定的。 在一个BFC中， 两个相邻的块级盒子的</li>
<li>垂直外边距会产生折叠。 在BFC中， 每一个盒子的左外边缘（ margin - left） 会触碰到容器的左边缘(border - left)（ 对于从右到左的格式来说， 则触碰到右边缘）。</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre><code>    触发BFC的方法：(任一即可)

float 元素
position（ absolute， fixed）
display(table - cell， table - caption， inline - block)
overflow 除了visible 以外的值（ hidden， auto， scroll）
fieldset元素
早期IE的hasLayout会触发一个新的block formatting context
</code></pre><h3 id="BFC的特性"><a href="#BFC的特性" class="headerlink" title="BFC的特性"></a>BFC的特性</h3><ul>
<li>边缘不和浮动元素重叠</li>
<li>不存在collapsing margins问题</li>
<li>第一个特性特别有用， 因为元素触发了BFC的话， 就不会被float元素覆盖， 当子元素全部浮动的时候也能够正确地包含了<ul>
<li>第二个margin不会叠加的特性， 可以理解为两个处于普通流的盒子， 会有margin叠加的问题， 是因为他们属于相同的BFC， 当他自身创建了一个新的BFC时， 这个问题就不存在了<h3 id="BFC的常见应用"><a href="#BFC的常见应用" class="headerlink" title="BFC的常见应用"></a>BFC的常见应用</h3><ol>
<li>通过边缘不和浮动元素重叠的特性， 实现两栏结构。</li>
<li>清除元素内部浮动</li>
<li>解决合并外边距的问题</li>
</ol>
</li>
</ul>
</li>
</ul>
<hr>
<h2 id="常见的浏览器端的存储技术都有哪些，以及他们的优缺点和使用场景？"><a href="#常见的浏览器端的存储技术都有哪些，以及他们的优缺点和使用场景？" class="headerlink" title="常见的浏览器端的存储技术都有哪些，以及他们的优缺点和使用场景？"></a>常见的浏览器端的存储技术都有哪些，以及他们的优缺点和使用场景？</h2><p>有时需要将网页中的一些数据保存在浏览器端，这样做的好处是，当下次访问页面时，不需要再次向服务器请求数据，直接就可以从本地读取数据。目前常用的有以下几种方法：</p>
<h3 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a><strong>cookie</strong></h3><p>cookie会随着每次HTTP请求头信息一起发送，无形中增加了网络流量，另外，cookie能存储的数据容量有限，根据浏览器类型不同而不同，IE6大约只能存储2K，cookie数据大小不能超过4k</p>
<h3 id="Flash-ShareObject"><a href="#Flash-ShareObject" class="headerlink" title="Flash ShareObject"></a><strong>Flash ShareObject</strong></h3><p>这种方式能能解决上面提到的cookie存储的两个弊端，而且能够跨浏览器，应该说是目前最好的本地存储方案。不过，需要在页面中插入一个Flash，当浏览器没有安装Flash控件时就不能用了。所幸的是，没有安装Flash的用户极少。<br>缺点：需要安装Flash插件。</p>
<h3 id="sessionStorage"><a href="#sessionStorage" class="headerlink" title="sessionStorage"></a><strong>sessionStorage</strong></h3><p>使用于Firefox2+的火狐浏览器，用这种方式存储的数据仅窗口级别有效，同一个窗口（或者Tab）页面刷新或者跳转，都能获取到本地存储的数据，当新开窗口或者页面时，原来的数据就失效了。<br>缺点：IE不支持、不能实现数据的持久保存。</p>
<h3 id="localStorage"><a href="#localStorage" class="headerlink" title="localStorage"></a><strong>localStorage</strong></h3><p>localStorage是Web Storage互联网存储规范中的一部分，现在在Firefox 3.5、Safari 4和IE8中得到支持。<br>缺点：低版本浏览器不支持。</p>
<p>提示：localStorage储存的值都是字符串类型，使用时要注意。另外，可以在浏览器调试器中的Resources的localStorage中看到储存的信息。</p>
<blockquote>
<p>//存储信息   （存储的信息名称，要存储的字符串）<br>localStorage.setItem(“CC_email_list”,input_eamil[i])<br>//读取信息   （要读取的信息名称）<br>localStorage.getItem(“CC_email_list”)<br>//清除信息    （要清除的信息名称）<br>localStorage.removeItem(“CC_email_list”);</p>
</blockquote>
<h3 id="globalStorage"><a href="#globalStorage" class="headerlink" title="globalStorage"></a><strong>globalStorage</strong></h3><p>使用于Firefox2+的火狐浏览器，类似于IE的userData。<br>1 //赋值 2 globalStorage[location.hostname][‘name’] = ‘tugai’; 3 //读取 4 globalStorage[location.hostname][‘name’]; 5 //删除 6 globalStorage[location.hostname].removeItem(‘name’);</p>
<h3 id="Google-Gear"><a href="#Google-Gear" class="headerlink" title="Google Gear"></a><strong>Google Gear</strong></h3><p>Google开发出的一种本地存储技术。<br>缺点：需要安装Gear组件。</p>
<h3 id="userData"><a href="#userData" class="headerlink" title="userData"></a><strong>userData</strong></h3><p>IE浏览器可以使用userData来存储数据，容量可达到640K，这种方案是很可靠的，不需要安装额外的插件。缺点：它仅在IE下有效。<br>缺点：IE不支持。</p>
<p>结论：Flash shareobject是不错的选择，如果你不想在页面上嵌入Flash，可以结合使用userData(IE6+)和globalStorage(Firefox2+)和localStorage(chrome3+)实现跨浏览器。</p>
<hr>
<h2 id="请描述一下-cookies，sessionStorage-和-localStorage-的区别？"><a href="#请描述一下-cookies，sessionStorage-和-localStorage-的区别？" class="headerlink" title="请描述一下 cookies，sessionStorage 和 localStorage 的区别？"></a>请描述一下 cookies，sessionStorage 和 localStorage 的区别？</h2><pre><code>cookie是网站为了标示用户身份而储存在用户本地终端（Client Side）上的数据（通常经过加密）。
cookie数据始终在同源的http请求中携带（即使不需要），记会在浏览器和服务器间来回传递。
sessionStorage和localStorage不会自动把数据发给服务器，仅在本地保存。
</code></pre><h3 id="存储大小："><a href="#存储大小：" class="headerlink" title="存储大小："></a>存储大小：</h3><pre><code>cookie数据大小不能超过4k。
sessionStorage和localStorage 虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大。
</code></pre><h3 id="有期时间："><a href="#有期时间：" class="headerlink" title="有期时间："></a>有期时间：</h3><pre><code>localStorage    存储持久数据，浏览器关闭后数据不丢失除非主动删除数据；
sessionStorage  数据在当前浏览器窗口关闭后自动删除。
cookie          设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭
</code></pre><hr>
<h1 id="HTML5"><a href="#HTML5" class="headerlink" title="HTML5"></a>HTML5</h1><h2 id="新特性"><a href="#新特性" class="headerlink" title="新特性"></a>新特性</h2><h3 id="1-标签语义化，"><a href="#1-标签语义化，" class="headerlink" title="1:标签语义化，"></a>1:标签语义化，</h3><p>比如header，footer，nav，aside，article，section等，新增了很多表单元素，入email，url等，除去了center等样式标签，还有除去了有性能问题的frame，frameset等标签</p>
<h3 id="2、音视频元素，"><a href="#2、音视频元素，" class="headerlink" title="2、音视频元素，"></a>2、音视频元素，</h3><p>video，audio的增加使得我们不需要在依赖外部的插件就可以往网页中加入音视频元素。</p>
<h3 id="3、新增很多api，"><a href="#3、新增很多api，" class="headerlink" title="3、新增很多api，"></a>3、新增很多api，</h3><p>比如获取用户地理位置的window.navigator.geoloaction</p>
<h3 id="、websocket"><a href="#、websocket" class="headerlink" title="、websocket"></a>、websocket</h3><p>websocket是伴随html5到来的基于tcp/ip的全双工通信的协议。<br>主要通信过程：先借http完成握手，达到了长连接<br>第一步：浏览器基于tcp，发送http请求<br>第二步：服务器端，接收到请求后。将 tcp用户网络层协议变为websocket协议，完成了握手<br>第三步：服务器端和浏览器完成握手，他们之间形成一条通道，可以源源不断的传送信息<br>websocket是一种协议，可以让我们建立客户端到服务器端的全双工通信，这就意味着服务器端可以主动推送数据到客户端。</p>
<hr>
<h3 id="、HTML5-能够本地存储数据，在之前都是使用-cookies-使用的。"><a href="#、HTML5-能够本地存储数据，在之前都是使用-cookies-使用的。" class="headerlink" title="、HTML5 能够本地存储数据，在之前都是使用 cookies 使用的。"></a>、HTML5 能够本地存储数据，在之前都是使用 cookies 使用的。</h3><p>HTML5 提供了下面本地存储方案：webstorage包括localeStorage和sessionStorage，localeStorage是持久化存储在客户端，只要用户不主动删除，就不会消失，sessionStorage也是存储在客户端，但是他的存在时间是一个回话，一旦浏览器的关于该回话的页面关闭了，sessionStorage就消失了，</p>
<hr>
<h3 id="：请描述一下-cookies，sessionStorage-和-localStorage-的区别？"><a href="#：请描述一下-cookies，sessionStorage-和-localStorage-的区别？" class="headerlink" title="：请描述一下 cookies，sessionStorage 和 localStorage 的区别？"></a>：请描述一下 cookies，sessionStorage 和 localStorage 的区别？</h3><p>  cookie是网站为了标示用户身份而储存在客户端上的数据（通常经过加密）。<br>  cookie数据始终在同源的http请求中携带（即使不需要），记会在浏览器和服务器间来回传递。<br>  sessionStorage和localStorage不会自动把数据发给服务器，仅在本地保存。</p>
<p>  存储大小：<br>      cookie数据大小不能超过4k。<br>      sessionStorage和localStorage 虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大。</p>
<p>  有期时间：<br>      localStorage    存储持久数据，浏览器关闭后数据不丢失除非主动删除数据；<br>      sessionStorage  数据在当前浏览器窗口关闭后自动删除。<br>      cookie  在过期时间之前一直有效，即使窗口或浏览器关闭</p>
<hr>
<h3 id="、应用程序缓存："><a href="#、应用程序缓存：" class="headerlink" title="、应用程序缓存："></a>、应用程序缓存：</h3><p>在用户没有与因特网连接时，可以正常访问站点或应用，在用户与因特网连接时，更新用户机器上的缓存文件。<br>  原理：HTML5的离线存储是基于一个新建的.appcache文件的缓存机制(不是存储技术)，通过这个文件上的解析清单离线存储资源，这些资源就会像cookie一样被存储了下来。之后当网络在处于离线状态下时，浏览器会通过被离线存储的数据进行页面展示。</p>
<p>html5允许我们自己控制哪些文件需要缓存，哪些不需要，具体的做法如下：</p>
<p>1、首先给html添加manifest属性，并赋值为cache.manifest<br>2、cache.manifest的内容为:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">  CACHE MANIFEST</span><br><span class="line">  #v1.2</span><br><span class="line">  CACHE :           //表示需要缓存的文件</span><br><span class="line">    a.js</span><br><span class="line">    b.js</span><br><span class="line">NETWORK:    //表示只在用户在线的时候才需要的文件，不会缓存</span><br><span class="line">  c.js</span><br><span class="line">FALLBACK</span><br><span class="line">/        /index.html     //表示如果找不到第一个资源就用第二个资源代替</span><br></pre></td></tr></table></figure></p>
<hr>
<h3 id="、web-worker，web-worker"><a href="#、web-worker，web-worker" class="headerlink" title="、web worker，web worker"></a>、web worker，web worker</h3><p>是运行在浏览器后台的js程序，他不影响主程序的运行，是另开的一个js线程，可以用这个线程执行复杂的数据操作，然后把操作结果通过postMessage传递给主线程，这样在进行复杂且耗时的操作时就不会阻塞主线程了。</p>
<hr>
<h1 id="CSS3"><a href="#CSS3" class="headerlink" title="CSS3"></a>CSS3</h1><ul>
<li>css3的新特性哪些，你都用过哪些 5%<h2 id="媒体查询具体到语句-5"><a href="#媒体查询具体到语句-5" class="headerlink" title="媒体查询具体到语句 5%"></a>媒体查询具体到语句 5%</h2>作用：媒体查询可以让我们根据设备显示器的特性（如视口宽度、屏幕比例、设备方向：横向或纵向）为其设定CSS样式，检测的媒体特性有 width 、 height 和 color （等）。</li>
</ul>
<h2 id="响应式布局meta-scale-怎样使用media"><a href="#响应式布局meta-scale-怎样使用media" class="headerlink" title="响应式布局meta,scale 怎样使用media?"></a>响应式布局meta,scale 怎样使用media?</h2><h3 id="meta-scale"><a href="#meta-scale" class="headerlink" title="meta,scale"></a>meta,scale</h3><p>第一步：<br> 首先需要在html文档中添加以下代码，用来兼容移动设备的显示效果</p>
<meta name="viewport content=" width="device-width,initial-scale=1,maximum-scale=1,user-scalable=no"/">

ps:
>width=device-width:宽度等于当前设备的宽度
initial-scale=1：初始的缩放比例（默认为1）
maximum-scale=1：允许用户缩放到得最大比例（默认为1）
user-scalable=no：用户不能手动缩放

### 第二步：媒体查询 语句
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@media screen and (max-width:720px) and (min-width:320px)&#123;</span><br><span class="line"></span><br><span class="line">      body&#123;</span><br><span class="line"></span><br><span class="line">       background-color:red;</span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">@media screen and (max-width:320px)&#123;</span><br><span class="line"></span><br><span class="line">      body&#123;</span><br><span class="line"></span><br><span class="line">         background-color:blue;</span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

## css 伪类 5%
### 伪类选择器
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">p:first-of-type	选择属于其父元素的首个 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。</span><br><span class="line">p:last-of-type	选择属于其父元素的最后 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。</span><br><span class="line">p:only-of-type	选择属于其父元素唯一的 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。</span><br><span class="line">p:only-child		选择属于其父元素的唯一子元素的每个 &lt;p&gt; 元素。</span><br><span class="line">p:nth-child(2)	选择属于其父元素的第二个子元素的每个 &lt;p&gt; 元素。</span><br></pre></td></tr></table></figure>

***
### 伪类 伪元素
伪类是给元素模拟添加类 ，来实现某种效果（：）
常见伪类：

![Paste_Image.png](http://upload-images.jianshu.io/upload_images/2377897-394530a71e54ed9f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

伪元素是模拟添加个元素来实现效果（::）(css3出现后做的区分)
常见伪元素：

![Paste_Image.png](http://upload-images.jianshu.io/upload_images/2377897-e655b83124da94d9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

http://web.jobbole.com/86181/

## 说一下flex 3%
### 请解释一下CSS3的Flexbox（弹性盒布局模型）,以及适用场景？
 一个用于页面布局的全新CSS3功能，Flexbox可以把列表放在同一个方向（从上到下排列，从左到右），并让列表能延伸到占用可用的空间。
   较为复杂的布局还可以通过嵌套一个伸缩容器（flex container）来实现。
   采用Flex布局的元素，称为Flex容器（flex container），简称"容器"。
   它的所有子元素自动成为容器成员，称为Flex项目（flex item），简称"项目"。
   常规布局是基于块和内联流方向，而Flex布局是基于flex-flow流可以很方便的用来做局中，能对不同屏幕大小自适应。
   在布局上有了比以前更加灵活的空间
http://www.w3cplus.com/css3/flexbox-basics.html

***
## 动画 2%

  二维动画——animation  这个属性必须配合@keyframes动画关键帧来使用。keyframes里面包含一个百分数，后面跟上在这段时间内变换的css样式。
     animation是一个复合属性，它包括以下几个组成部分：
   * 1.animation-name：执行动画的keyframes的名字。
    * 2.animation-duration：执行动画的总时长。
    * 3.animation-timing-function：指定过渡函数。
    * 4.animation-delay：执行延迟时间。
    *  5.animation-direction：动画播放的方式。这个属性的值主要有：normal正常播放模式、reverse倒序播放、alternate
                  动画在奇数次正向播放偶数次倒序播放、alternate-reverse动画在奇数次倒序播放偶数次正向播放。
     *  6.animation-iteration-count：动画执行的次数。infinite是无限次，写一个数字就是要执行几次。
      *  7.animation-fill-mode：执行完动画后物体停止的位置。forwards是停在结束的位置上、backwards是快速执行初始帧
                  （这个最好配合延迟来观察）、
                  none是回到初始帧的位置、both是同时具有forwards和backwards的效果。
        *  8.animation-play-state：控制动画的播放状态。running是播放、paused是暂停。
***
## css3动画卡了

    transform: transition3d(0, 0, 0);
    transform: translateZ(0);
    这两个属性可以开启GPU加速模式
    然而面试官问我为什么，你知道原理么？
    这两个属性都会开启GPU硬件加速模式，从而让浏览器在渲染动画的时候从CPU转向GPU
## less
*  Less 有了解过吗？有什么好处？
   什么是CSS 预处理器 / 后处理器？
    * 预处理器例如：LESS、Sass、Stylus，用来预编译Sass或less，增强了css代码的复用性，
    还有层级、mixin、变量、循环、函数等，具有很方便的UI组件模块化开发能力，极大的提高工作效率。
   * 后处理器例如：PostCSS，通常被视为在完成的样式表中根据CSS规范处理CSS，让其更有效；目前最常做的是给CSS属性添加浏览器私有前缀，实现跨浏览器兼容性的问题。
## 常见的浏览器端的存储技术都有哪些，以及他们的优缺点和使用场景？
有时需要将网页中的一些数据保存在浏览器端，这样做的好处是，当下次访问页面时，不需要再次向服务器请求数据，直接就可以从本地读取数据。目前常用的有以下几种方法：
### **cookie**
cookie会随着每次HTTP请求头信息一起发送，无形中增加了网络流量，另外，cookie能存储的数据容量有限，根据浏览器类型不同而不同，IE6大约只能存储2K，cookie数据大小不能超过4k
### **Flash ShareObject**
这种方式能能解决上面提到的cookie存储的两个弊端，而且能够跨浏览器，应该说是目前最好的本地存储方案。不过，需要在页面中插入一个Flash，当浏览器没有安装Flash控件时就不能用了。所幸的是，没有安装Flash的用户极少。
缺点：需要安装Flash插件。
### **sessionStorage**
使用于Firefox2+的火狐浏览器，用这种方式存储的数据仅窗口级别有效，同一个窗口（或者Tab）页面刷新或者跳转，都能获取到本地存储的数据，当新开窗口或者页面时，原来的数据就失效了。
缺点：IE不支持、不能实现数据的持久保存。
### **localStorage**
localStorage是Web Storage互联网存储规范中的一部分，现在在Firefox 3.5、Safari 4和IE8中得到支持。
缺点：低版本浏览器不支持。

提示：localStorage储存的值都是字符串类型，使用时要注意。另外，可以在浏览器调试器中的Resources的localStorage中看到储存的信息。
>//存储信息   （存储的信息名称，要存储的字符串）
localStorage.setItem("CC_email_list",input_eamil[i])
//读取信息   （要读取的信息名称）
localStorage.getItem("CC_email_list")
//清除信息    （要清除的信息名称）
localStorage.removeItem("CC_email_list");

### **globalStorage**
使用于Firefox2+的火狐浏览器，类似于IE的userData。
1 //赋值 2 globalStorage[location.hostname]['name'] = 'tugai'; 3 //读取 4 globalStorage[location.hostname]['name']; 5 //删除 6 globalStorage[location.hostname].removeItem('name');
### **Google Gear**
Google开发出的一种本地存储技术。
缺点：需要安装Gear组件。
### **userData**
IE浏览器可以使用userData来存储数据，容量可达到640K，这种方案是很可靠的，不需要安装额外的插件。缺点：它仅在IE下有效。
缺点：IE不支持。

结论：Flash shareobject是不错的选择，如果你不想在页面上嵌入Flash，可以结合使用userData(IE6+)和globalStorage(Firefox2+)和localStorage(chrome3+)实现跨浏览器。
***
## 请描述一下 cookies，sessionStorage 和 localStorage 的区别？

    cookie是网站为了标示用户身份而储存在用户本地终端（Client Side）上的数据（通常经过加密）。
    cookie数据始终在同源的http请求中携带（即使不需要），记会在浏览器和服务器间来回传递。
    sessionStorage和localStorage不会自动把数据发给服务器，仅在本地保存。
### 存储大小：
        cookie数据大小不能超过4k。
        sessionStorage和localStorage 虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大。
### 有期时间：
        localStorage    存储持久数据，浏览器关闭后数据不丢失除非主动删除数据；
        sessionStorage  数据在当前浏览器窗口关闭后自动删除。
        cookie          设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭

***
## html 获取页面，浏览器，屏幕宽高
一个页面的展示，从外到内的容器为：屏幕->浏览器->页面本身。
HTML元素展现在页面内->页面展现在浏览器内->而浏览器展现在屏幕内。
通过Js的一些对象可以获取这些容器的高度、宽度。
1：总

![Paste_Image.png](http://upload-images.jianshu.io/upload_images/2377897-c6dff4f74e7f2eb3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)


2:屏幕
![Paste_Image.png](http://upload-images.jianshu.io/upload_images/2377897-f47a188d60bd97a4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
3:浏览器

![Paste_Image.png](http://upload-images.jianshu.io/upload_images/2377897-8e3d9af0d6d264b0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

![Paste_Image.png](http://upload-images.jianshu.io/upload_images/2377897-5e416993bde1fdb7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)


5:可视区 
定义：可视区域是指能显示网页内容区域的宽高。
拉动控制台的时候网页可视区域的宽高也会随之改变。
可视区宽高跟内容宽高没关系。

如果内容超过可视区域的高度或者宽度就出现滚动条。要获取可视区域的宽高每个浏览器的获取方法不一样

[参照](http://www.cnblogs.com/polk6/p/5051935.html)
***
## Doctype
1.Doctype作用
位置：<!DOCTYPE>声明位于html第一行
作用： 告知浏览器用什么标准解析html文档
            <!DOCTYPE>不存在，或者格式不正确，会导致文档以兼容模 (怪异模式)式出现

语法：
      HTML 顶级元素 可用性 "注册//组织//类型 标签//定义 语言""URL"
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN"> 
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Strict//EN">

其中，DTD的是W3C所发布的一个文档类型定义，简单的说，就是告诉浏览器你的这个HTML，是根据那个标准写的，解析的时候用哪个标准解析。




http://www.qdfuns.com/notes/21146/12ba5b538dd5974b1bee88f77c71b0a0.html
***

##为什么HTML5就只要写<!DOCTYPE HTML>?
HTML 4.01 中的 doctype 需要对 DTD 进行引用，因为 HTML 4.01 基于 SGML。 HTML 5 不基于 SGML，因此不需要对 DTD 进行引用，但是需要 doctype 来规范浏览器的行为。
其中，SGML是标准通用标记语言,简单的说，就是比HTML,XML更老的标准，这两者都是由SGML发展而来的。BUT，HTML5不是的。
***
## 标准模式与兼容模式（怪异模式）各有什么区别?

A：在标准模式中，浏览器根据规范呈现页面；在混杂模式中，页面以一种比较宽松向后兼容的方式显示。简单的说，就是尽可能的显示能显示的东西给用户看。（但是会有些样式失效）

1：width不同
在严格模式中 ：width是内容宽度 ，元素真正的宽度 = width+（padding+border+margin）2
在兼容模式中 ：width则是元素的实际宽度 ，内容宽度 = width - ( padding2+border2)

2.兼容模式下可设置百分比的高度和行内元素的高宽
    在Standards模式下，给span等行内元素设置wdith和height都不会生效，而在兼容模式下，则会生效。
    在standards模式下，一个元素的高度是由其包含的内容来决定的，如果父元素没有设置高度，子元素设置一个百分比的高度是无效的。

3.用margin:0 auto设置水平居中在IE下会失效
    使用margin:0 auto在standards模式下可以使元素水平居中，但在兼容模式下却会失效（用text-align属性解决）
    body{text-align:center};#content{text-align:left}

4.兼容模式下Table中的字体属性不能继承上层的设置，white-space:pre会失效，设置图片的padding会失效

***
## 介绍一下你对浏览器内核的理解？
主要分成两部分：渲染引擎(layout engineer或Rendering Engine)和JS引擎。
  渲染引擎：负责取得网页的内容（HTML、XML、图像等等）、整理讯息（例如加入CSS等），以及计算网页的显示方式，然后会输出至显示器或打印机。浏览器的内核的不同对于网页的语法解释会有不同，所以渲染的效果也不相同。所有网页浏览器、电子邮件客户端以及其它需要编辑、显示网络内容的应用程序都需要内核。

JS引擎则：解析和执行javascript来实现网页的动态效果。
***
常见的浏览器内核有哪些？
 Trident内核：IE,MaxThon,TT,The World,360,搜狗浏览器等。[又称MSHTML]
  Gecko内核：Netscape6及以上版本，FF,MozillaSuite/SeaMonkey等
  Presto内核：Opera7及以上。      [Opera内核原为：Presto，现为：Blink;]
  Webkit内核：Safari,Chrome等。   [ Chrome的：Blink（WebKit的分支）]
***
## HTML、XML、XHTML 有什么区别？
HTML是被设计用来显示数据的，重点是:显示数据以及如何显示数据更好上面。
XML是被设计用来描述数据的，重点是:什么是数据，如何存放数据。
XHTML基于HTML的基础上进行了扩展和规范，让XHTML更加严格，主要目的是促进HTML向XML过渡。

HTML的弊端：
编码不规范，结构混乱臃肿，需要智能的终端才能很好的显示；
表现和结构混乱，不利于开发和维护；
不能使用于更多的网络设备中，比如手机；
为了让HTML逐渐过渡到XML阶段，w3c又定制了XHTML标准。

而XML的弊端也不少：
在数据中寻找信息非常难
大数据量效率低
使用XML传输数据时没有数据库系统那样的信息管理功能
因此XML因为自身严苛限制等因素逐渐被HTML5取代。
***
## 怎样理解 HTML 语义化？
HTML语义化能提高网页语义的清晰度，方便爬虫工具识别网站内容，爬虫工具在识别网站内容时不会受到网站样式的影响，只会关注网站内容本身
HTML的语义化能够提高团队对网站的维护和改进效率
改善网页的可访问性，遇到视觉障碍用户时屏幕阅读器能够更好的系别网页内容

***
## iframe有那些缺点？

  * iframe会阻塞主页面的Onload事件；
  * 搜索引擎的检索程序无法解读这种页面，不利于SEO;

  * iframe和主页面共享连接池，而浏览器对相同域的连接有限制，所以会影响页面的并行加载。

  使用iframe之前需要考虑这两个缺点。如果需要使用iframe，最好是通过javascript
  动态给iframe添加src属性值，这样可以绕开以上两个问题。
***

## 为什么要初始化CSS样式。
- 因为浏览器的兼容问题，不同浏览器对有些标签的默认值是不同的，如果没对CSS初始化往往会出现浏览器之间的页面显示差异。

  - 当然，初始化样式会对SEO有一定的影响，但鱼和熊掌不可兼得，但力求影响最小的情况下初始化。
淘宝的样式初始化代码：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">body, h1, h2, h3, h4, h5, h6, hr, p, blockquote, dl, dt, dd, ul, ol, li, pre, form, fieldset, legend, button, input, textarea, th, td &#123; margin:0; padding:0; &#125;</span><br><span class="line">body, button, input, select, textarea &#123; font:12px/1.5tahoma, arial, \5b8b\4f53; &#125;</span><br><span class="line">h1, h2, h3, h4, h5, h6&#123; font-size:100%; &#125;</span><br><span class="line">address, cite, dfn, em, var &#123; font-style:normal; &#125;</span><br><span class="line">code, kbd, pre, samp &#123; font-family:couriernew, courier, monospace; &#125;</span><br><span class="line">small&#123; font-size:12px; &#125;</span><br><span class="line">ul, ol &#123; list-style:none; &#125;</span><br><span class="line">a &#123; text-decoration:none; &#125;</span><br><span class="line">a:hover &#123; text-decoration:underline; &#125;</span><br><span class="line">sup &#123; vertical-align:text-top; &#125;</span><br><span class="line">sub&#123; vertical-align:text-bottom; &#125;</span><br><span class="line">legend &#123; color:#000; &#125;</span><br><span class="line">fieldset, img &#123; border:0; &#125;</span><br><span class="line">button, input, select, textarea &#123; font-size:100%; &#125;</span><br><span class="line">table &#123; border-collapse:collapse; border-spacing:0; &#125;</span><br></pre></td></tr></table></figure>

## 用纯CSS创建一个三角形的原理是什么？
 把上、左、右三条边隐藏掉（颜色设为 transparent）

>  #demo {
    width: 0;
    height: 0;
    border-width: 20px;
    border-style: solid;
    border-color: transparent transparent red transparent;
  }
***
## 经常遇到的浏览器的兼容性有哪些？原因，解决方法是什么，常用hack的技巧 ？
 * png24位的图片在iE6浏览器上出现背景，解决方案是做成PNG8.

  * 浏览器默认的margin和padding不同。解决方案是加一个全局的*{margin:0;padding:0;}来统一。

  * IE6双边距bug:块属性标签float后，又有横行的margin情况下，在ie6显示margin比设置的大。

    浮动ie产生的双倍距离 #box{ float:left; width:10px; margin:0 0 0 100px;}

    这种情况之下IE会产生20px的距离，解决方案是在float的标签样式控制中加入 ——_display:inline;将其转化为行内属性。(_这个符号只有ie6会识别)

    渐进识别的方式，从总体中逐渐排除局部。

    首先，巧妙的使用“\9”这一标记，将IE游览器从所有情况中分离出来。
    接着，再次使用“+”将IE8和IE7、IE6分离开来，这样IE8已经独立识别。

    css
        .bb{
            background-color:red;/*所有识别*/
            background-color:#00deff\9; /*IE6、7、8识别*/
            +background-color:#a200ff;/*IE6、7识别*/
            _background-color:#1e0bd1;/*IE6识别*/
        }


  *  IE下,可以使用获取常规属性的方法来获取自定义属性,
     也可以使用getAttribute()获取自定义属性;
     Firefox下,只能使用getAttribute()获取自定义属性。
     解决方法:统一通过getAttribute()获取自定义属性。

  *  IE下,even对象有x,y属性,但是没有pageX,pageY属性;
     Firefox下,event对象有pageX,pageY属性,但是没有x,y属性。

  *  解决方法：（条件注释）缺点是在IE浏览器下可能会增加额外的HTTP请求数。

  *  Chrome 中文界面下默认会将小于 12px 的文本强制按照 12px 显示,
     可通过加入 CSS 属性 -webkit-text-size-adjust: none; 解决。

  超链接访问过后hover样式就不出现了 被点击访问过的超链接样式不在具有hover和active了解决方法是改变CSS属性的排列顺序:
  L-V-H-A :  a:link {} a:visited {} a:hover {} a:active {}
***
## 什么是外边距合并？
外边距合并指的是，当两个垂直外边距相遇时，它们将形成一个外边距。
  合并后的外边距的高度等于两个发生合并的外边距的高度中的较大者。
  w3school介绍网址： http://www.w3school.com.cn/css/css_margin_collapsing.asp
***
## zoom:1的清除浮动原理?
清除浮动，触发hasLayout；
  Zoom属性是IE浏览器的专有属性，它可以设置或检索对象的缩放比例。解决ie下比较奇葩的bug。
  譬如外边距（margin）的重叠，浮动清除，触发ie的haslayout属性等。

  来龙去脉大概如下：
  当设置了zoom的值之后，所设置的元素就会就会扩大或者缩小，高度宽度就会重新计算了，这里一旦改变zoom值时其实也会发生重新渲染，运用这个原理，也就解决了ie下子元素浮动时候父元素不随着自动扩大的问题。

  Zoom属是IE浏览器的专有属性，火狐和老版本的webkit核心的浏览器都不支持这个属性。然而，zoom现在已经被逐步标准化，出现在 CSS 3.0 规范草案中。

  目前非ie由于不支持这个属性，它们又是通过什么属性来实现元素的缩放呢？
  可以通过css3里面的动画属性scale进行缩放。 
  ***
## 如何居中div？

水平居中：给div设置一个宽度，然后添加margin:0 auto属性

 div{
     width:200px;
     margin:0 auto;
  }
让绝对定位的div居中

 div {
     position: absolute;
     width: 300px;
     height: 300px;
     margin: auto;
     top: 0;
     left: 0;
     bottom: 0;
     right: 0;
     background-color: pink;    /* 方便看效果 */
 }

水平垂直居中一

 确定容器的宽高 宽500 高 300 的层
 设置层的外边距

 div {
     position: relative;        /* 相对定位或绝对定位均可 */
     width:500px;
     height:300px;
     top: 50%;
     left: 50%;
     margin: -150px 0 0 -250px;         /* 外边距为自身宽高的一半 */
     background-color: pink;         /* 方便看效果 */

  }

水平垂直居中二

 未知容器的宽高，利用 `transform` 属性

 div {
     position: absolute;        /* 相对定位或绝对定位均可 */
     width:500px;
     height:300px;
     top: 50%;
     left: 50%;
     transform: translate(-50%, -50%);
     background-color: pink;         /* 方便看效果 */

 }

水平垂直居中三

 利用 flex 布局
 实际使用时应考虑兼容性

 .container {
     display: flex;
     align-items: center;         /* 垂直居中 */
     justify-content: center;    /* 水平居中 */

 }
 .container div {
     width: 100px;
     height: 100px;
     background-color: pink;        /* 方便看效果 */
 } 
## position的值relative和absolute定位原点是？

    absolute
      生成绝对定位的元素，相对于值不为 static的第一个父元素进行定位。
    fixed （老IE不支持）
      生成绝对定位的元素，相对于浏览器窗口进行定位。
    relative
      生成相对定位的元素，相对于其正常位置进行定位。
    static
      默认值。没有定位，元素出现在正常的流中（忽略 top, bottom, left, right z-index 声明）。
    inherit
      规定从父元素继承 position 属性的值。
***

# HTML5
## 新特性
### 1:标签语义化，
比如header，footer，nav，aside，article，section等，新增了很多表单元素，入email，url等，除去了center等样式标签，还有除去了有性能问题的frame，frameset等标签

### 2、音视频元素，
video，audio的增加使得我们不需要在依赖外部的插件就可以往网页中加入音视频元素。

### 3、新增很多api，
比如获取用户地理位置的window.navigator.geoloaction

### 、websocket
websocket是伴随html5到来的基于tcp/ip的全双工通信的协议。
主要通信过程：先借http完成握手，达到了长连接
第一步：浏览器基于tcp，发送http请求
第二步：服务器端，接收到请求后。将 tcp用户网络层协议变为websocket协议，完成了握手
第三步：服务器端和浏览器完成握手，他们之间形成一条通道，可以源源不断的传送信息
websocket是一种协议，可以让我们建立客户端到服务器端的全双工通信，这就意味着服务器端可以主动推送数据到客户端。
***
### 、HTML5 能够本地存储数据，在之前都是使用 cookies 使用的。
HTML5 提供了下面本地存储方案：webstorage包括localeStorage和sessionStorage，localeStorage是持久化存储在客户端，只要用户不主动删除，就不会消失，sessionStorage也是存储在客户端，但是他的存在时间是一个回话，一旦浏览器的关于该回话的页面关闭了，sessionStorage就消失了，
***
### ：请描述一下 cookies，sessionStorage 和 localStorage 的区别？
  cookie是网站为了标示用户身份而储存在客户端上的数据（通常经过加密）。
  cookie数据始终在同源的http请求中携带（即使不需要），记会在浏览器和服务器间来回传递。
  sessionStorage和localStorage不会自动把数据发给服务器，仅在本地保存。

  存储大小：
      cookie数据大小不能超过4k。
      sessionStorage和localStorage 虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大。

  有期时间：
      localStorage    存储持久数据，浏览器关闭后数据不丢失除非主动删除数据；
      sessionStorage  数据在当前浏览器窗口关闭后自动删除。
      cookie  在过期时间之前一直有效，即使窗口或浏览器关闭
## 具体应用
### cookie:
document.cookie = name, value, expires, domain, path, secure
encodeURIComponent
decodeURIComponent(document.cookie.substring(cookieStart + cookieName.length, cookieEnd)
### localStoragey用法
localStorage储存的值都是字符串类型，使用时要注意。另外，可以在浏览器调试器中的Resources的localStorage中看到储存的信息。
>//存储信息   （存储的信息名称，要存储的字符串）
storage = window.localStorage
storage.setItem("CC_email_list",input_eamil[i])
//读取信息   （要读取的信息名称）
storage.getItem("CC_email_list")
//清除信息    （要清除的信息名称）
storage.removeItem("CC_email_list");
storage.clear();
### sessionStorage:
sessionStorage用法和localStorage完全一致，差别只在有效期：

***

### 1.什么是cookie？
    答：cookie是用于在客户端存储会话信息的。
### 4.如何操作cookie？
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">var CookieUtil = &#123;</span><br><span class="line">    // 设置cookie</span><br><span class="line">    set : function (name, value, expires, domain, path, secure) &#123;</span><br><span class="line">        var cookieText = &quot;&quot;;</span><br><span class="line">        cookieText += encodeURIComponent(name) + &quot;=&quot; + encodeURIComponent(value);</span><br><span class="line">        if (expires instanceof Date) &#123;</span><br><span class="line">            cookieText += &quot;; expires=&quot; + expires.toGMTString();</span><br><span class="line">        &#125;</span><br><span class="line">        if (path) &#123;</span><br><span class="line">            cookieText += &quot;; path=&quot; + path;</span><br><span class="line">        &#125;</span><br><span class="line">        if (domain) &#123;</span><br><span class="line">            cookieText += &quot;; domain=&quot; + domain;</span><br><span class="line">        &#125;</span><br><span class="line">        if (secure) &#123;</span><br><span class="line">            cookieText += &quot;; secure&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        document.cookie = cookieText;</span><br><span class="line">    &#125;,</span><br><span class="line">    // name=value; expires=expiration_time; path=domain_path; domain=domain_name; secure</span><br><span class="line">    // 获取cookie</span><br><span class="line">    get : function (name) &#123;</span><br><span class="line">        var cookieName = encodeURIComponent(name) + &quot;=&quot;,</span><br><span class="line">            cookieStart = document.cookie.indexOf(cookieName),</span><br><span class="line">            cookieValue = &quot;&quot;;</span><br><span class="line">        if (cookieStart &gt; -1) &#123;</span><br><span class="line">            var cookieEnd = document.cookie.indexOf (&quot;;&quot;, cookieStart);</span><br><span class="line">            if (cookieEnd == -1) &#123;</span><br><span class="line">                cookieEnd = document.cookie.length;</span><br><span class="line">            &#125;</span><br><span class="line">            cookieValue = decodeURIComponent(document.cookie.substring(cookieStart + cookieName.length, cookieEnd));</span><br><span class="line">        &#125;</span><br><span class="line">        return cookieValue; </span><br><span class="line">    &#125;,</span><br><span class="line">    // 删除cookie</span><br><span class="line">    unset : function (name, domain, path, secure) &#123;</span><br><span class="line">        this.set(name, &quot;&quot;, Date(0), domain, path, secure);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">// 测试</span><br><span class="line">CookieUtil.set(&quot;name&quot;, &quot;zhang&quot;);</span><br><span class="line">var name = CookieUtil.get(&quot;name&quot;);</span><br><span class="line">alert(name);    // zhang</span><br><span class="line">CookieUtil.unset(&quot;name&quot;);</span><br><span class="line">alert(CookieUtil.get(&quot;name&quot;));  // 空</span><br></pre></td></tr></table></figure>

### 2.cookie的组成部分？
    ①名称：一个唯一确定cookie 的名称。建议区分大小写。cookie 的名称必须是经过URL 编码的。
    ②值：储存在cookie 中的字符串值。值必须被URL 编码。
    ③域：cookie 对于哪个域是有效的。所有向该域发送的请求中都会包含这个cookie 信息。这个值可以包含子域（subdomain，如www.wrox.com），也可以不包含它（如.wrox.com，则对于wrox.com的所有子域都有效）。如果没有明确设定，那么这个域会被认作来自设置cookie 的那个域。
    ④路径：对于指定域中的那个路径，应该向服务器发送cookie。例如，你可以指定cookie 只有从http://www.wrox.com/books/ 中才能访问，那么http://www.wrox.com 的页面就不会发送cookie 信息，即使请求都是来自同一个域的。
    ⑤失效时间：表示cookie 何时应该被删除的时间戳。默认情况下，浏览器会话结束时即将所有cookie 删除；不过也可以自己设置删除时间。这个值是个GMT 格式的日期（Wdy, DD-Mon-YYYY HH:MM:SS GMT），用于指定应该删除cookie 的准确时间。因此，cookie 
    可在浏览器关闭后依然保存在用户的机器上。如果你设置的失效日期是个以前的时间，则cookie 会被立刻删除。
    ⑥安全标志：指定后，cookie 只有在使用SSL 连接的时候才发送到服务器。例如，cookie 信息只能发送给https://www.wrox.com，而http://www.wrox.com 的请求则不能发送cookie。
### 3.列举一个cookie的例子？
    以下是一个完整的cookie的例子，我们将把它分解开来：
    Set-Cookie: name=value; expires=Mon, 22-Jan-07 07:10:24 GMT; domain=.wrox.com; path=/; secure
    ①名称: name字符串表示
    ②值：value字符串表示
    ③过期时间：Mon, 22-Jan-07 07:10:24 GMT
    ④域名：.wrox.com
    ⑤路径：当前目录/
    ⑥安全标志：secure
***
### 、应用程序缓存：
在用户没有与因特网连接时，可以正常访问站点或应用，在用户与因特网连接时，更新用户机器上的缓存文件。
  原理：HTML5的离线存储是基于一个新建的.appcache文件的缓存机制(不是存储技术)，通过这个文件上的解析清单离线存储资源，这些资源就会像cookie一样被存储了下来。之后当网络在处于离线状态下时，浏览器会通过被离线存储的数据进行页面展示。

html5允许我们自己控制哪些文件需要缓存，哪些不需要，具体的做法如下：

1、首先给html添加manifest属性，并赋值为cache.manifest
2、cache.manifest的内容为: 
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">  CACHE MANIFEST</span><br><span class="line">  #v1.2</span><br><span class="line">  CACHE :           //表示需要缓存的文件</span><br><span class="line">    a.js</span><br><span class="line">    b.js</span><br><span class="line">NETWORK:    //表示只在用户在线的时候才需要的文件，不会缓存</span><br><span class="line">  c.js</span><br><span class="line">FALLBACK</span><br><span class="line">/        /index.html     //表示如果找不到第一个资源就用第二个资源代替</span><br></pre></td></tr></table></figure>

***
### 、web worker，web worker
是运行在浏览器后台的js程序，他不影响主程序的运行，是另开的一个js线程，可以用这个线程执行复杂的数据操作，然后把操作结果通过postMessage传递给主线程，这样在进行复杂且耗时的操作时就不会阻塞主线程了。
***
### 标签页的通信
localstorge在一个标签页里被添加、修改或删除时，都会触发一个storage事件，通过在另一个标签页里监听storage事件，即可得到localstorge存储的值，实现不同标签页之间的通信。
标签页1：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;input id=&quot;name&quot;&gt;  </span><br><span class="line">&lt;input type=&quot;button&quot; id=&quot;btn&quot; value=&quot;提交&quot;&gt;  </span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;  </span><br><span class="line">    $(function()&#123;    </span><br><span class="line">        $(&quot;#btn&quot;).click(function()&#123;    </span><br><span class="line">            var name=$(&quot;#name&quot;).val();    </span><br><span class="line">            localStorage.setItem(&quot;name&quot;, name);   </span><br><span class="line">        &#125;);    </span><br><span class="line">    &#125;);    </span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

标签页2：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;  </span><br><span class="line">    $(function()&#123;   </span><br><span class="line">        window.addEventListener(&quot;storage&quot;, function(event)&#123;    </span><br><span class="line">            console.log(event.key + &quot;=&quot; + event.newValue);    </span><br><span class="line">        &#125;);     </span><br><span class="line">    &#125;);  </span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

使用cookie+setInterval，将要传递的信息存储在cookie中，每隔一定时间读取cookie信息，即可随时获取要传递的信息。
标签页1： 
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;input id=&quot;name&quot;&gt;  </span><br><span class="line">&lt;input type=&quot;button&quot; id=&quot;btn&quot; value=&quot;提交&quot;&gt;  </span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;  </span><br><span class="line">    $(function()&#123;    </span><br><span class="line">        $(&quot;#btn&quot;).click(function()&#123;    </span><br><span class="line">            var name=$(&quot;#name&quot;).val();    </span><br><span class="line">            document.cookie=&quot;name=&quot;+name;    </span><br><span class="line">        &#125;);    </span><br><span class="line">    &#125;);    </span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

标签页2：  
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;  </span><br><span class="line">    $(function()&#123;   </span><br><span class="line">        function getCookie(key) &#123;    </span><br><span class="line">            return JSON.parse(&quot;&#123;\&quot;&quot; + document.cookie.replace(/;\s+/gim,&quot;\&quot;,\&quot;&quot;).replace(/=/gim, &quot;\&quot;:\&quot;&quot;) + &quot;\&quot;&#125;&quot;)[key];    </span><br><span class="line">        &#125;     </span><br><span class="line">        setInterval(function()&#123;    </span><br><span class="line">            console.log(&quot;name=&quot; + getCookie(&quot;name&quot;));    </span><br><span class="line">        &#125;, 10000);    </span><br><span class="line">    &#125;);  </span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

# 重排重绘
## 浏览器从下载文档到显示页面的过程
  * 浏览器引擎会解析HTML文档来构建DOM树
  * 根据DOM元素的几何属性构建一棵用于渲染的树
渲染树的每个节点都有大小和边距等属性，类似于盒子模型（由于隐藏元素不需要显示，渲染树中并不包含DOM树中隐藏的元素）。当渲染树构建完成后，浏览器就可以将元素放置到正确的位置了
  * 根据渲染树节点的样式属性绘制出页面。
## 重绘redraw
重绘是一个元素外观的改变所触发的浏览器行为，例如改变visibility、背景色等属性。浏览器会根据元素的新属性重新绘制，使元素呈现新的外观。
重绘不会带来重新布局，并不一定伴随重排。
## 重排
重排是几何上的改变，可以理解为渲染树需要重新计算。
###  触发重排：
   * 1.DOM元素的几何属性变化（定位，位置）
      * 渲染树中的相关节点就会失效，重新构建渲染树中失效的节点，根据新的渲染树重新绘制这部分页面
       * 例如：动画
       * 一个元素重排可能会使其他元素重排重绘
    * 2.DOM树的结构变化（dom增删，移动）
        * 例如节点的增减、移动等，也会触发重排
     * 3.获取某些属性（offsetWidth和offsetHeight）
　浏览器引擎可能会针对重排做了优化。比如Opera，它会等到有足够数量的变化发生，或者等到一定的时间，或者等一个线程结束，再一起处理，这样就只发生一次重排。但除了渲染树的直接变化，当获取一些属性时，浏览器为取得正确的值也会触发重排。这样就使得浏览器的优化失效了。这些属性包括：offsetTop、offsetLeft、 offsetWidth、offsetHeight、scrollTop、scrollLeft、scrollWidth、scrollHeight、clientTop、clientLeft、clientWidth、clientHeight、getComputedStyle() (currentStyle in IE)。
所以，在多次使用这些值时应进行缓存。

### 减少重排
 * 将多次改变样式属性封装成一个类，用js加上类
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">div.changeDiv &#123;</span><br><span class="line">background: #eee;</span><br><span class="line">color: #093;</span><br><span class="line">height: 200px;</span><br><span class="line">&#125;</span><br><span class="line">document.getElementById(‘changeDiv’).className = ‘changeDiv’;</span><br></pre></td></tr></table></figure>

   * 将需要多次重排的元素，position属性设为absolute或fixed
这样此元素就脱离了文档流，它的变化不会影响到其他元素。例如有动画效果的元素就最好设置为绝对定位。
* 最小化DOM深度
减少你的DOM树的大小和每个分支的元素数量。你的文档越小，越浅，重排就会越快。如果你不支持旧版的浏览器，可能你要移除不需要的包裹元素。
* 保证n次创建，1次写入。
例如要异步获取表格数据，渲染到页面。可以先取得数据后在内存中构建整个表格的html片段，再一次性添加到文档中去，而不是循环添加每一行。
* dom 复杂操作时，先隐藏，再显示
由于display属性为none的元素不在渲染树中，对隐藏的元素操作不会引发其他元素的重排。如果要对一个元素进行复杂的操作时，可以先隐藏它，操作完成后再显示。这样只在隐藏和显示时触发2次重排。
* 
在多次使用这些值时应进行缓存。
## 表格排序考虑到减少重排重绘
保证n次创建，1次写入。

***
# CSS3
## css3的新特性哪些，你都用过哪些 5%
CSS3有哪些新内容，请至少说出5个。

   1）border-radius。CSS3圆角表格

   2）font-effect。以往对网页上的文字加特效只能用filter属性，但是在CSS3中专门制定了一个加文字特效的属性，而且不止加阴影这种效果。

   3）text-underline-style，text-underline-color，text-underline-mode，text-underline-position。丰富了对链接下划线的样式，以往的下划线都是直线，这次可不一样了，有波浪线、点线、虚线等等，更可对下划线的颜色和
位置进行任意改变，哈哈~~下划线的世界从此不再单一。（还有对应顶线和中横线的样式，效果与下划线类似）

   4）font-emphasize-style和font-emphasize-position。我们在做笔记时经常要在文字下点几个点或打个圈什么的，以示重点，CSS3也开始加入了这项功能，这应该在某些特定网页上很有用。

   5）Font-face可以用来加载字体样式，而且它还能够加载服务器端的字体文件，显示客户端没有安装的字体。
***
## 媒体查询具体到语句 5%
作用：媒体查询可以让我们根据设备显示器的特性（如视口宽度、屏幕比例、设备方向：横向或纵向）为其设定CSS样式，检测的媒体特性有 width 、 height 和 color （等）。

##  响应式布局meta,scale 怎样使用media?
### meta,scale
第一步：
 首先需要在html文档中添加以下代码，用来兼容移动设备的显示效果
<meta name="viewport content=" width="device-width,initial-scale=1,maximum-scale=1,user-scalable=no"/">

<p>ps:</p>
<blockquote>
<p>width=device-width:宽度等于当前设备的宽度<br>initial-scale=1：初始的缩放比例（默认为1）<br>maximum-scale=1：允许用户缩放到得最大比例（默认为1）<br>user-scalable=no：用户不能手动缩放</p>
</blockquote>
<h3 id="第二步：媒体查询-语句"><a href="#第二步：媒体查询-语句" class="headerlink" title="第二步：媒体查询 语句"></a>第二步：媒体查询 语句</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@media screen and (max-width:720px) and (min-width:320px)&#123;</span><br><span class="line"></span><br><span class="line">      body&#123;</span><br><span class="line"></span><br><span class="line">       background-color:red;</span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">@media screen and (max-width:320px)&#123;</span><br><span class="line"></span><br><span class="line">      body&#123;</span><br><span class="line"></span><br><span class="line">         background-color:blue;</span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="css-伪类-5"><a href="#css-伪类-5" class="headerlink" title="css 伪类 5%"></a>css 伪类 5%</h2><h3 id="伪类选择器"><a href="#伪类选择器" class="headerlink" title="伪类选择器"></a>伪类选择器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">p:first-of-type	选择属于其父元素的首个 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。</span><br><span class="line">p:last-of-type	选择属于其父元素的最后 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。</span><br><span class="line">p:only-of-type	选择属于其父元素唯一的 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。</span><br><span class="line">p:only-child		选择属于其父元素的唯一子元素的每个 &lt;p&gt; 元素。</span><br><span class="line">p:nth-child(2)	选择属于其父元素的第二个子元素的每个 &lt;p&gt; 元素。</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="伪类-伪元素-1"><a href="#伪类-伪元素-1" class="headerlink" title="伪类 伪元素"></a>伪类 伪元素</h3><p>伪类是给元素模拟添加类 ，来实现某种效果（：）<br>常见伪类：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2377897-394530a71e54ed9f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<p>伪元素是模拟添加个元素来实现效果（::）(css3出现后做的区分)<br>常见伪元素：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2377897-e655b83124da94d9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<p><a href="http://web.jobbole.com/86181/" target="_blank" rel="external">http://web.jobbole.com/86181/</a></p>
<h2 id="说一下flex-3"><a href="#说一下flex-3" class="headerlink" title="说一下flex 3%"></a>说一下flex 3%</h2><h3 id="请解释一下CSS3的Flexbox（弹性盒布局模型）-以及适用场景？"><a href="#请解释一下CSS3的Flexbox（弹性盒布局模型）-以及适用场景？" class="headerlink" title="请解释一下CSS3的Flexbox（弹性盒布局模型）,以及适用场景？"></a>请解释一下CSS3的Flexbox（弹性盒布局模型）,以及适用场景？</h3><p> 一个用于页面布局的全新CSS3功能，Flexbox可以把列表放在同一个方向（从上到下排列，从左到右），并让列表能延伸到占用可用的空间。<br>   较为复杂的布局还可以通过嵌套一个伸缩容器（flex container）来实现。<br>   采用Flex布局的元素，称为Flex容器（flex container），简称”容器”。<br>   它的所有子元素自动成为容器成员，称为Flex项目（flex item），简称”项目”。<br>   常规布局是基于块和内联流方向，而Flex布局是基于flex-flow流可以很方便的用来做局中，能对不同屏幕大小自适应。<br>   在布局上有了比以前更加灵活的空间<br><a href="http://www.w3cplus.com/css3/flexbox-basics.html" target="_blank" rel="external">http://www.w3cplus.com/css3/flexbox-basics.html</a></p>
<hr>
<h2 id="动画-2"><a href="#动画-2" class="headerlink" title="动画 2%"></a>动画 2%</h2><p>  二维动画——animation  这个属性必须配合@keyframes动画关键帧来使用。keyframes里面包含一个百分数，后面跟上在这段时间内变换的css样式。<br>     animation是一个复合属性，它包括以下几个组成部分：</p>
<ul>
<li>1.animation-name：执行动画的keyframes的名字。<ul>
<li>2.animation-duration：执行动画的总时长。</li>
<li>3.animation-timing-function：指定过渡函数。</li>
<li>4.animation-delay：执行延迟时间。</li>
<li>5.animation-direction：动画播放的方式。这个属性的值主要有：normal正常播放模式、reverse倒序播放、alternate<pre><code>动画在奇数次正向播放偶数次倒序播放、alternate-reverse动画在奇数次倒序播放偶数次正向播放。
</code></pre></li>
<li>6.animation-iteration-count：动画执行的次数。infinite是无限次，写一个数字就是要执行几次。<ul>
<li>7.animation-fill-mode：执行完动画后物体停止的位置。forwards是停在结束的位置上、backwards是快速执行初始帧<pre><code>（这个最好配合延迟来观察）、
none是回到初始帧的位置、both是同时具有forwards和backwards的效果。
</code></pre></li>
<li>8.animation-play-state：控制动画的播放状态。running是播放、paused是暂停。</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h2 id="css3动画卡了"><a href="#css3动画卡了" class="headerlink" title="css3动画卡了"></a>css3动画卡了</h2><pre><code>transform: transition3d(0, 0, 0);
transform: translateZ(0);
这两个属性可以开启GPU加速模式
然而面试官问我为什么，你知道原理么？
这两个属性都会开启GPU硬件加速模式，从而让浏览器在渲染动画的时候从CPU转向GPU。
</code></pre><hr>
<h1 id="移动端"><a href="#移动端" class="headerlink" title="移动端"></a>移动端</h1><p><a href="https://www.v2ex.com/t/359985?p=1" target="_blank" rel="external">https://www.v2ex.com/t/359985?p=1</a><br><a href="http://caibaojian.com/vw-vh.html" target="_blank" rel="external">http://caibaojian.com/vw-vh.html</a><br><a href="https://aotu.io/notes/2017/04/28/2017-4-28-CSS-viewport-units/" target="_blank" rel="external">https://aotu.io/notes/2017/04/28/2017-4-28-CSS-viewport-units/</a></p>
<h2 id="移动端适配："><a href="#移动端适配：" class="headerlink" title="移动端适配："></a>移动端适配：</h2><ul>
<li>通常<br>通常使用响应式布局和弹性布局+媒体查询配置多个响应断点<br>缺陷：布局在响应断点范围内的分辨率下维持不变，而在响应断点切换的瞬间，布局带来断层式的切换变化，如同卡带的唱机般“咔咔咔”地一下又一下。</li>
<li>rem单位动态计算<br>rem单位的动态计算的弹性布局，则是需要在头部内嵌一段脚本来进行监听分辨率的变化来动态改变根元素字体大小，使得 CSS 与 JS 耦合了在一起。</li>
<li>vh,vw视口单位实现适配<ul>
<li>优点：既能解决响应式断层问题，又能解觉rem决脚本依赖的问题的。</li>
<li>缺点：由于相对于视口为单位，随着视口增大而增大，失去了最大最小宽度限制</li>
</ul>
</li>
<li>vw+rem<ul>
<li>rem 弹性布局的核心在于动态改变根元素大小，那么我们可以通过：<ul>
<li>给根元素大小设置随着视口变化而变化的 vw 单位，这样就可以实现动态改变其大小。</li>
<li>限制根元素字体大小的最大最小值，配合g body 加上最大宽度和最小宽度</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h2 id="自适应，响应式布局："><a href="#自适应，响应式布局：" class="headerlink" title="自适应，响应式布局："></a>自适应，响应式布局：</h2><ul>
<li><p>设置meta viewport</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">　&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot; /&gt;</span><br><span class="line">目的是：网页宽度默认等于屏幕宽度（width=device-width），原始缩放比例（initial-scale=1）为1.0，即网页初始大小占屏幕面积的100%。</span><br></pre></td></tr></table></figure>
</li>
<li><p>媒体查询</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@media screen and (max-device-width: 400px) &#123;&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>不指定像素宽度<br>宽度定百分比或者width:auto</p>
</li>
<li>相对大小的字体<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">* 流动布局</span><br><span class="line">各个区块的位置都是浮动的（float），不是固定不变的,绝对定位的使用也要 非常小心</span><br><span class="line">***</span><br><span class="line">## meta</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>meta是干嘛用的？<br>Meta标签是用来描述网页属性的一种语言，标准的Meta标签可以便于搜索引擎排序，提高搜索引擎网站权重排名。</p>
<ul>
<li>两个属性name 和 http-equiv<ul>
<li>name<ul>
<li>keywords<br>设置你网页的关键字。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>&lt;meta name =”keywords”<br>     content=”science,education,culture,politics”</p>
<pre><code>* description：
  用来告诉搜索引擎你的网站主要内容。
 尽可能准确地描述网页的核心内容，通常为网页内容的摘要信息，也就是希望搜索引擎在检索结果中展示的摘要信息（100中文字之内）
* robots：
 告诉搜索机器人哪些页面需要索引，哪些页面不需要索引
 all,none,index,noindex,follow,nofollow
* author:作者
</code></pre><ul>
<li>http-equiv：相当于http的文件头作用<ul>
<li>Expires（期限）<br>可以用于设定网页的到期时间。一旦网页过期，必须到服务器上重新传输。<br>注意：必须使用GMT的时间格式。<br>用法：<meta http-equiv="expires" content="Fri,12 Jan 2001 18:18:18 GMT"></li>
<li>Pragma(cache模式）<br>说明：禁止浏览器从本地计算机的<a href="http://baike.baidu.com/view/907.htm" target="_blank" rel="external">缓存</a>中访问页面内容。<meta http-equiv="Pragma" content="no-cache"></li>
<li>Refresh（刷新）<br>自动刷新并转到新页面。<br><meta http-equiv="Refresh" content="2;URL">；</li>
<li>Set-Cookie(cookie设定）<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">***</span><br><span class="line">## meta viewport</span><br><span class="line">&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, minimum-scale=1, maximum-scale=1, user-scalable=no&quot;&gt;</span><br><span class="line">### 视窗基本属性</span><br><span class="line">* width：控制 viewport 的大小，你可以给它指定一个值，如：600，或者甚至还可以给它一个特殊的值，如：device-width，device-width为设备的宽度（单位为缩放为 100% 时的 CSS 的像素）。</span><br><span class="line">* height：与 width 相对应，指定viewport 高度。</span><br><span class="line">* initial-scale：初始缩放比例，也即是当页面第一次 load 的时候缩放比例。</span><br><span class="line">* maximum-scale：允许用户缩放到的最大比例。</span><br><span class="line">* minimum-scale：允许用户缩放到的最小比例。</span><br><span class="line">* user-scalable：是否允许用户手动缩放。</span><br><span class="line">### 三个视窗</span><br><span class="line">* 布局视窗：css定义的网页内容宽度，网页内容宽度跟移动端浏览器窗口无关</span><br><span class="line">* 视觉视窗：用户正看的区域window.innerWidth/Height</span><br><span class="line">* 理想视窗：定义理想视口是浏览器的工作，而不是设备或操作系统的工作。因此，同一设备上的不同浏览器拥有不同的理想视口。screen.width/height返回是理想视口的尺寸</span><br><span class="line">[三个视窗](http://www.cnblogs.com/xiaohuochai/p/5496995.html)</span><br><span class="line">[meta-viewport](http://yunkus.com/meta-viewport-usage/)</span><br><span class="line">***</span><br><span class="line">## 媒体查询</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<p>@media screen and (max-width:480px){<br> .ads {<br>   display:none;<br>  }<br>}<br>@media screen and (min-width:600px) and (max-width:900px){<br>  body {background-color:#f5f5f5;}<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">***</span><br><span class="line">## flex弹性布局：</span><br><span class="line">* flex布局好处？不需要再给子元素设置定位，使用flex属性就可以让浏览器自己计算位置</span><br><span class="line">* 父块元素：display: flex;</span><br><span class="line">* 父行级元素：display: inline-flex;</span><br><span class="line">* 设置了flex布局后，子元素的float、clear和vertical-align属性就会失效</span><br><span class="line">* 具体描述：</span><br><span class="line">设置了 flex的父亲成为：flex容器，孩子成为flex项目</span><br><span class="line">  * 父亲容器属性：</span><br><span class="line">    * flex-direction(孩子横向还是竖向)：row(孩子水平)| row-reverse | column(孩子竖直) | column-reverse;</span><br><span class="line">    * flex-wrap(孩子换行)：nowrap | wrap | wrap-reverse;</span><br><span class="line">    * justify-content（孩子对齐方式）: flex-start | flex-end | center | space-between | space-around;</span><br><span class="line">   * 孩子項目屬性：</span><br><span class="line">     * order ：属性定义项目的排列顺序。数值越小，排列越靠前，默认为0</span><br><span class="line">     * flex-basis：属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。</span><br><span class="line">     * flex-grow：属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大</span><br><span class="line">     * flex-shrink：属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。</span><br><span class="line">     * align-self：属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。</span><br><span class="line">【问题】：</span><br><span class="line">flex弹性盒模型，主轴有几个方向？后代 flex：1代表什么？</span><br><span class="line">【答案】：</span><br><span class="line"></span><br><span class="line">flex-grow:0; 定义弹性盒子项的拉伸因子，即子项分配父项剩余空间的比，默认值为 0flex-shrink:1; 指定了 flex 元素的收缩规则，子项的收缩所占的份数，默认值为1 [ 当所有子项相加的宽度大于父项的宽度，每个子项减少的多出的父项宽度的 1/n ]felx-basis:auto; 指定了 flex 元素在主轴方向上的初始大小，即子项的宽度</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">***</span><br><span class="line">## grid system ，网格布局，栅格化 </span><br><span class="line">栅格化？</span><br><span class="line">http://www.cnblogs.com/dojo-lzz/p/4621627.html</span><br><span class="line">http://www.w3cplus.com/css/learncssgrid.html</span><br><span class="line">网格布局的好处？</span><br><span class="line">规范网页中的版面布局以及信息分布，让网页设计不再无规律可循。</span><br><span class="line">有规律的网页设计，可以为网页前端开发带来很多便利。</span><br><span class="line">栅格化主要好处是：快速开发、提高整站布局的一致性。</span><br><span class="line">缺点：灵活性可能稍嫌不足。但我觉得，划分 12 栏的网格系统其实也已具有较大的灵活性了。</span><br><span class="line">http://www.chinaz.com/design/2009/0527/77426.shtml</span><br><span class="line">* 创建网格容器</span><br><span class="line">display: grid/inline-grid</span><br><span class="line">网格项目默认纵项排列</span><br><span class="line">* 设置网格项目的高或者宽</span><br></pre></td></tr></table></figure></p>
<p>grid-template-columns/rows: 10px;<br>grid-template-columns: 1fr 1fr 2fr;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">***</span><br><span class="line"></span><br><span class="line">## px,em,rem，%的区别?</span><br><span class="line">*  px</span><br><span class="line">   相对屏幕分辨率</span><br><span class="line">* em</span><br><span class="line">  * 若自身定义了font-size，按照自身算</span><br><span class="line">  * 自身没定义就按照父元素算</span><br><span class="line">  * em的值并不是固定的</span><br><span class="line">  * 具体使用方案：</span><br></pre></td></tr></table></figure></p>
<p>   body选择器中声明Font-size=62.5%；<br>   16px*62.5% = 10px<br>    1em = 10px;<br>    IE浏览器:Font-size=63%<br>   将你的原来的px数值除以10，然后换上em作为单位；</p>
<p>重新计算那些被放大的字体的em数值。避免字体大小的重复声明。如：行高、字体大小。<br>缺陷：整个页面内1em不是一个固定的值，设置em要知道父元素font-size<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">* rem </span><br><span class="line">  * 相对于html根元素来算，免字体大小逐层复合</span><br><span class="line">  * 除了IE8及更早版本外，所有浏览器均已支持rem</span><br><span class="line">* 百分比</span><br><span class="line">  * 相对于父元素的百分比</span><br><span class="line">  * 使用：如果是随着父容器或者是整体页面布局而改变尺寸，则使用百分比更好，如元素的高度和宽度设置。</span><br><span class="line"></span><br><span class="line">***</span><br><span class="line">## 知道css新属性 vw vh ？【4】</span><br><span class="line">* 定义</span><br><span class="line">  * css3的新单位</span><br><span class="line">  * css3引入的”vw”和”vh”基于宽度/高度相对于窗口大小</span><br><span class="line">  * ”vw”=”view width”, “vh”=”view height”; </span><br><span class="line">  * 相对于浏览器窗口的大小定义的最佳方式</span><br><span class="line">  * 字体大小会随着你窗口改变而改变</span><br><span class="line">*  应用</span><br><span class="line">根据[CSS3规范](https://drafts.csswg.org/css-values-3/#viewport-relative-lengths)，视口单位主要包括以下4个：·</span><br><span class="line">vw : 1vw 等于视口宽度的1%</span><br><span class="line">vh : 1vh 等于视口高度的1%</span><br><span class="line">vmin : 选取 vw 和 vh 中最小的那个</span><br><span class="line">vmax : 选取 vw 和 vh 中最大的那个</span><br><span class="line">视口单位区别于%单位，视口单位是依赖于视口的尺寸，根据视口尺寸的百分比来定义的；而%单位则是依赖于元素的祖先元素。</span><br><span class="line">* 兼容性</span><br><span class="line">兼容主流浏览,IE兼容IE10</span><br><span class="line">***</span><br><span class="line">##  设备像素物理像素？</span><br><span class="line">###  设备像素(物理像素)</span><br><span class="line">又叫 物理像素，设备能控制显示的最小单位，</span><br><span class="line">### 设备独立像素（css像素）</span><br><span class="line">* 独立于设备的用于逻辑衡量像素的单位。平时用的虚拟像素，但不是屏幕分辨率。</span><br><span class="line">* 移动端，PC端通过screen.width/height获取的这个值是设备独立像素（CSS 像素），而不是设备的屏幕分辨率，因为设备的屏幕分辨率对于WEB开发者来说是无法通过代码来获得的，是完全透明的。 </span><br><span class="line">### 物理像素与设备独立像素</span><br><span class="line">* 在PC端浏览器默认情况下（100%，即页面没被缩放），一个物理像素 = 一个设备独立像素</span><br><span class="line">* 在移动端时候，一般物理像素与设备独立像素不相等，有一定的换算关系。</span><br><span class="line">设备像素比 = 物理像素/设备独立像素（在某个方向上）</span><br><span class="line">* 获取设备像素比 : window.devicePixelRatio</span><br><span class="line">### PPI</span><br><span class="line">像素密度（pixel density）. </span><br><span class="line">全称是（pixel per inch）就是每英寸内有多少个设备像素点. </span><br><span class="line">PPI的值越高，画质越好，也就是越细腻，看起来更有逼格。 </span><br><span class="line">标准的PPI是160, 不过现在屏幕标准的少了, 都超过了160. </span><br><span class="line">PPI 值超过300的叫做超高密度屏幕，Apple 给它换了个高大尚的名称：Retina视网膜屏幕</span><br><span class="line">***</span><br><span class="line">[设备像素](http://yunkus.com/physical-pixel-device-independent-pixels/)</span><br><span class="line">[物理像素](http://www.jianshu.com/p/af6dad66e49a)</span><br><span class="line">***</span><br><span class="line">## 用宽确定高，百分比（元素宽度为窗口的多少）</span><br></pre></td></tr></table></figure></p>
<p>1 使用padding，根据宽来定高，注意，元素有内容时，需要去除文本高度<br>width: 50%;padding: 25% 0;<br>2使用vw<br> width: 50vw;<br> height: 50vw;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">### css一个正方形，宽度是屏幕的一半，水平垂直居中</span><br><span class="line">* vw 获取屏幕的width</span><br><span class="line">* 垂直水平居中</span><br></pre></td></tr></table></figure></p>
<pre><code>width: 50vw;
height: 50vw;
position: absolute;
left: 50%;
top: 50%;
transform: translate(-50%, -50%);
background: pink;
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">* 当元素无内容的时候，padding: 25% 0;可以当作元素的高；</span><br></pre></td></tr></table></figure>
<pre><code>width: 50%;
padding: 25% 0;
position: absolute;
top: 50%;
left: 50%;
transform: translate(-50%, -50%);
background: red;
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">***</span><br><span class="line">## ul&gt;li列表，小于480时一行显示两个，大于480&lt;960时候一行显示三个</span><br><span class="line">* media ,vw,可以弄出元素的宽高</span><br></pre></td></tr></table></figure>
<p> @media screen and (max-width:480px) {<br>            li {<br>                width: 38vw;<br>                height: 38vw;<br>                background: pink;<br>                float: left;<br>                margin-left: 1vw;<br>                margin-bottom: 1vw;<br>            }<br>        }</p>
<pre><code>@media screen and (min-width:481px)and (max-width:960px) {
    li {
        width: 27vw;
        height: 27vw;
        background: greenyellow;
        float: left;
        margin-left: 1vw;
        margin-bottom: 1vw;
    }
}

@media screen and (min-width:962px) {
    li {
        width: 30vw;
        height: 30vw;
        background: purple;
        float: left;
        margin-left: 1vw;
        margin-bottom: 1vw;
    }
}

ul {
    position: relative;
}
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line"></span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class="line">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, minimum-scale=1, maximum-scale=1, user-scalable=no&quot;&gt;</span><br><span class="line">    &lt;title&gt;响应式&lt;/title&gt;</span><br><span class="line">    &lt;style type=&quot;text/css&quot;&gt;</span><br><span class="line">        @media screen and (max-width:480px) &#123;</span><br><span class="line">            li &#123;</span><br><span class="line">                width: 44%;</span><br><span class="line">                padding: 22% 0;</span><br><span class="line">                background: pink;</span><br><span class="line">                float: left;</span><br><span class="line">                margin-left: 1%;</span><br><span class="line">                margin-bottom: 1%;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        @media screen and (min-width:480px)and (max-width:960px) &#123;</span><br><span class="line">            li &#123;</span><br><span class="line">                width: 30%;</span><br><span class="line">                padding: 15% 0;</span><br><span class="line">                background: green;</span><br><span class="line">                float: left;</span><br><span class="line">                margin-left: 1%;</span><br><span class="line">                margin-bottom: 1%;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        ul &#123;</span><br><span class="line">            position: relative;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        ul&gt;li &#123;</span><br><span class="line">            list-style-type: none;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        @media screen and (min-width:960px) &#123;</span><br><span class="line">            li &#123;</span><br><span class="line">                width: 30%;</span><br><span class="line">                padding: 15% 0;</span><br><span class="line">                background: red;</span><br><span class="line">                float: left;</span><br><span class="line">                margin-left: 1%;</span><br><span class="line">                margin-bottom: 1%;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line"></span><br><span class="line">&lt;/head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div class=&apos;con&apos;&gt;</span><br><span class="line">        &lt;ul&gt;</span><br><span class="line">            &lt;li&gt;1&lt;/li&gt;</span><br><span class="line">            &lt;li&gt;2&lt;/li&gt;</span><br><span class="line">            &lt;li&gt;3&lt;/li&gt;</span><br><span class="line">            &lt;li&gt;4&lt;/li&gt;</span><br><span class="line">            &lt;li&gt;5&lt;/li&gt;</span><br><span class="line">            &lt;li&gt;6&lt;/li&gt;</span><br><span class="line">        &lt;/ul&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="JS"><a href="#JS" class="headerlink" title="JS"></a>JS</h1><h2 id="js数据类型有哪些-5"><a href="#js数据类型有哪些-5" class="headerlink" title="js数据类型有哪些 5%"></a>js数据类型有哪些 5%</h2><p>数据类型分为：简单数据类型和引用<br> (五大)简单数据类型 ：数字 ，字符串 ， 布尔值(true/false)， null，undifined<br>引用：数组，函数，正则表达式，对象</p>
<hr>
<h2 id="null-和undefined"><a href="#null-和undefined" class="headerlink" title="null 和undefined"></a>null 和undefined</h2><p><a href="http://www.ruanyifeng.com/blog/2014/03/undefined-vs-null.html" target="_blank" rel="external">http://www.ruanyifeng.com/blog/2014/03/undefined-vs-null.html</a></p>
<ul>
<li>相似性：<ul>
<li>undefined和null在if语句中，都会被自动转为false<ul>
<li>undefined == null // true</li>
</ul>
</li>
</ul>
</li>
<li>null：<ul>
<li>null表示”没有对象”，即该处不应该有值</li>
<li>用法：<ul>
<li>原型链的终点</li>
<li>作为函数的参数，表示该函数的参数不是对象</li>
</ul>
</li>
</ul>
</li>
<li>undefined<ul>
<li>undefined表示”缺少值”，就是此处应该有一个值，但是还没有定义</li>
<li>典型用法是：<ul>
<li>变量定义了没有赋值</li>
<li>函数应该传递的参数没有传递</li>
<li>对象定义属性没有赋值</li>
<li>函数没有返回值的时候 返回undefined</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h2 id="简单说一下作用域与作用域链-5"><a href="#简单说一下作用域与作用域链-5" class="headerlink" title="简单说一下作用域与作用域链 5%"></a>简单说一下作用域与作用域链 5%</h2><h3 id="作用域和作用域链"><a href="#作用域和作用域链" class="headerlink" title="作用域和作用域链"></a>作用域和作用域链</h3><p>因为当某个函数第一次被调用时候，会创建相应的执行环境和作用域链<br>并把作用域链赋值给内部属性：scope,使用this,arguments和函数的初始参数为活动对象（活动对象就是函数执行上下文中的变量）<br>当在函数中访问变量的时候，需要在作用域链中进行查找，先访问自己的内部的，再访问外部的，再访问外部外部的，直到作用域链的终点：全局执行环境<br>创建函数时，会创建包含函数外部对象的 作用域链，作用域链保存在当前函数的scope中<br>调用函数时，会创建执行环境，创建执行环境的作用域链：是靠复制函数的scope里面的对象<br>作用域链的本质是指向变量对象的指针链表，指引用，不实际包含变量对象</p>
<h3 id="谈一下关于作用域"><a href="#谈一下关于作用域" class="headerlink" title="谈一下关于作用域"></a>谈一下关于作用域</h3><p>  函数里外变量名相同,取函数内部的。Es6 作用域和他一样吗</p>
<ul>
<li>es5函数作用域，作用域链<br>es5只有全局作用域和函数作用域<ul>
<li>作用域<br>作用域指的是变量的作用范围。</li>
<li>作用域链<br>函数内部作用域由函数的参数，局部变量，函数构成。内部作用域和外部的作用域一层层的链接起来形成作用域链。<br>当在函数内部要访问一个变量的时候，首先查找自己的内部作用域有没有这个变量，如果没有就到这个函数所在的外层作用域中找，直到到window所在的作用域。</li>
</ul>
</li>
<li>es6作用域<br>函数内部访问一个变量,由于块级作用域，只能在函数内部查找是否有这个变量，若函数内部没有这个变量还去访问会报错。</li>
</ul>
<hr>
<h2 id="原型-原型链-原型继承（说一下原型-原型链，考了几道题-让你现在作答）-5"><a href="#原型-原型链-原型继承（说一下原型-原型链，考了几道题-让你现在作答）-5" class="headerlink" title="原型 原型链 原型继承（说一下原型 原型链，考了几道题 让你现在作答） 5%"></a>原型 原型链 原型继承（说一下原型 原型链，考了几道题 让你现在作答） 5%</h2><p>请简单说一下原型,原型链，继承</p>
<h3 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h3><ul>
<li>来由：原型是在创建对象时原型模式里提出的概念</li>
<li>定义：创建的每个函数都有一个原型prototype属性，这个属性是一个指针,指向一个对象，这个对象包含着这个函数所有实例可以共享的函数和方法。<br>这个原型对象就是:函数每个原型</li>
<li>优点：可以让所有实例共享原型对象中的属性和方法</li>
<li>缺点：因为共享的特性，实例改写引用类型属性 会更改原型对象属性 使得其他实例属性也改变；还有一个：无法给函数初始化参数</li>
<li>prototype与在构造函数中定义属性和方法有什么区别？<ul>
<li>构造函数中的属性和方法，每个实例都将构造函数中的所有属性创建一遍副本，</li>
<li>缺点：无法共享一套属性 <ul>
<li>优点：每个实例改写属性后互不影响</li>
</ul>
</li>
</ul>
</li>
<li>使用构造函数模式+原型模式创建对象取两者优点<ul>
<li>可传递参数</li>
<li>每个实例都可以利用原型对象共享方法</li>
<li>将引用类型属性放到构造函数中，实例改写后互不影响<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function Person(name, age, job) &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.age = age;</span><br><span class="line">    this.job = job;</span><br><span class="line">    this.friends = [&apos;a&apos;, &apos;b&apos;];</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">    constructor: Person,</span><br><span class="line">    sayName: function() &#123;</span><br><span class="line">        console.log(this.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h3 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h3><ul>
<li>来由：原型链这个概念是在讲继承的时候提出的</li>
<li>定义：原型与实例层层递进构成的链条叫做原型链。某个原型对象等于另一函数的实例:child.prototype = new father()，孩子原型.proto指向父原型，父原型的.proto指向 父原型的原型，直到Object.prototype.proto = null</li>
<li>确定原型和实例的关系<ul>
<li>instance instanceof SubType</li>
<li>father.prototype.isPrototypeOf(child)<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3></li>
</ul>
</li>
<li><p>原型链继承 child.prototype = new father()</p>
<ul>
<li><p>缺点：</p>
<ul>
<li>访问重写父亲引用属性，会更改父原型</li>
<li>创建子类无法给父构造函数传递参数</li>
</ul>
</li>
<li><p>代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">function SuperType() &#123;</span><br><span class="line">    this.property = true;</span><br><span class="line">&#125;</span><br><span class="line">SuperType.prototype.getSuperValue = function() &#123; </span><br><span class="line">    return this.property;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function SubType() &#123;</span><br><span class="line">    this.subproperty = false;</span><br><span class="line">&#125;</span><br><span class="line">//先继承</span><br><span class="line">SubType.prototype = new SuperType(); </span><br><span class="line">//再添加方法</span><br><span class="line">SubType.prototype.getSubValue = function() &#123;</span><br><span class="line">    return this.subproperty;</span><br><span class="line">&#125;</span><br><span class="line">var instance = new SubType(); </span><br><span class="line">console.log(instance.getSuperValue()); //true</span><br><span class="line">//SuperType.prototype : constructor,getSuperValue(),proto</span><br><span class="line">//SubType.prototype : proto, property = true;getSubValue()</span><br><span class="line">// instance : proto , subproperty = false;</span><br><span class="line">//确定原型和实例的关系 instanceof /father.prototype.isPrototypeOf(child)</span><br><span class="line">console.log(instance instanceof SubType);</span><br><span class="line">console.log(instance instanceof SuperType);</span><br><span class="line">console.log(instance instanceof Object);</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>借用构造函数继承/经典继承</p>
<ul>
<li>定义：在子类构造函数中调用父类构造函数 ，子向父类传递参数</li>
<li>子类中Father.apply(this,param)</li>
<li>缺点：无法达到共享或者复用性（构造模式的问题）</li>
<li>优点：可给父类传递参数，副本属性</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function SuperType(name) &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">&#125;  </span><br><span class="line">function SubType() &#123;</span><br><span class="line">    //在子类构造函数中调用父类构造函数 实现了继承 还传递了参数</span><br><span class="line">    SuperType.call(this, &apos;carry&apos;);</span><br><span class="line">    //给子添加 属性</span><br><span class="line">    this.age = 19;</span><br><span class="line">&#125;</span><br><span class="line">var instance = new SubType();</span><br><span class="line">instance.name; //carry</span><br></pre></td></tr></table></figure>
<ul>
<li><p>组合继承（原型链继承+借用构造函数继承）</p>
<ul>
<li>定义：原型链继承(可继承方法：达到共享)+借用构造函数继承(可继承属性：有自己的副本属性)</li>
<li>组合继承是js中最常用的继承方式</li>
<li>优点：属性互不影响，又可以共用方法，两全其美</li>
<li>缺点：要调用两次父类的构造函数，造成了属性副本在子类原型中的多余 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">function SuperType(name) &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.colors = [&apos;green&apos;, &apos;red&apos;];</span><br><span class="line">&#125;</span><br><span class="line">SuperType.prototype.sayName = function() &#123;</span><br><span class="line">    alert(this.name);</span><br><span class="line">&#125;</span><br><span class="line">function SubType(name, age) &#123;</span><br><span class="line">    //继承实例属性</span><br><span class="line">    SuperType.call(this, name);</span><br><span class="line">    this.age = age;</span><br><span class="line">&#125;</span><br><span class="line">//继承父类方法</span><br><span class="line">SubType.prototype = new SuperType();</span><br><span class="line">SubType.prototype.sayAge = function() &#123;</span><br><span class="line">    alert(this.age);</span><br><span class="line">&#125;</span><br><span class="line">var i1 = new SubType(&apos;bill&apos;, 18);</span><br><span class="line">i1.colors.push(&apos;white&apos;);</span><br><span class="line">alert(i1.colors); //&apos;green&apos;, &apos;red&apos;,&apos;white&apos;</span><br><span class="line">i1.sayAge(); //18</span><br><span class="line">i1.sayName(); //bill</span><br><span class="line">var i2 = new SubType(&apos;carry&apos;, 28)</span><br><span class="line">i2.colors; //&apos;green&apos;, &apos;red</span><br><span class="line">i1.sayAge(); //28</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>原型式继承 var childObj = Object.create(fatherObj) //Object.create() = create()  </p>
<ul>
<li>在没有必要兴师动众的创建构造函数的情况下， 只想让两个对象保持差不多一致<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var peron = &#123;</span><br><span class="line">    name: &apos;carry1&apos;,</span><br><span class="line">    friends: [&apos;f1&apos;, &apos;f2&apos;]</span><br><span class="line">&#125;</span><br><span class="line">var np1 = Object.create(peron);</span><br><span class="line">np1.name = &apos;carry2&apos;;</span><br><span class="line">np1.friends.push(&apos;f3&apos;);</span><br><span class="line">var np2 = Object.create(peron, &#123;</span><br><span class="line">    name: &#123;</span><br><span class="line">        value: &apos;carry3&apos;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">console.log(np2.name); //carry3</span><br><span class="line">peron.friends; //f1,f2,f3</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>寄生式继承</p>
<ul>
<li>封装一个仅仅用于实现继承过程的函数 该函数 完成继承操作 然后返回子对象.</li>
<li>寄生式继承就是利用原型式继承的中Object.create(fatherObj)原理实现实例属性的继承，但是又可以在clone函数中定义自己的方法<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function createClone(father) &#123;</span><br><span class="line">    var clone = Object.create(father);</span><br><span class="line">    clone.sayHi = function() &#123;</span><br><span class="line">        alert(&apos;i am clone&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">    return clone;</span><br><span class="line">&#125;</span><br><span class="line">var peron = &#123;</span><br><span class="line">    name: &apos;carry1&apos;,</span><br><span class="line">    friends: [&apos;f1&apos;, &apos;f2&apos;]</span><br><span class="line">&#125;</span><br><span class="line">var child = createClone(Person);</span><br><span class="line">child.name = &apos;carry2&apos;;</span><br><span class="line">child.sayHi(); //&apos;i am clone&apos;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>寄生组合式继承</p>
<ul>
<li>采用 借用构造函数 来继承属性  使用 原型链的混成形式来继承 方法</li>
<li>用来完善组合式继承：因为组合式继承 要调用两次父类的构造函数，造成了在子类中又创建了一遍属性</li>
<li>优点：寄生式组合继承 只使用了一次 父类构造函数，避免了child.prototype上创建没必要的属性，原型链的结构还可以保持不变<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">function inheritPrototype(subType, superType) &#123;</span><br><span class="line">    var prototype = Object.create(SuperType.prototype); //创建对象</span><br><span class="line">    prototype.constructor = subType; //增强对象</span><br><span class="line">    subType.prototype = prototype; //指定对象</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function SuperType(name) &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.colors = [&apos;green&apos;, &apos;red&apos;];</span><br><span class="line">&#125;</span><br><span class="line">SuperType.prototype.sayName = function() &#123;</span><br><span class="line">    alert(this.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function SubType(name, age) &#123;</span><br><span class="line">    //继承属性</span><br><span class="line">    SuperType.call(this, name);</span><br><span class="line">    this.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//继承方法</span><br><span class="line">inheritPrototype(SubType, SuperType)</span><br><span class="line">SubType.prototype.sayAge = function() &#123;</span><br><span class="line">    alert(this.age);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<hr>
<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>闭包大纲</p>
<ul>
<li>什么是闭包？</li>
<li>闭包的原理？</li>
<li>平时如何用闭包，闭包能解决什么问题？</li>
</ul>
<h3 id="a：说一下什么是闭包"><a href="#a：说一下什么是闭包" class="headerlink" title="a：说一下什么是闭包?"></a>a：说一下什么是闭包?</h3><p>使用着另一个函数作用域中的变量的函数，保留变量并不被回收</p>
<h3 id="b-闭包的原理（深刻一点，包括作用域链，垃圾回收机制）"><a href="#b-闭包的原理（深刻一点，包括作用域链，垃圾回收机制）" class="headerlink" title="b:闭包的原理（深刻一点，包括作用域链，垃圾回收机制）"></a>b:闭包的原理（深刻一点，包括作用域链，垃圾回收机制）</h3><p>之所以内层函数可以访问外的变量是因为</p>
<ul>
<li>内部函数的作用域链中包含着外层函数的变量对象（活动对象和全局变量对象）</li>
<li>外层函数执行完毕后，它的执行环境和作用域链会被销毁，但被闭包引用的变量对象不被销毁</li>
</ul>
<p>如何销毁闭包：</p>
<ul>
<li>var a = outerFunction(‘123’);</li>
<li>使用闭包后,想销毁闭包的作用域链</li>
<li>a = null;//通知垃圾回收进行清除</li>
</ul>
<h3 id="c-你是如何应用闭包的"><a href="#c-你是如何应用闭包的" class="headerlink" title="c:你是如何应用闭包的?"></a>c:你是如何应用闭包的?</h3><p>使用闭包定义私有方法和变量</p>
<h4 id="1-模拟块级作用域（私有变量和作用域）"><a href="#1-模拟块级作用域（私有变量和作用域）" class="headerlink" title="1:模拟块级作用域（私有变量和作用域）"></a>1:模拟块级作用域（私有变量和作用域）</h4><p>只让for循环内访问变量i，立即函数模拟块级作用域，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">function foo3(count) &#123;</span><br><span class="line">    for (var i = 0; i &lt; count; i++) &#123;</span><br><span class="line">        console.log(&apos;inner:&apos; + i); //12345</span><br><span class="line">    &#125;</span><br><span class="line">    console.log(&apos;outer:&apos; + i); //5</span><br><span class="line">&#125;</span><br><span class="line">foo3(5);</span><br><span class="line"></span><br><span class="line">//使用立即函数和闭包定义块级作用域</span><br><span class="line">function foo4(count) &#123;</span><br><span class="line">    (function() &#123;</span><br><span class="line">        //块作用域</span><br><span class="line">        for (var i = 0; i &lt; count; i++) &#123;</span><br><span class="line">            console.log(&apos;inner:&apos; + i); //12345</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;)();</span><br><span class="line">    console.log(&apos;outer:&apos; + i); //报错</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="2：构造模式，定义接口，让外界可以访问函数的私有变量"><a href="#2：构造模式，定义接口，让外界可以访问函数的私有变量" class="headerlink" title="2：构造模式，定义接口，让外界可以访问函数的私有变量"></a>2：构造模式，定义接口，让外界可以访问函数的私有变量</h4><p>//定义构造函数，使用闭包访问函数的私有变量<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function Person(name) &#123;</span><br><span class="line">    this.getName = function() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line">    this.setName = function(value) &#123;</span><br><span class="line">        name = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var a = new Person(&apos;carry&apos;);</span><br><span class="line">var k =  a.getName(); //carry;</span><br><span class="line">a.setName(&apos;bill&apos;);</span><br><span class="line">a.getName(); //bill;</span><br></pre></td></tr></table></figure></p>
<h4 id="3：原型模式-私有作用域-定义接口"><a href="#3：原型模式-私有作用域-定义接口" class="headerlink" title="3：原型模式 私有作用域 定义接口"></a>3：原型模式 私有作用域 定义接口</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">(function() &#123;</span><br><span class="line">    //定义私有变量</span><br><span class="line">    var name = &apos;&apos;;</span><br><span class="line">    //定义私有方法</span><br><span class="line">    Person = function(value) &#123;</span><br><span class="line">            name = value;</span><br><span class="line">        &#125;</span><br><span class="line">        //定义接口</span><br><span class="line">    Person.prototype.getName = function() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line">    Person.prototype.setName = function(value) &#123;</span><br><span class="line">        name = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
<h4 id="4：模块化"><a href="#4：模块化" class="headerlink" title="4：模块化"></a>4：模块化</h4><p>retrun {f:f}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">function CoolModule() &#123;</span><br><span class="line">    var something = &quot;cool&quot;;</span><br><span class="line">    var another = [1, 2, 3];</span><br><span class="line"></span><br><span class="line">    function doSomething() &#123;</span><br><span class="line">        alert( something );</span><br><span class="line">    &#125;</span><br><span class="line">    function doAnother() &#123;</span><br><span class="line">        alert( another.join( &quot; ! &quot; ) );</span><br><span class="line">    &#125;</span><br><span class="line">    return &#123;</span><br><span class="line">        doSomething: doSomething,</span><br><span class="line">        doAnother: doAnother</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line">var foo = CoolModule();</span><br><span class="line">foo.doSomething(); // cool</span><br><span class="line">foo.doAnother(); // 1 ! 2 ! 3</span><br></pre></td></tr></table></figure></p>
<hr>
<h3 id="d-使用闭包应该注意？"><a href="#d-使用闭包应该注意？" class="headerlink" title="d:使用闭包应该注意？"></a>d:使用闭包应该注意？</h3><ul>
<li>1:闭包只能取某变量的最后一个值（for循环中的匿名函数）</li>
<li>2:闭包中的this指向全局环境，无法正常的访问作用域中的this和arguments,</li>
</ul>
<h4 id="1-闭包只能取某变量的最后一个值（for循环中的匿名函数）"><a href="#1-闭包只能取某变量的最后一个值（for循环中的匿名函数）" class="headerlink" title="1:闭包只能取某变量的最后一个值（for循环中的匿名函数）"></a>1:闭包只能取某变量的最后一个值（for循环中的匿名函数）</h4><p>下面函数的输出结果是 10个10<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function foo1() &#123;</span><br><span class="line">    var result = [];</span><br><span class="line">    for (var i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">        result[i] = function() &#123;</span><br><span class="line">            console.log(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>使用立即函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function foo1() &#123;</span><br><span class="line">    var result = [];</span><br><span class="line">    for (var i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">        result[i] = function(n) &#123;</span><br><span class="line">            return function() &#123;</span><br><span class="line">                console.log(n);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;(i);</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="2-闭包中的this指向-window"><a href="#2-闭包中的this指向-window" class="headerlink" title="2:闭包中的this指向 window"></a>2:闭包中的this指向 window</h4><p>this在运行时是基于函数的执行环境绑定的<br>匿名函数的执行环境具有全局性，闭包中的this指向window<br>闭包在执行环境中搜索 this和arguments<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var name = &apos;the window&apos;;</span><br><span class="line">var obj = &#123;</span><br><span class="line">    name: &apos;my obj&apos;,</span><br><span class="line">    getName: function() &#123;</span><br><span class="line">        var that = this;</span><br><span class="line">        return function() &#123;</span><br><span class="line">            return that.name;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">console.log(obj.getName());</span><br></pre></td></tr></table></figure></p>
<h3 id="d-闭包的优缺点"><a href="#d-闭包的优缺点" class="headerlink" title="d:闭包的优缺点"></a>d:闭包的优缺点</h3><p>优点：避免全局变量的污染，存在私有变量，使一个成员常驻内存。<br>缺点：闭包会常驻内存，会增大内存使用，使用不当容易造成内存溢出。<br>闭包会保存外层函数的变量对象，会占用更多的内存。<br>V 8优化后的js引擎会尝试回收被闭包占用的内存，但还需慎重使用闭包</p>
<h3 id="f-如何创建闭包"><a href="#f-如何创建闭包" class="headerlink" title="f:如何创建闭包"></a>f:如何创建闭包</h3><p>1.定义外层函数，和变量。<br>2.定义内层函数，并对外部函数的变量进行使用。<br>3.返回内层函数。<br>返回的内层函数，在其他地方被调用，仍然保存着外函数的变量。（通过访问闭包来访问变量，闭包使变量为私有变量）</p>
<h3 id="作用域和作用域链-1"><a href="#作用域和作用域链-1" class="headerlink" title="作用域和作用域链"></a>作用域和作用域链</h3><p>因为当某个函数第一次被调用时候，会创建相应的执行环境和作用域链<br>并把作用域链赋值给内部属性：scope,使用this,arguments和函数的初始参数为活动对象（活动对象就是函数执行上下文中的变量）<br>当在函数中访问变量的时候，需要在作用域链中进行查找，先访问自己的内部的，再访问外部的，再访问外部外部的，直到作用域链的终点：全局执行环境<br>创建函数时，会创建包含函数外部对象的 作用域链，作用域链保存在当前函数的scope中<br>调用函数时，会创建执行环境，创建执行环境的作用域链：是靠复制函数的scope里面的对象<br>作用域链的本质是指向变量对象的指针链表，指引用，不实际包含变量对象</p>
<h3 id="内存泄露，垃圾回收机制"><a href="#内存泄露，垃圾回收机制" class="headerlink" title="内存泄露，垃圾回收机制"></a>内存泄露，垃圾回收机制</h3><p>循环引用会导致内存泄露<br>在IE9之前版本使用闭包，会导致一些特殊的问题。例如，闭包的作用域链中保存着html元素，无法被销毁</p>
<ul>
<li>解决 定义访问的dom元素的副本，element = null; //解除对dom对象的引用<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function foo2() &#123;</span><br><span class="line">    var element = document.getElementById(&apos;someElement&apos;);</span><br><span class="line">    var id = element.id; //定义让闭包访问的副本</span><br><span class="line">    element.onclick = function() &#123;</span><br><span class="line">        alert(id);</span><br><span class="line">    &#125;;</span><br><span class="line">    element = null; //解除对dom对象的引用</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h3 id="函数声明与函数表达式"><a href="#函数声明与函数表达式" class="headerlink" title="函数声明与函数表达式"></a>函数声明与函数表达式</h3><p>function a (){};<br>a();<br>var a = function(){};<br>a();</p>
<p>函数声明方式后不能直接加 ()调用，需要 (function a (){})();</p>
<hr>
<h2 id="js事件-5"><a href="#js事件-5" class="headerlink" title="js事件 5%"></a>js事件 5%</h2><h3 id="事件模型"><a href="#事件模型" class="headerlink" title="事件模型"></a>事件模型</h3><ul>
<li>DOM0 :原始事件模型<ul>
<li>btn.onclick=function(){}这种类型的事件模型（btn.onclick = null;）</li>
<li>基于DOM0的事件，对于同一个dom节点而言，只能注册一个， 取后面事件。后边注册的同种事件会覆盖之前注册的。</li>
</ul>
</li>
<li>DOM2<ul>
<li>冒泡 ：事件从事件的发生地（目标元素），一直向上传递，直到window<ul>
<li>IE只支持事件冒泡</li>
</ul>
</li>
<li>捕获 ：事件是从window向下传递，直到事件的发生地（目标元素）</li>
<li>设置捕获和冒泡：<ul>
<li>IE：默认事件冒泡<ul>
<li>标准： addEventListener()第三个参数:捕获/冒泡 = true/false</li>
</ul>
</li>
</ul>
</li>
<li>绑定或者解除事件<ul>
<li>标准：addEventListener(type,handler),removeEventListener(type,handler)</li>
<li>IE: attachEvent,target.detachEvent(“on”+type,handler);</li>
</ul>
</li>
<li>阻止事件冒泡：evt.stopPropagation()/evt.cancelBubble=true</li>
<li>获取事件对象(标准||IE):var event=window.event||event; </li>
<li>获取事件源对象：var target = event.target||event.srcElement;</li>
<li>同一个节点元素，给她添加捕获和冒泡事件模型，捕获比冒泡快</li>
<li>绑定多个事件的顺序:比如说一下子注册了3个冒泡事件，那么执行顺序就按照注册的顺序来，先注册先执行</li>
</ul>
</li>
</ul>
<hr>
<h3 id="事件委托"><a href="#事件委托" class="headerlink" title="事件委托"></a>事件委托</h3><p>应用场景：动态添加 或删除孩子的时候<br>含义：孩子的事委托父亲做<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul id=&quot;ul1&quot;&gt;</span><br><span class="line">    &lt;li&gt;111&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;222&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;333&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;444&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line"></span><br><span class="line">window.onload = function()&#123;</span><br><span class="line">    var oUl = document.getElementById(&quot;ul1&quot;);</span><br><span class="line">   oUl.onclick = function()&#123;</span><br><span class="line">        alert(123);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里用父级ul做事件处理，当li被点击时，由于冒泡原理，事件就会冒泡到ul上，因为ul上有点击事件，所以事件就会触发.<br>当然，这里当点击ul的时候，也是会触发的，那么问题就来了，如果我想让事件代理的效果跟直接给节点的事件效果一样怎么办，比如说只有点击li才会触发，不怕，我们有绝招：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">window.onload = function()&#123;</span><br><span class="line">　　var oUl = document.getElementById(&quot;ul1&quot;);</span><br><span class="line">　　oUl.onclick = function(event)&#123;</span><br><span class="line">　　　　var ev = event || window.event;</span><br><span class="line">　　　　var target = ev.target || ev.srcElement;</span><br><span class="line">　　　　if(target.nodeName.toLowerCase() == &apos;li&apos;)&#123;</span><br><span class="line">　 　　　　　　 alert(123);</span><br><span class="line">　　　　　　　  alert(target.innerHTML);</span><br><span class="line">　　　　&#125;</span><br><span class="line">　　&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<p>##【事件相关问题】<br>1：阻止默认事件：preventDefault():<br>2：阻止冒泡：stopPropagation();<br>3：什么时候会事件捕获？应用事件捕获解决什么问题？<br>你想作全局的点击事件监听，相对于document结点与document下所有的子结点，在某个条件下要求所有的子结点点击无效，这种情况下冒泡模型就解决不了了，而捕获型却非常适合，可以在最顶层结点添加捕获型事件监听器。<br>3：事件冒泡和事件捕获分别有哪些浏览器支持？<br>IE只支持事件冒泡</p>
<hr>
<h2 id="浏览器对事件的处理过"><a href="#浏览器对事件的处理过" class="headerlink" title="浏览器对事件的处理过"></a>浏览器对事件的处理过</h2><ul>
<li>鼠标点击以后 浏览器对于事件的处理详细过程？<br>当(click)点击某个元素，以PC端为例，操作系统会将(click)鼠标点击事件广播到所有应用中，浏览器应用接受到鼠标事件广播后，查询事件源和对应的回函数（按照先捕获后冒泡的顺序），并压入事件处理队列（Event Queue）。Event Loop 则会从中取出回调函数并执行。<ul>
<li>注册（绑定）事件，浏览器干嘛了？<br>DOM.addEventListener，函数以类似”委托”的形式注册到浏览器内建的队列中，等到某个”事件”被触发后，则回Call之前注册的函数。</li>
<li>执行（响应）事件浏览器干嘛了？<br>当(click)点击某个元素，以PC端为例，操作系统会将(click)鼠标点击事件广播到所有应用中，浏览器应用接受到鼠标事件广播后，查询事件源和对应的回函数（按照先捕获后冒泡的顺序），并压入事件处理队列（Event Queue）。</li>
<li>异步<br>js中的异步没有从语言上约定其异步的特性，是浏览器/执行引擎来实现，我们所探讨的“异步”都是由执行引擎所赋予的。<br>javascript 是的单线程的，于是就产生了一种任务执行机制叫 eventloop。它维护了一个任务队列，完成一个任务才会开始下一个任务。</li>
</ul>
</li>
</ul>
<hr>
<h2 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收?"></a>垃圾回收?</h2><h3 id="为什么要垃圾回收？"><a href="#为什么要垃圾回收？" class="headerlink" title="* 为什么要垃圾回收？"></a>* 为什么要垃圾回收？</h3><p>由于字符串、对象和数组没有固定大小，所有当他们的大小已知时，才能对他们进行动态的存储分配。JavaScript程序每次创建字符串、数组或对象时，解释器都必须分配内存来存储那个实体。只要像这样动态地分配了内存，最终都要释放这些内存以便他们能够被再用，否则，JavaScript的解释器将会消耗完系统中所有可用的内存，造成系统崩溃。</p>
<h3 id="垃圾回收的基本方法？"><a href="#垃圾回收的基本方法？" class="headerlink" title="* 垃圾回收的基本方法？"></a>* 垃圾回收的基本方法？</h3><h4 id="1、标记清除（mark-and-sweep）"><a href="#1、标记清除（mark-and-sweep）" class="headerlink" title="1、标记清除（mark and sweep）"></a><strong>1、标记清除（mark and sweep）</strong></h4><p>　　这是javascript中最常用的垃圾回收方式。当变量进入执行环境是，就标记这个变量为“进入环境”。从逻辑上讲，永远不能释放进入环境的变量所占用的内存，因为只要执行流进入相应的环境，就可能会用到他们。当变量离开环境时，则将其标记为“离开环境”。　　垃圾收集器在运行的时候会给存储在内存中的所有变量都加上标记。然后，它会去掉环境中的变量以及被环境中的变量引用的标记。而在此之后再被加上标记的变量将被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。最后。垃圾收集器完成内存清除工作，销毁那些带标记的值，并回收他们所占用的内存空间。</p>
<h4 id="2。标记清除"><a href="#2。标记清除" class="headerlink" title="2。标记清除"></a>2。标记清除</h4><p>　　另一种不太常见的垃圾回收策略是引用计数。引用计数的含义是跟踪记录每个值被引用的次数。当声明了一个变量并将一个引用类型赋值给该*变量时，则这个值的引用次数就是1。相反，如果包含对这个值引用的变量又取得了另外一个值，则这个值的引用次数就减1。当这个引用次数变成0时，则说明没有办法再访问这个值了，因而就可以将其所占的内存空间给收回来。这样，垃圾收集器下次再运行时，它就会释放那些引用次数为0的值所占的内存。</p>
<h4 id="减少垃圾回收？"><a href="#减少垃圾回收？" class="headerlink" title="* 减少垃圾回收？"></a>* 减少垃圾回收？</h4><p> 1:只保留程序运行时需要的数据，对于已经使用的或者不需要的数据，应该将其值设为 null<br> 2:避免创建对象<br>    清空数组：array.length = 0</p>
<hr>
<h2 id="原生js的-增-删-改-5"><a href="#原生js的-增-删-改-5" class="headerlink" title="原生js的(增 删 改) 5%"></a>原生js的(增 删 改) 5%</h2><p><img src="http://upload-images.jianshu.io/upload_images/2377897-d9abdd592a00f11f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<h3 id="增"><a href="#增" class="headerlink" title="增"></a>增</h3><ul>
<li>若添加新元素：首先创建该元素节点，然后添加</li>
<li>创建元素节点：document.createElement(‘h1’)</li>
<li>创建文本节点：document.createTextNode(‘描述’)</li>
<li>增加：<ul>
<li>添加孩子<ul>
<li>A.append(B) : 把B追加到A内部</li>
<li>A.appendTo(B) : 把A追加到B内部</li>
<li>A.prepend(B) : 在A的开始添加孩子B</li>
<li>A.prependTo(B) : 把A追加到B的开始<ul>
<li>添加兄弟</li>
<li>A.after(B) :  在A后添加B</li>
<li>A.before(B): 在A前追加B</li>
<li>添加class</li>
<li>elm.classList.add(‘nn’)</li>
<li>elm.className+=” nn”  //nn前边有空格</li>
<li>parent.insertBefore(newNode,oldNode):在父节点n里面的B节点前面追加A<br>模拟insertAfter: parent.insertBefore(newNode,oN.nextsilibing());</li>
<li>替换节点：parent.replaceChild(child,oldElem);</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="删"><a href="#删" class="headerlink" title="删"></a>删</h3><ul>
<li>elementNow.remove():删除当前元素</li>
<li>parent.removeChild(child):删除父元素中的子元素</li>
<li>child.parentNode.removeChild(child)：不确定父元素的时候可以这样做<h3 id="改"><a href="#改" class="headerlink" title="改"></a>改</h3><a href="http://www.jianshu.com/writer#/notebooks/10862078/notes/15825654/preview" target="_blank" rel="external">http://www.jianshu.com/writer#/notebooks/10862078/notes/15825654/preview</a><ul>
<li>( 获取，设置) 修改HTML元素内容<ul>
<li>node.textContent:用来设置或是获取某个元素内所有文本内容，包括子元素中的内容。（css等兼容性比innerText好）</li>
<li>node.innerText: 只获取当前节点内容</li>
<li>node.innerHTML：</li>
<li>node.outerHTML：</li>
</ul>
</li>
<li>更改属性<ul>
<li>设置属性：node.setAttribute(‘style’,’color:red’)</li>
<li>获取属性：var a = node.getAttribute(‘’style’’);</li>
</ul>
</li>
<li>修改元素CSS<ul>
<li>node.style.color=”red”<h3 id="查"><a href="#查" class="headerlink" title="查"></a>查</h3></li>
</ul>
</li>
<li>querySelector()、</li>
<li>querySelectorAll()</li>
<li>getElementById()、</li>
<li>getElementsByTagName()、</li>
<li>getElementsByName()、</li>
<li>getElementsByClassName()、</li>
</ul>
</li>
</ul>
<hr>
<h3 id="jq增删改查"><a href="#jq增删改查" class="headerlink" title="jq增删改查"></a>jq增删改查</h3><ul>
<li>内部插入主要方法：<ul>
<li>append(content) 向每个匹配的元素内部追加内容。</li>
<li>prepend(content) 向每个匹配的元素内部前置内容。</li>
</ul>
</li>
<li>外部插入：<ul>
<li>after(content) 在每个匹配的元素之后插入内容。</li>
<li>before(content) 在每个匹配的元素之前插入内容。</li>
</ul>
</li>
<li>删除：<ul>
<li>empty() 删除匹配的元素集合中所有的子节点。</li>
<li>remove([expr]) 从DOM中删除所有匹配的元素。</li>
</ul>
</li>
</ul>
<hr>
<h2 id="深拷贝与浅拷贝"><a href="#深拷贝与浅拷贝" class="headerlink" title="深拷贝与浅拷贝"></a>深拷贝与浅拷贝</h2><p>深拷贝与浅拷贝是之于Array,Object来说的，来由背景，引用类型对象的赋值，一个改变，会引起另一个改变，因为两个变量指向同一个堆空间放的对象</p>
<ul>
<li>深拷贝和浅拷贝最根本的区别在于是否是真正获取了一个对象的复制实体，而不是引用地址<figure class="highlight plain"><figcaption><span>a = &#123;b:'k'&#125;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var c = a;</span><br><span class="line">a.b = &apos;carry&apos;;</span><br><span class="line">c.b? 答案是&apos;carry&apos;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>那么我们如何给引用类型对象赋值（copy），完全隔离，互不影响呢？</p>
<h3 id="数组深拷贝"><a href="#数组深拷贝" class="headerlink" title="数组深拷贝"></a>数组深拷贝</h3><ul>
<li>ES6拷贝数组Array.from， […oldArr]</li>
<li>使用循环遍历拷贝</li>
<li>使用slice，concat进行数组拷贝</li>
</ul>
<h4 id="1-使用slice，concat进行数组拷贝"><a href="#1-使用slice，concat进行数组拷贝" class="headerlink" title="1.使用slice，concat进行数组拷贝"></a>1.使用slice，concat进行数组拷贝</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1. var a = [1,2];</span><br><span class="line">var b = a.slice(0);</span><br><span class="line">b[0] = 3;</span><br><span class="line">alert(a) //1,2</span><br><span class="line">2. var a = [1,2];</span><br><span class="line">var b = a.concat(0);</span><br></pre></td></tr></table></figure>
<h4 id="2-使用循环遍历拷贝"><a href="#2-使用循环遍历拷贝" class="headerlink" title="2.使用循环遍历拷贝"></a>2.使用循环遍历拷贝</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var arr1=[1,2,3,4];</span><br><span class="line">var arr2=[];</span><br><span class="line">for(var i=0; i&lt;arr1.length; i++)&#123;</span><br><span class="line">  arr2[i]=arr1[i];</span><br><span class="line">&#125;</span><br><span class="line">arr1.push(5);</span><br><span class="line">arr2.push(6);</span><br><span class="line">alert(arr1); //12345</span><br><span class="line">alert(arr2); //12346</span><br></pre></td></tr></table></figure>
<h4 id="3-ES6拷贝数组Array-from，-…oldArr"><a href="#3-ES6拷贝数组Array-from，-…oldArr" class="headerlink" title="3. ES6拷贝数组Array.from， […oldArr]"></a>3. ES6拷贝数组Array.from， […oldArr]</h4><ul>
<li>第一种：var newArr = Array.from(oldArr);</li>
<li>第二种：var newArr = […oldArr]<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var arr1=[1,2,3];</span><br><span class="line">var arr2=Array.from(arr1);</span><br><span class="line">arr1.push(4);</span><br><span class="line">alert(arr1);  //1234</span><br><span class="line">alert(arr2);  //123</span><br><span class="line">arr2.push(5);</span><br><span class="line">alert(arr1);  //1234</span><br><span class="line">alert(arr2);  //1235</span><br></pre></td></tr></table></figure>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var arr1=[1,2,3];</span><br><span class="line">var arr2=[...arr1];</span><br><span class="line">arr1.push(4);</span><br><span class="line">alert(arr1);  //1234</span><br><span class="line">alert(arr2);  //123</span><br><span class="line">arr2.push(5);</span><br><span class="line">alert(arr1);  //1234</span><br><span class="line">alert(arr2);  //1235</span><br></pre></td></tr></table></figure>
<h3 id="对象深拷贝"><a href="#对象深拷贝" class="headerlink" title="对象深拷贝"></a>对象深拷贝</h3><ul>
<li>JSON对象的parse和stringify</li>
<li>jQuery中的extend复制方法</li>
</ul>
<h4 id="JSON对象的parse和stringify"><a href="#JSON对象的parse和stringify" class="headerlink" title="JSON对象的parse和stringify"></a>JSON对象的parse和stringify</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var source = &#123;</span><br><span class="line">    name:&quot;source&quot;,</span><br><span class="line">    child:&#123;</span><br><span class="line">        name:&quot;child&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var target = JSON.parse(JSON.stringify(source));</span><br><span class="line">//改变target的name属性</span><br><span class="line">target.name = &quot;target&quot;;</span><br><span class="line">console.log(source.name);   //source</span><br><span class="line">console.log(target.name);   //target</span><br><span class="line">//改变target的child</span><br><span class="line">target.child.name = &quot;target child&quot;;</span><br><span class="line">console.log(source.child.name);  //child</span><br><span class="line">console.log(target.child.name);  //target child</span><br></pre></td></tr></table></figure>
<h4 id="jQuery中的extend复制方法"><a href="#jQuery中的extend复制方法" class="headerlink" title="jQuery中的extend复制方法"></a>jQuery中的extend复制方法</h4><h3 id="自己实现深拷贝"><a href="#自己实现深拷贝" class="headerlink" title="自己实现深拷贝"></a>自己实现深拷贝</h3><ul>
<li>判断对象数据类型 Object.prototype.toString.call(obj);</li>
<li>若为Object则实现深拷贝</li>
<li>Array和Object 用遍历的方式深拷贝<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">//util作为判断变量具体类型的辅助模块</span><br><span class="line">   var util = (function()&#123;</span><br><span class="line">       var class2type = &#123;&#125;;</span><br><span class="line">       [&quot;Null&quot;,&quot;Undefined&quot;,&quot;Number&quot;,&quot;Boolean&quot;,&quot;String&quot;,&quot;Object&quot;,&quot;Function&quot;,&quot;Array&quot;,&quot;RegExp&quot;,&quot;Date&quot;].forEach(function(item)&#123;</span><br><span class="line">           class2type[&quot;[object &quot;+ item + &quot;]&quot;] = item.toLowerCase();</span><br><span class="line">       &#125;)</span><br><span class="line"> </span><br><span class="line">       function isType(obj, type)&#123;</span><br><span class="line">           return getType(obj) === type;</span><br><span class="line">       &#125;</span><br><span class="line">       function getType(obj)&#123;</span><br><span class="line">           return class2type[Object.prototype.toString.call(obj)] || &quot;object&quot;;</span><br><span class="line">       &#125;</span><br><span class="line">       return &#123;</span><br><span class="line">           isType:isType,</span><br><span class="line">           getType:getType</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;)();</span><br><span class="line"> </span><br><span class="line">   function copy(obj,deep)&#123;</span><br><span class="line">        //如果obj不是对象，那么直接返回值就可以了</span><br><span class="line">       if(obj === null || typeof obj !== &quot;object&quot;)&#123;</span><br><span class="line">           return obj;</span><br><span class="line">       &#125;</span><br><span class="line">　　　　//定义需要的局部变脸，根据obj的类型来调整target的类型</span><br><span class="line">       var i, target = util.isType(obj,&quot;array&quot;) ? [] : &#123;&#125;,value,valueType;</span><br><span class="line">       for(i in obj)&#123;</span><br><span class="line">           value = obj[i];</span><br><span class="line">           valueType = util.getType(value);</span><br><span class="line">　　　　　　　//只有在明确执行深复制，并且当前的value是数组或对象的情况下才执行递归复制</span><br><span class="line">           if(deep &amp;&amp; (valueType === &quot;array&quot; || valueType === &quot;object&quot;))&#123;</span><br><span class="line">               target[i] = copy(value);</span><br><span class="line">           &#125;else&#123;</span><br><span class="line">               target[i] = value;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       return target;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h2 id="new"><a href="#new" class="headerlink" title="new"></a>new</h2><h3 id="New一共做了几个操作步骤，要求具体说明"><a href="#New一共做了几个操作步骤，要求具体说明" class="headerlink" title="New一共做了几个操作步骤，要求具体说明"></a>New一共做了几个操作步骤，要求具体说明</h3><ol>
<li><p>创建空对象；<br>　　var obj = {};</p>
</li>
<li><p>设置新对象的constructor属性为构造函数的名称，设置新对象的<strong>proto</strong>属性指向构造函数的prototype对象；<br>　　obj.<strong>proto</strong> = ClassA.prototype;</p>
</li>
<li><p>使用新对象调用函数，函数中的this被指向新实例对象：<br>　　ClassA.call(obj);　　//{}.构造函数();          </p>
</li>
<li><p>将初始化完毕的新对象地址，保存到等号左边的变量中</p>
<h3 id="new一个对象-执行了什么过程？，那-return-‘-’，null-undefined会怎样？"><a href="#new一个对象-执行了什么过程？，那-return-‘-’，null-undefined会怎样？" class="headerlink" title="new一个对象 执行了什么过程？，那 return ‘ ’，null,undefined会怎样？"></a>new一个对象 执行了什么过程？，那 return ‘ ’，null,undefined会怎样？</h3></li>
</ol>
<hr>
<h2 id="如何判定js一个变量值的类型（至少3种）3"><a href="#如何判定js一个变量值的类型（至少3种）3" class="headerlink" title="如何判定js一个变量值的类型（至少3种）3%"></a>如何判定js一个变量值的类型（至少3种）3%</h2><p>Object.prototype.toString.call(obj)<br>[] instanceof Array<br>[].constructor === Object</p>
<hr>
<h2 id="数组和字符串的转换-3"><a href="#数组和字符串的转换-3" class="headerlink" title="数组和字符串的转换 3%"></a>数组和字符串的转换 3%</h2><p>split,join</p>
<hr>
<h2 id="arguments"><a href="#arguments" class="headerlink" title="arguments"></a>arguments</h2><h3 id="是啥？"><a href="#是啥？" class="headerlink" title="是啥？"></a>是啥？</h3><p>函数参数对象，不是数组，但是有length属性，也能arguments[0]取值</p>
<h3 id="转为数组？"><a href="#转为数组？" class="headerlink" title="转为数组？"></a>转为数组？</h3><ul>
<li>Array.prototype.slice.apply(arguments)这是运行效率比较快的方法</li>
<li>Array.prototype.concat.apply(thisArg,arguments)</li>
<li>Array.prototype.slice.call(arguments);<br>对象转为数组</li>
<li>Array.from(arguments) </li>
<li>[…arguments]<h3 id="arguments其他用法？"><a href="#arguments其他用法？" class="headerlink" title="arguments其他用法？"></a>arguments其他用法？</h3><h4 id="利用arguments-callee实现递归"><a href="#利用arguments-callee实现递归" class="headerlink" title="利用arguments.callee实现递归"></a>利用arguments.callee实现递归</h4></li>
</ul>
<hr>
<h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><h3 id="1-arguments-callee"><a href="#1-arguments-callee" class="headerlink" title="1.arguments.callee"></a>1.arguments.callee</h3><p>解决函数名递归带来的危险，arguments.callee指向正在执行的函数，使用它来代替函数名<br>arguments.callee是一个指向正在执行的函数的指针<br>好处：不用使用当前函数进行递归，性能变高<br>缺点：严格模式下不管用</p>
<h3 id="2-使用函数命名表达式"><a href="#2-使用函数命名表达式" class="headerlink" title="2.使用函数命名表达式"></a>2.使用函数命名表达式</h3><p>一个函数两个名字<br>有点：严格模式和非严格模式都适用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var factorial = （ function f(num)&#123;</span><br><span class="line">  return num * f(num-1)</span><br><span class="line">&#125;）</span><br></pre></td></tr></table></figure></p>
<h3 id="3-递归性能上的分析？优化？用es6优化？"><a href="#3-递归性能上的分析？优化？用es6优化？" class="headerlink" title="3.递归性能上的分析？优化？用es6优化？"></a>3.递归性能上的分析？优化？用es6优化？</h3><p>递归非常耗费内存，因为需要同时保存成千上百个调用帧，很容易发生“栈溢出”错误（stack overflow）</p>
<h4 id="使用尾调递归优化递归"><a href="#使用尾调递归优化递归" class="headerlink" title="使用尾调递归优化递归"></a>使用尾调递归优化递归</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function factorial(n) &#123;</span><br><span class="line">  if (n === 1) return 1;</span><br><span class="line">  return n * factorial(n - 1);</span><br><span class="line">&#125;</span><br><span class="line">factorial(5) // 120</span><br></pre></td></tr></table></figure>
<p>比正常递归函数多了一个参数total<br>尾递归，只保留一个调用记录，复杂度 O(1)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function factorial(n, total) &#123;</span><br><span class="line">  if (n === 1) return total;</span><br><span class="line">  return factorial(n - 1, n * total);</span><br><span class="line">&#125;</span><br><span class="line">factorial(5, 1) // 120</span><br></pre></td></tr></table></figure></p>
<h4 id="ES6尾调用"><a href="#ES6尾调用" class="headerlink" title="ES6尾调用"></a>ES6尾调用</h4><p>ES6 的尾调用优化只在严格模式下开启，正常模式是无效的。<br>这是因为在正常模式下，函数内部有两个变量，可以跟踪函数的调用栈。<br>func.arguments：返回调用时函数的参数。<br>func.caller：返回调用当前函数的那个函数。<br>尾调用优化发生时，函数的调用栈会改写，因此上面两个变量就会失真。严格模式禁用这两个变量，所以尾调用模式仅在严格模式下生效。</p>
<hr>
<h2 id="字符串和json的转换3"><a href="#字符串和json的转换3" class="headerlink" title="字符串和json的转换3%"></a>字符串和json的转换3%</h2><p>JSON.stringify( );<br>JSON.parse（）</p>
<h2 id="eval"><a href="#eval" class="headerlink" title="eval()"></a>eval()</h2><p>eval() 函数可计算某个字符串，并执行其中的的 JavaScript 代码。<br>eval(“alert(‘Hello world’)”)<br>eval(“x=10;y=20;document.write(x*y)”)</p>
<h2 id="typeof-输出"><a href="#typeof-输出" class="headerlink" title="typeof 输出"></a>typeof 输出</h2><p>typeof(的)运算数未定义,返回(的)就是 “undefined”.<br>typeof(undifiend)//undifiend</p>
<p>运算数为数字 typeof(x) = “number”<br>字符串 typeof(x) = “string”<br>布尔值 typeof(x) = “boolean”<br>对象,数组和null typeof(x) = “object”<br>函数 typeof(x) = “function”<br>        typeof(‘aa’+4);//string<br>       typeof(‘1’+undifiend);//报错</p>
<hr>
<h2 id="链式调用"><a href="#链式调用" class="headerlink" title="链式调用"></a>链式调用</h2><p>所谓链式调用就是能够返回自身对象<br>$(‘#id’).show().hide().show().hide().show().hide();<br>有点：代码简洁易读，减少了多次重复使用同一个变量</p>
<h3 id="1-方法中直接-return-this"><a href="#1-方法中直接-return-this" class="headerlink" title="1.方法中直接 return this"></a>1.方法中直接 return this</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">   function ClassA()&#123;</span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line">    ClassA.prototype = &#123;</span><br><span class="line">        hide:function()&#123;</span><br><span class="line">            console.log(&apos;hide&apos;);</span><br><span class="line">            return this;</span><br><span class="line">        &#125;,</span><br><span class="line">    getName:function(callback)&#123;</span><br><span class="line">         if(callback)&#123;</span><br><span class="line">            callback.call(this,this.name);</span><br><span class="line">         &#125;</span><br><span class="line">        return this;</span><br><span class="line">      &#125;,</span><br><span class="line">        show:function()&#123;</span><br><span class="line">            console.log(&apos;show&apos;);</span><br><span class="line">            return this;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">var a = new ClassA();</span><br><span class="line">a.show().hide().show().hide().show();</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h2><h2 id="如何解决ajax跨域"><a href="#如何解决ajax跨域" class="headerlink" title="如何解决ajax跨域"></a>如何解决ajax跨域</h2><h3 id="1-CROS方式（跨域资源共享）"><a href="#1-CROS方式（跨域资源共享）" class="headerlink" title="1.CROS方式（跨域资源共享）"></a>1.CROS方式（跨域资源共享）</h3><p> 原理 ：配置的两大基本信息,Origin和headers<br>第一步:配置Php 后台允许跨域<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">header(&apos;Access-Control-Allow-Origin: *&apos;);</span><br><span class="line">header(&apos;Access-Control-Allow-Headers: Origin, X-Requested-With, Content-Type, Accept&apos;);</span><br><span class="line">//主要为跨域CORS配置的两大基本信息,Origin和headers</span><br></pre></td></tr></table></figure></p>
<p>第二步:配置Apache web服务器跨域(httpd.conf中)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;Directory /&gt;</span><br><span class="line">   //AllowOverride none</span><br><span class="line">    //Require all denied</span><br><span class="line">    Options FollowSymLinks</span><br><span class="line">    AllowOverride none</span><br><span class="line">    Order deny,allow</span><br><span class="line">    Allow from all</span><br><span class="line">&lt;/Directory&gt;</span><br></pre></td></tr></table></figure></p>
<hr>
<h3 id="2-JSONP方式"><a href="#2-JSONP方式" class="headerlink" title="2.JSONP方式"></a>2.JSONP方式</h3><p>jsonp解决跨域问题是一个比较古老的方案(实际中不推荐使用),这里做简单介绍(实际项目中如果要使用JSONP,一般会使用JQ等对JSONP进行了封装的类库来进行ajax请求)</p>
<p>实现原理</p>
<p>JSONP之所以能够用来解决跨域方案,主要是因为 <script> 脚本拥有跨域能力,而JSONP正是利用这一点来实现。具体原理如图<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">function addScriptTag(src) &#123;</span><br><span class="line">  var script = document.createElement(&apos;script&apos;);</span><br><span class="line">  script.setAttribute(&quot;type&quot;,&quot;text/javascript&quot;);</span><br><span class="line">  script.src = src;</span><br><span class="line">  document.body.appendChild(script);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">window.onload = function () &#123;</span><br><span class="line">  addScriptTag(&apos;http://example.com/ip?callback=foo&apos;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function foo(data) &#123;</span><br><span class="line">  console.log(&apos;response data: &apos; + JSON.stringify(data));</span><br><span class="line">&#125;;</span><br><span class="line">服务端对应的接口在返回参数外面添加函数包裹层</span><br><span class="line">foo(&#123;</span><br><span class="line">  &quot;test&quot;: &quot;testData&quot;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<h4 id="jsonp的弊端"><a href="#jsonp的弊端" class="headerlink" title="jsonp的弊端"></a>jsonp的弊端</h4><p>JSONP只支持GET请求，CORS支持所有类型的HTTP请求。JSONP的优势在于支持老式浏览器，以及可以向不支持CORS的网站请求数据。</p>
<h2 id="请求代理进行跨域nginx"><a href="#请求代理进行跨域nginx" class="headerlink" title="请求代理进行跨域nginx"></a>请求代理进行跨域nginx</h2><hr>
<p>如何解决ajax跨域</p>
<p>一般ajax跨域解决就是通过JSONP解决或者CORS解决,如以下:(注意，现在已经几乎不会再使用JSONP了，所以JSONP了解下即可)</p>
<h2 id="其他跨域"><a href="#其他跨域" class="headerlink" title="其他跨域"></a>其他跨域</h2><p>2:通过修改document.domain来跨子域<br>仅在相同主域下才有效，且window.domain需要设置为相同的父域 不同的框架之间是可以获取window对象的，但却无法获取相应的属性和方法。<br>比如，有一个页面，它的地址是<a href="http://www.example.com/a.html">http://www.example.com/a.html</a> ，<br>在这个页面里面有一个iframe，它的src是<a href="http://example.com/b.html">http://example.com/b.html</a>,<br>很显然，这个页面与它里面的iframe框架是不同域的，所以我们是无法通过在页面中书写js代码来获取iframe中的东西的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">    function test()&#123;</span><br><span class="line">        var iframe = document.getElementById(&apos;iframe&apos;);</span><br><span class="line">        var win = document.contentWindow;//可以获取到iframe里的window对象，但该window对象的属性和方法几乎是不可用的</span><br><span class="line">        var doc = win.document;//这里获取不到iframe里的document对象</span><br><span class="line">        var name = win.name;//这里同样获取不到window对象的name属性</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;iframe id = &quot;iframe&quot; src=&quot;http://example.com/b.html&quot; onload = &quot;test()&quot;&gt;&lt;/iframe&gt;</span><br></pre></td></tr></table></figure></p>
<p><img src="http://upload-images.jianshu.io/upload_images/2377897-b81be614658808c3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"><br>3:</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2377897-d51bad8105ff7116.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"><br>4：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2377897-665a15e11ea92788.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"><br>5：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2377897-2e14787d1c2eae05.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<hr>
<h2 id="if-false-的几种情况"><a href="#if-false-的几种情况" class="headerlink" title="if() false 的几种情况"></a>if() false 的几种情况</h2><ul>
<li>if(false)</li>
<li>if(null)</li>
<li>if(undefined)</li>
<li>if(‘’)</li>
<li>if(NaN)-数字NaN</li>
<li>if(0)-数字0</li>
</ul>
<hr>
<h2 id="Ajax实现流程"><a href="#Ajax实现流程" class="headerlink" title="Ajax实现流程"></a>Ajax实现流程</h2><p>创建一个XMLHttpRequest()实例<br>准备一个Ajax请求以待发送<br>发送Ajax请求<br>根据服务器响应的结果，将相应数据填充到xhr对象的属性中 注意url是相对于执行代码的当前页面，也可以是绝对路径。</p>
<p>var xhr = new XMLHttpRequest();<br>xhr.open(Type,URL,Boolean);<br>//请求类型，请求地址，是否异步<br>xhr.send(null);<br>xhr.onreadystatechange = function(){<br>    if(xhr.readyState == 4){<br>        if(xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300 || xhr.status == 304){<br>            alert(xhr.responseText);<br>        }else {<br>            alert(‘unsuccessful ‘ + xhr.status);<br>        }<br>    }<br>};</p>
<hr>
<h2 id="单线程"><a href="#单线程" class="headerlink" title="单线程"></a>单线程</h2><p>为什么javascrip是单线程<br>JavaScript的单线程，与它的用途有关。作为浏览器脚本语言，JavaScript的主要用途是与用户互动，以及操作DOM。这决定了它只能是单线程，否则会带来很复杂的同步问题。<br>浏览器端多线程<br>js<br>css<br>事件<br>数据交互</p>
<hr>
<h2 id="垃圾回收-1"><a href="#垃圾回收-1" class="headerlink" title="垃圾回收"></a>垃圾回收</h2><p>垃圾收集器必须跟踪哪个变量有用哪个变量没用，对于不再有用的变量打上标记，以备将来收回其占用的内存，内存泄露和浏览器实现的垃圾回收机制息息相关， 而浏览器实现标识无用变量的策略主要有下两个方法：<br>第一，引用计数法<br>跟踪记录每个值被引用的次数。当声明一个变量并将引用类型的值赋给该变量时，则这个值的引用次数就是1。如果同一个值又被赋给另一个变量，则该值的引用次 数加1.相反，如果包含对这个值引用的变量又取得另外一个值，则这个值的引用次数减1.当这个值的引用次数变成0时，则说明没有办法访问这个值了，因此就 可以将其占用的内存空间回收回来。</p>
<p>如： var a = {};     //对象{}的引用计数为1<br>     b = a;          //对象{}的引用计数为 1+1<br>     a = null;       //对象{}的引用计数为2-1<br>所以这时对象{}不会被回收;<br>IE 6, 7 对DOM对象进行引用计数回收， 这样简单的垃圾回收机制，非常容易出现循环引用问题导致内存不能被回收， 进行导致内存泄露等问题，一般不用引用计数法。<br>第二，标记清除法<br>到2008年为止，IE,Firefox,Opera,Chrome和Safari的javascript实现使用的都是标记清除式的垃圾收集策略（或类似的策略），只不过垃圾收集的时间间隔互有不同。<br>标记清除的算法分为两个阶段，标记(mark)和清除(sweep). 第一阶段从引用根节点开始标记所有被引用的对象，第二阶段遍历整个堆，把未标记的对象清除。</p>
<hr>
<h2 id="javascript创建对象的几种方式？"><a href="#javascript创建对象的几种方式？" class="headerlink" title="javascript创建对象的几种方式？"></a>javascript创建对象的几种方式？</h2><p> javascript创建对象简单的说,无非就是使用内置对象或各种自定义对象，当然还可以用JSON；但写法有很多种，也能混合使用。</p>
<p> 1、对象字面量的方式</p>
<pre><code>person={firstname:&quot;Mark&quot;,lastname:&quot;Yun&quot;,age:25,eyecolor:&quot;black&quot;};
</code></pre><p> 2、用function来模拟无参的构造函数</p>
<pre><code>function Person(){}
var person=new Person();//定义一个function，如果使用new&quot;实例化&quot;,该function可以看作是一个Class
person.name=&quot;Mark&quot;;
person.age=&quot;25&quot;;
person.work=function(){
alert(person.name+&quot; hello...&quot;);
}
person.work();
</code></pre><p> 3、用function来模拟参构造函数来实现（用this关键字定义构造的上下文属性）</p>
<pre><code>function Pet(name,age,hobby){
   this.name=name;//this作用域：当前对象
   this.age=age;
   this.hobby=hobby;
   this.eat=function(){
      alert(&quot;我叫&quot;+this.name+&quot;,我喜欢&quot;+this.hobby+&quot;,是个程序员&quot;);
   }
}
var maidou =new Pet(&quot;麦兜&quot;,25,&quot;coding&quot;);//实例化、创建对象
maidou.eat();//调用eat方法
</code></pre><p> 4、用工厂方式来创建（内置对象）</p>
<pre><code>var wcDog =new Object();
wcDog.name=&quot;旺财&quot;;
wcDog.age=3;
wcDog.work=function(){
  alert(&quot;我是&quot;+wcDog.name+&quot;,汪汪汪......&quot;);
}
wcDog.work();
</code></pre><p> 5、用原型方式来创建</p>
<pre><code>function Dog(){

 }
 Dog.prototype.name=&quot;旺财&quot;;
 Dog.prototype.eat=function(){
 alert(this.name+&quot;是个吃货&quot;);
 }
 var wangcai =new Dog();
 wangcai.eat();
</code></pre><p> 5、用混合方式来创建</p>
<pre><code>function Car(name,price){
  this.name=name;
  this.price=price;
}
 Car.prototype.sell=function(){
   alert(&quot;我是&quot;+this.name+&quot;，我现在卖&quot;+this.price+&quot;万元&quot;);
  }
var camry =new Car(&quot;凯美瑞&quot;,27);
camry.sell();
</code></pre><hr>
<h2 id="JavaScript有几种类型的值？，你能画一下他们的内存图吗？"><a href="#JavaScript有几种类型的值？，你能画一下他们的内存图吗？" class="headerlink" title="JavaScript有几种类型的值？，你能画一下他们的内存图吗？"></a>JavaScript有几种类型的值？，你能画一下他们的内存图吗？</h2><p> 栈：原始数据类型（Undefined，Null，Boolean，Number、String）<br> 堆：引用数据类型（对象、数组和函数）</p>
<p> 两种类型的区别是：存储位置不同；<br> 原始数据类型直接存储在栈(stack)中的简单数据段，占据空间小、大小固定，属于被频繁使用数据，所以放入栈中存储；<br> 引用数据类型存储在堆(heap)中的对象,占据空间大、大小不固定。如果存储在栈中，将会影响程序运行的性能；引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2377897-f0c90cfaba1aabac.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<hr>
<h2 id="说几条写JavaScript的基本规范？"><a href="#说几条写JavaScript的基本规范？" class="headerlink" title="说几条写JavaScript的基本规范？"></a>说几条写JavaScript的基本规范？</h2><p> 1.不要在同一行声明多个变量。<br> 2.请使用 ===/!==来比较true/false或者数值<br> 3.使用对象字面量替代new Array这种形式<br> 4.不要使用全局函数。<br> 5.Switch语句必须带有default分支<br> 6.函数不应该有时候有返回值，有时候没有返回值。<br> 7.For循环必须使用大括号<br> 8.If语句必须使用大括号<br> 9.for-in循环中的变量 应该使用var关键字明确限定作用域，从而避免作用域污染。</p>
<hr>
<h1 id="Node-amp-Express"><a href="#Node-amp-Express" class="headerlink" title="Node&amp;Express"></a>Node&amp;Express</h1><ul>
<li>基于node的其他web开发框架</li>
<li>node 有关的知识点</li>
</ul>
<hr>
<h2 id="express"><a href="#express" class="headerlink" title="express"></a>express</h2><p>Express 是一个基于 Node的极简灵活的web 应用开发框架。Express是在Node之上扩展了 Web 应用所需的基本功能。<br>Express完全是由中间件构成一个的 web 开发框架：从本质上来说，一个 Express 应用就是在调用各种中间件。</p>
<h3 id="中间件含义"><a href="#中间件含义" class="headerlink" title="中间件含义"></a>中间件含义</h3><p>是一个函数或功能，（err,res,rep,next），是封装在程序中处理请求的功能。后台的请求分为一部分一部分，每一部分都有中间件来完成,之道响应完毕</p>
<h3 id="Express-几种中间件："><a href="#Express-几种中间件：" class="headerlink" title="Express 几种中间件："></a>Express 几种中间件：</h3><p>应用级中间件<br>绑定到app 对象使用 app.use()和 app.METHOD()， 其中， METHOD 是需要处理的 HTTP 请求的方法，例如 GET, PUT, POST 等等</p>
<p>路由级中间件<br>绑定的对象为 express.Router()。路由级使用 router.use() 加载</p>
<p>错误处理中间件<br>4 个参数，而不是 3 个，其签名如下： (err, req, res, next)。</p>
<p>内置的中间件<br>express.static是 Express 唯一内置的中间件。负责在 Express 应用中托管静态资源。</p>
<p>第三方中间件<br>例如 cookie-parser</p>
<hr>
<h1 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h1><p> 对前端安全有什么看法？<br>是否了解Web注入攻击，说下原理，最常见的两种攻击（XSS 和 CSRF）了解到什么程度？</p>
<p>1, XSS(cross-site scripting跨域脚本攻击)是一种经常出现在web应用中的计算机安全漏洞，它允许恶意web用户将代码植入到提供给其它用户使用的页面中。 其实在web前端方面，可以简单的理解为一种javascript代码注入。 解决方法：将前端输出数据都进行转义（$lt,$gt）</p>
<p>2, CSRF（cross-site request forgery），翻译为跨站请求伪造，与XSS非常相似，但XSS是利用用户对当前网站的信任来发起攻击，而CSRF是利用网站对用户的信任来发起攻击(即模拟请求攻击)。</p>
<p>对于CSRF攻击，我们所能做的可以有：</p>
<p>检查报头中的Referer参数确保请求发自正确的网站（但XHR请求可调用setRequestHeader方法来修改Referer报头）；<br>对于任何重要的请求都需要重新验证用户的身份；<br>创建一个唯一的令牌（Token），将其存在服务端的session中及客户端的cookie中，对任何请求，都检查二者是否一致。</p>
<hr>
<h1 id="网络部分"><a href="#网络部分" class="headerlink" title="网络部分"></a>网络部分</h1><h2 id="一个页面从输入-URL-到页面加载显示完成，这个过程中都发生了什么？（流程说的越详细越好）"><a href="#一个页面从输入-URL-到页面加载显示完成，这个过程中都发生了什么？（流程说的越详细越好）" class="headerlink" title="一个页面从输入 URL 到页面加载显示完成，这个过程中都发生了什么？（流程说的越详细越好）"></a>一个页面从输入 URL 到页面加载显示完成，这个过程中都发生了什么？（流程说的越详细越好）</h2><p> 详细版：<br>      1、浏览器会开启一个线程来处理这个请求，对 URL 分析判断如果是 http 协议就按照 Web 方式来处理;<br>      2、调用浏览器内核中的对应方法，比如 WebView 中的 loadUrl 方法;<br>      3、通过DNS解析获取网址的IP地址，设置 UA 等信息发出第二个GET请求;<br>      4、进行HTTP协议会话，客户端发送报头(请求报头);<br>      5、进入到web服务器上的 Web Server，如 Apache、Tomcat、Node.JS 等服务器;<br>      6、进入部署好的后端应用，如 PHP、Java、JavaScript、Python 等，找到对应的请求处理;<br>      7、处理结束回馈报头，此处如果浏览器访问过，缓存上有对应资源，会与服务器最后修改时间对比，一致则返回304;<br>      8、浏览器开始下载html文档(响应报头，状态码200)，同时使用缓存;<br>      9、文档树建立，根据标记请求所需指定MIME类型的文件（比如css、js）,同时设置了cookie;<br>      10、页面开始渲染DOM，JS根据DOM API操作DOM,执行事件绑定等，页面显示完成。</p>
<pre><code>简洁版：
  浏览器根据请求的URL交给DNS域名解析，找到真实IP，向服务器发起请求；
  服务器交给后台处理完成后返回数据，浏览器接收文件（HTML、JS、CSS、图象等）；
  浏览器对加载到的资源（HTML、JS、CSS等）进行语法解析，建立相应的内部数据结构（如HTML的DOM）；
  载入解析到的资源文件，渲染页面，完成。
</code></pre><hr>
<h2 id="页面渲染流程主要分三部分"><a href="#页面渲染流程主要分三部分" class="headerlink" title="页面渲染流程主要分三部分"></a>页面渲染流程主要分三部分</h2><p>HTML文档解析生成DOM树<br>DOM树构建完到Webkit绘制上下文<br>上下文到最终生成的图像 (JavaScript省略为JS)<br>当用户输入URL时候，WebKit调用其资源加载器加载该URL对应的网页。<br>加载器依赖网络模块建立连接，发送请求并接受答复。<br>WebKit收到各种网页或资源的数据，可能是同步或者是异步获取的。<br>网页被交给HTML解释器转换成一系列词语(Token)。<br>解释器根据词语构建节点(Node)，形成DOM树。<br>如果节点是JS，调用JS引擎解释并执行。<br>JS代码修改DOM树的结构<br>如果节点需要依赖其他资源，如图片、css等，调用资源加载器来加载他们，但他们是异步的，不会阻碍当前DOM树的继续构建，如果是JS资源URL(未标记异步)，则需要停止当前DOM数的构建，直到JS引擎执行后才继续构建DOM树。 至此会触发两个事件，一个时DOMConent表示DOM构建完全(和jQuery的$(function(){})()一样),后者是 onload 事件，表示DOM树所依赖的各种图片、css等资源加载完毕，通常这两个事件不是同时发生。<br>接下来是利用CSS和DOM树构建RenderObject树直到绘图上下文。</p>
<p>CSS文件被CSS解释器解释成表示结构。<br>CSS解释器完成工作之后，在DOM树上附加解释后的样式信息，包括布局计算，这就是RenderObject树。<br>RenderObject节点在创建的同时，WebKit会根据网页的层次结构创建RenderLayer树，同时构建一个虚拟的绘图上下文。<br>实际上，DOM树，RenderObject树，RenderLayer树和绘图上下文在关闭浏览器前并不会被销毁。</p>
<p>最后，根据绘图上下文生成最终图像，主要依赖2D和3D图形库。</p>
<p>绘图上下文将每个绘图操作桥接到不同的具体实现类，也就是绘图具体实现类，绘图实现类将2D图形库或者3D图形库绘制的结果保存下来，交给浏览器来显示。</p>
<h2 id="浏览器接收到服务器文件（HTML、JS、CSS、图象等），开始加载资源，对于加载到的资源进行以下操作："><a href="#浏览器接收到服务器文件（HTML、JS、CSS、图象等），开始加载资源，对于加载到的资源进行以下操作：" class="headerlink" title="浏览器接收到服务器文件（HTML、JS、CSS、图象等），开始加载资源，对于加载到的资源进行以下操作："></a>浏览器接收到服务器文件（HTML、JS、CSS、图象等），开始加载资源，对于加载到的资源进行以下操作：</h2><ul>
<li>浏览器解析<ul>
<li>解析html形成 Dom Tree</li>
<li>解析 css 形成 Css Rule Tree</li>
<li>Js通过  DOM API和CSSOM API来操作DOM Tree和CSS Rule Tree</li>
</ul>
</li>
<li>构建Render Tree<ul>
<li>浏览器引擎用Dom Tree 和 Css Rule Tree 构建 Render Tree<ul>
<li>Css Rule Tree对比DOM生成Style Context Tree</li>
</ul>
</li>
</ul>
</li>
<li>绘制网页</li>
</ul>
<hr>
<h2 id="网络有几层，每层有哪些协议"><a href="#网络有几层，每层有哪些协议" class="headerlink" title="网络有几层，每层有哪些协议"></a>网络有几层，每层有哪些协议</h2><ul>
<li>OSI分层（7层）：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层。</li>
<li>TCP/IP分层（4层）：网络接口层、网际层、运输层、应用层。</li>
<li>五层协议（5层）：物理层、数据链路层、网络层、运输层、应用层。<br>tcp,udp在运输层<br>http,ftp 在应用层<br>ip在网络层<h2 id="UDP-TCP-的区别，什么时候用哪个-哪个是可靠的？"><a href="#UDP-TCP-的区别，什么时候用哪个-哪个是可靠的？" class="headerlink" title="UDP TCP 的区别，什么时候用哪个,哪个是可靠的？"></a>UDP TCP 的区别，什么时候用哪个,哪个是可靠的？</h2></li>
<li>1、TCP面向连接;UDP是无连接的，即发送数据之前不需要建立连接</li>
<li>2、TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达（ack）;UDP尽最大努力交付，即不保证可靠交付</li>
<li>3、TCP面向字节流，实际上是TCP把数据看成一连串无结构的字节流;UDP是面向报文的<br>UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如IP电话，实时视频会议等）</li>
<li>4、每一条TCP连接只能是点到点的;UDP支持一对一，一对多，多对一和多对多的交互通信</li>
<li>5、TCP首部开销20字节;UDP的首部开销小，只有8个字节</li>
<li>6、TCP的逻辑通信信道是全双工的可靠信道，UDP则是不可靠信道</li>
</ul>
<h2 id="http-中get和post的区别"><a href="#http-中get和post的区别" class="headerlink" title="http 中get和post的区别"></a>http 中get和post的区别</h2><ul>
<li>GET：一般用来获取数据  ，POST：一般用来修改数据</li>
<li>发送值：<br>　<em> geturl参数可见。
　</em> post是通过HTTP post机制，将数据放到 头传过去</li>
<li>长度限制：<ul>
<li>大部分浏览器对GET url有长度限制2k</li>
<li>post传送的数据量较大，一般被默认为不受限制。80KB-100KB。</li>
</ul>
</li>
<li>缓存:<ul>
<li>GET 请求默认在ajax环境下是会被缓存的 ，这样就会减轻服务器端的压力。<ul>
<li>但是post请求是不会被缓存的。</li>
</ul>
</li>
</ul>
</li>
<li>GET/POST使用场景有区别<ul>
<li>用get:<br>请求中的URL可以被手动输入<br>请求中的URL可以被存在书签里，或者历史里，或者快速拨号里面，或者分享给别人。<br>请求中的URL可以被缓存。GET 请求默认在ajax环境下是会被缓存的 ，这样就会减轻服务器端的压力。但是post请求是不会被缓存的。<br> 用GET： 可以重复的交互，比如取个数据，跳个页面</li>
<li>post:<br>表单数据，数据库内添加新的数据行，用POST, 因为POST不能被缓存，所以浏览器不会多次提交。</li>
</ul>
</li>
<li>延伸<br>http:get 获取数据 post:修改数据 put:增加数据 delete：删除数据<h2 id="为什么get方式有限制是2kb-，出于什么原因？"><a href="#为什么get方式有限制是2kb-，出于什么原因？" class="headerlink" title="为什么get方式有限制是2kb.，出于什么原因？"></a>为什么get方式有限制是2kb.，出于什么原因？</h2></li>
<li>不同<strong>的</strong>浏览器对于URL是有限制<strong>的</strong>，比如IE浏览器对于URL<strong>的</strong>限制为<strong>2KB</strong>，而Chrome，FireFox浏览器理论上对于URL是没有限制<strong>的</strong>，它真正<strong>的</strong>限制取决于操作系统本身</li>
<li>服务器最多处理64K大小的url。超过的部分，恕不处理。<h2 id="知道post请求发几个包？，知道某个名词吗"><a href="#知道post请求发几个包？，知道某个名词吗" class="headerlink" title="知道post请求发几个包？，知道某个名词吗?"></a>知道post请求发几个包？，知道某个名词吗?</h2>GET和POST还有一个重大区别是：GET产生一个TCP数据包，而POST产生两个TCP数据包(但又不是绝对)</li>
<li><p>1、对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200(返回数据);</p>
</li>
<li><p>2、而对于POST，浏览器先发送header，服务器响应100(客户端应当继续发送请求) continue，浏览器再发送data，服务器响应200 ok(返回数据)。</p>
</li>
<li><p>3、也就是说，GET只需要汽车跑一趟就把货送到了，而POST得跑两趟，第一趟，先去和服务器打个招呼“嗨，我等下要送一批货来，你们打开门迎接我”，然后再回头把货送过去。</p>
</li>
<li>4、因为POST需要两步，时间上消耗的要多一点，看起来GET比POST更有效。因此Yahoo团队有推荐用GET替换POST来优化网站性能。但这是一个坑!跳入需谨慎。为什么?</li>
<li>6、 据研究，在网络环境好的情况下，发一次包的时间和发两次包的时间差别基本可以无视。而在网络环境差的情况下，两次包的TCP在验证数据包完整性上，有非常大的优点。</li>
<li>7、但并不是所有浏览器都会在POST中发送两次包，Firefox就只发送一次。<h2 id="握手挥手"><a href="#握手挥手" class="headerlink" title="握手挥手"></a>握手挥手</h2><h3 id="握手"><a href="#握手" class="headerlink" title="握手"></a>握手</h3>三次握手过程：<br>客户端向服务器发送一个SYN（包含了SYN，SEQ）。<br>当服务器会向客户端发送一个SYN+ACK的数据包<br>当客户端向服务器发送ACK的数据包，此时ACK数据包中的ack值等于上一次SYN中的seq+syn。<br>如果某个阶段莫名中断，TCP会再次以相同的顺序发送相同的数据包。<h4 id="三次握手的目的："><a href="#三次握手的目的：" class="headerlink" title="三次握手的目的："></a>三次握手的目的：</h4>防止已过期的连接请求报文突然又传送到服务器，因而产生错误。<h3 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h3>第一次挥手：主动关闭方A发送一个FIN，用来A到被动关闭方B对的数据传送，也就是A不再给B发数据了，但是A还可以接收数据</li>
</ul>
<p>第二次挥手：B收到FIN包后，发一个ACK给对方，确认序号为收到序号+1。（一个FIN占用一个序号）</p>
<p>第三次挥手：B发送一个FIN，用来关闭B到A的数据传送</p>
<p>第四次挥手：A收到FIN后，发送一个ACK给B，确认序号为收到序号+1。完成四次挥手。</p>
<h2 id="为什么挥手比握手多了一个次？"><a href="#为什么挥手比握手多了一个次？" class="headerlink" title="为什么挥手比握手多了一个次？"></a>为什么挥手比握手多了一个次？</h2><p>但关闭连接时，当收到对方的FIN报文通知时，它仅仅表示对方没有数据发送给你了；但未必你所有的数据都全部发送给对方了，所以它这里的ACK报文和FIN报文分开发送的。</p>
<h2 id="http的缓存机制（cookie）"><a href="#http的缓存机制（cookie）" class="headerlink" title="http的缓存机制（cookie）"></a>http的缓存机制（cookie）</h2><p><a href="http://www.jianshu.com/p/0c31b58dbccb">http://www.jianshu.com/p/0c31b58dbccb</a><br><a href="https://segmentfault.com/a/1190000010775131">https://segmentfault.com/a/1190000010775131</a></p>
<p><img src="http://upload-images.jianshu.io/upload_images/2377897-3e3258c0ab144bfd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/2377897-870aaa08f5c962a7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<hr>
<h2 id="http请求是有状态的嘛？websocket区别"><a href="#http请求是有状态的嘛？websocket区别" class="headerlink" title="http请求是有状态的嘛？websocket区别"></a>http请求是有状态的嘛？websocket区别</h2><h3 id="http"><a href="#http" class="headerlink" title="http"></a>http</h3><ul>
<li>http基于tcp</li>
<li>http为非状态协议，每次发送数据都要重新请求连接</li>
<li>被动性：服务器不能主动发送请求，只能等待响应<h3 id="websocket"><a href="#websocket" class="headerlink" title="websocket"></a>websocket</h3><ul>
<li>基于tcp,为了实现实时 通信而产生的。</li>
<li>特点：<ul>
<li>服务器可以主动发送请求</li>
<li>节约带宽</li>
<li>持久连接<h2 id="Http与https"><a href="#Http与https" class="headerlink" title="Http与https"></a>Http与https</h2>HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全。<br>HTTPS和HTTP的区别主要如下：</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>　　1、https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用。</p>
<p>　　2、http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。</p>
<p>　　3、http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。</p>
<p>　　4、http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。</p>
<hr>
<h2 id="HTTP请求报文与响应报文格式"><a href="#HTTP请求报文与响应报文格式" class="headerlink" title="HTTP请求报文与响应报文格式"></a>HTTP请求报文与响应报文格式</h2><h3 id="请求报文包含三部分："><a href="#请求报文包含三部分：" class="headerlink" title="请求报文包含三部分："></a>请求报文包含三部分：</h3><p>a、请求行：包含请求方法、URI、HTTP版本信息<br>b、请求首部字段<br>c、请求内容实体</p>
<h3 id="响应报文包含三部分："><a href="#响应报文包含三部分：" class="headerlink" title="响应报文包含三部分："></a>响应报文包含三部分：</h3><p>a、状态行：包含HTTP版本、状态码、状态码的原因短语<br>b、响应首部字段<br>c、响应内容实体</p>
<hr>
<h2 id="常见HTTP首部字段"><a href="#常见HTTP首部字段" class="headerlink" title="常见HTTP首部字段"></a>常见HTTP首部字段</h2><p>###　a、通用首部字段（请求报文与响应报文都会使用的首部字段）<br>Date：创建报文时间<br>Connection：连接的管理<br>Cache-Control：缓存的控制<br>Transfer-Encoding：报文主体的传输编码方式</p>
<h3 id="b、请求首部字段（请求报文会使用的首部字段）"><a href="#b、请求首部字段（请求报文会使用的首部字段）" class="headerlink" title="b、请求首部字段（请求报文会使用的首部字段）"></a>b、请求首部字段（请求报文会使用的首部字段）</h3><p>Host：请求资源所在服务器<br>Accept：可处理的媒体类型<br>Accept-Charset：可接收的字符集<br>Accept-Encoding：可接受的内容编码<br>Accept-Language：可接受的自然语言</p>
<h3 id="c、响应首部字段（响应报文会使用的首部字段）"><a href="#c、响应首部字段（响应报文会使用的首部字段）" class="headerlink" title="c、响应首部字段（响应报文会使用的首部字段）"></a>c、响应首部字段（响应报文会使用的首部字段）</h3><p>Accept-Ranges：可接受的字节范围<br>Location：令客户端重新定向到的URI<br>Server：HTTP服务器的安装信息</p>
<h3 id="d、实体首部字段（请求报文与响应报文的的实体部分使用的首部字段）"><a href="#d、实体首部字段（请求报文与响应报文的的实体部分使用的首部字段）" class="headerlink" title="d、实体首部字段（请求报文与响应报文的的实体部分使用的首部字段）"></a>d、实体首部字段（请求报文与响应报文的的实体部分使用的首部字段）</h3><p>Allow：资源可支持的HTTP方法<br>Content-Type：实体主类的类型<br>Content-Encoding：实体主体适用的编码方式<br>Content-Language：实体主体的自然语言<br>Content-Length：实体主体的的字节数<br>Content-Range：实体主体的位置范围，一般用于发出部分请求时使用</p>
<hr>
<h3 id="Http状态码-常用的"><a href="#Http状态码-常用的" class="headerlink" title="Http状态码 常用的"></a>Http状态码 常用的</h3><p>成功的状态码：<br>200 – 服务器成功返回网页<br>304 – 未修改<br>失败的状态码：<br>404 – 请求的网页不存在<br>503 – 服务器暂时不可用<br>500 – 服务器内部错误  </p>
<h2 id="http状态码有那些？分别代表是什么意思？"><a href="#http状态码有那些？分别代表是什么意思？" class="headerlink" title="http状态码有那些？分别代表是什么意思？"></a>http状态码有那些？分别代表是什么意思？</h2><h3 id="简单版"><a href="#简单版" class="headerlink" title="简单版"></a>简单版</h3><pre><code>[
    100  Continue    继续，一般在发送post请求时，已发送了http header之后服务端将返回此信息，表示确认，之后发送具体参数信息
    200  OK         正常返回信息
    201  Created      请求成功并且服务器创建了新的资源
    202  Accepted     服务器已接受请求，但尚未处理
    301  Moved Permanently  请求的网页已永久移动到新位置。
    302 Found          临时性重定向。
    303 See Other      临时性重定向，且总是使用 GET 请求新的 URI。
    304  Not Modified 自从上次请求后，请求的网页未修改过。

    400 Bad Request  服务器无法理解请求的格式，客户端不应当尝试再次使用相同的内容发起请求。
    401 Unauthorized 请求未授权。
    403 Forbidden      禁止访问。
    404 Not Found      找不到如何与 URI 相匹配的资源。

    500 Internal Server Error  最常见的服务器端错误。
    503 Service Unavailable 服务器端暂时无法处理请求（可能是过载或维护）。
]
</code></pre><h3 id="完整版"><a href="#完整版" class="headerlink" title="完整版"></a>完整版</h3><h4 id="1-信息类-：表示接收到请求并且继续处理"><a href="#1-信息类-：表示接收到请求并且继续处理" class="headerlink" title="1**(信息类)：表示接收到请求并且继续处理"></a>1**(信息类)：表示接收到请求并且继续处理</h4><pre><code>100——客户必须继续发出请求
101——客户要求服务器根据请求转换HTTP协议版本
</code></pre><h4 id="2-响应成功-：表示动作被成功接收、理解和接受"><a href="#2-响应成功-：表示动作被成功接收、理解和接受" class="headerlink" title="2**(响应成功)：表示动作被成功接收、理解和接受"></a>2**(响应成功)：表示动作被成功接收、理解和接受</h4><pre><code>200——表明该请求被成功地完成，所请求的资源发送回客户端
201——提示知道新文件的URL
202——接受和处理、但处理未完成
203——返回信息不确定或不完整
204——请求收到，但返回信息为空
205——服务器完成了请求，用户代理必须复位当前已经浏览过的文件
206——服务器已经完成了部分用户的GET请求
</code></pre><h4 id="3-重定向类-：为了完成指定的动作，必须接受进一步处理"><a href="#3-重定向类-：为了完成指定的动作，必须接受进一步处理" class="headerlink" title="3**(重定向类)：为了完成指定的动作，必须接受进一步处理"></a>3**(重定向类)：为了完成指定的动作，必须接受进一步处理</h4><pre><code>300——请求的资源可在多处得到
301——本网页被永久性转移到另一个URL
302——请求的网页被转移到一个新的地址，但客户访问仍继续通过原始URL地址，重定向，新的URL会在response中的Location中返回，浏览器将会使用新的URL发出新的Request。
303——建议客户访问其他URL或访问方式
304——自从上次请求后，请求的网页未修改过，服务器返回此响应时，不会返回网页内容，代表上次的文档已经被缓存了，还可以继续使用
305——请求的资源必须从服务器指定的地址得到
306——前一版本HTTP中使用的代码，现行版本中不再使用
307——申明请求的资源临时性删除
</code></pre><h4 id="4-客户端错误类-：请求包含错误语法或不能正确执行"><a href="#4-客户端错误类-：请求包含错误语法或不能正确执行" class="headerlink" title="4**(客户端错误类)：请求包含错误语法或不能正确执行"></a>4**(客户端错误类)：请求包含错误语法或不能正确执行</h4><pre><code>400——客户端请求有语法错误，不能被服务器所理解
401——请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用
HTTP 401.1 - 未授权：登录失败
　　HTTP 401.2 - 未授权：服务器配置问题导致登录失败
　　HTTP 401.3 - ACL 禁止访问资源
　　HTTP 401.4 - 未授权：授权被筛选器拒绝
HTTP 401.5 - 未授权：ISAPI 或 CGI 授权失败
402——保留有效ChargeTo头响应
403——禁止访问，服务器收到请求，但是拒绝提供服务
HTTP 403.1 禁止访问：禁止可执行访问
　　HTTP 403.2 - 禁止访问：禁止读访问
　　HTTP 403.3 - 禁止访问：禁止写访问
　　HTTP 403.4 - 禁止访问：要求 SSL
　　HTTP 403.5 - 禁止访问：要求 SSL 128
　　HTTP 403.6 - 禁止访问：IP 地址被拒绝
　　HTTP 403.7 - 禁止访问：要求客户证书
　　HTTP 403.8 - 禁止访问：禁止站点访问
　　HTTP 403.9 - 禁止访问：连接的用户过多
　　HTTP 403.10 - 禁止访问：配置无效
　　HTTP 403.11 - 禁止访问：密码更改
　　HTTP 403.12 - 禁止访问：映射器拒绝访问
　　HTTP 403.13 - 禁止访问：客户证书已被吊销
　　HTTP 403.15 - 禁止访问：客户访问许可过多
　　HTTP 403.16 - 禁止访问：客户证书不可信或者无效
HTTP 403.17 - 禁止访问：客户证书已经到期或者尚未生效
404——一个404错误表明可连接服务器，但服务器无法取得所请求的网页，请求资源不存在。eg：输入了错误的URL
405——用户在Request-Line字段定义的方法不允许
406——根据用户发送的Accept拖，请求资源不可访问
407——类似401，用户必须首先在代理服务器上得到授权
408——客户端没有在用户指定的饿时间内完成请求
409——对当前资源状态，请求不能完成
410——服务器上不再有此资源且无进一步的参考地址
411——服务器拒绝用户定义的Content-Length属性请求
412——一个或多个请求头字段在当前请求中错误
413——请求的资源大于服务器允许的大小
414——请求的资源URL长于服务器允许的长度
415——请求资源不支持请求项目格式
416——请求中包含Range请求头字段，在当前请求资源范围内没有range指示值，请求也不包含If-Range请求头字段
417——服务器不满足请求Expect头字段指定的期望值，如果是代理服务器，可能是下一级服务器不能满足请求长。
</code></pre><h4 id="5-服务端错误类-：服务器不能正确执行一个正确的请求"><a href="#5-服务端错误类-：服务器不能正确执行一个正确的请求" class="headerlink" title="5**(服务端错误类)：服务器不能正确执行一个正确的请求"></a>5**(服务端错误类)：服务器不能正确执行一个正确的请求</h4><pre><code>  HTTP 500 - 服务器遇到错误，无法完成请求
  　　HTTP 500.100 - 内部服务器错误 - ASP 错误
  　　HTTP 500-11 服务器关闭
  　　HTTP 500-12 应用程序重新启动
  　　HTTP 500-13 - 服务器太忙
  　　HTTP 500-14 - 应用程序无效
  　　HTTP 500-15 - 不允许请求 global.asa
  　　Error 501 - 未实现
HTTP 502 - 网关错误
HTTP 503：由于超载或停机维护，服务器目前无法使用，一段时间后可能恢复正常
</code></pre><hr>
<h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><h2 id="什么是事务？"><a href="#什么是事务？" class="headerlink" title="什么是事务？"></a>什么是事务？</h2><ul>
<li>事务就是被绑定在一起作为一个逻辑工作单元的SQL语句分组，如果任何一个语句操作失败那么整个操作就被失败，以后操作就会回滚到操作前状态，或者是上有个节点。为了确保要么执行，要么不执行，就可以使用事务。要将有组语句作为事务考虑，就需要通过ACID测试，即原子性，一致性，隔离性和持久性。<h2 id="数据库有哪几种事务"><a href="#数据库有哪几种事务" class="headerlink" title="数据库有哪几种事务"></a>数据库有哪几种事务</h2><h2 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h2>答：视图是一种虚拟的表，具有和物理表相同的功能。可以对视图进行增，改，查，操作，视图通常是有一个表或者多个表的行或列的子集。对视图的修改不影响基本表。它使得我们获取数据更容易，相比多表查询<h2 id="mysql的left-join，inner-join，right-join"><a href="#mysql的left-join，inner-join，right-join" class="headerlink" title="mysql的left join，inner join，right join;"></a>mysql的left join，inner join，right join;</h2></li>
<li>Inner Join:内连接是最常见的一种连接，只连接匹配的行。它又分为等值连接（连接条件运算符为”=”）和不等值连接（连接条件运算符不为”=”，例如between…and）。</li>
<li>Outer Join：它除了显示符合连接条件的记录以外，还会显示所有左表中的记录（右外连接就是所有右表中的记录）<ul>
<li>A FULL OUTER JOIN B：产生A和B的并集<br>*A Left Outer Join B：产生表A的完全集，而B表中匹配的则有值，没有匹配的则以null值取代。</li>
<li>A Right Outer Join B：是后面的表为基础<h2 id="mysql的索引"><a href="#mysql的索引" class="headerlink" title="mysql的索引;"></a>mysql的索引;</h2><h2 id="索引的作用？和它的优点缺点是什么？"><a href="#索引的作用？和它的优点缺点是什么？" class="headerlink" title="索引的作用？和它的优点缺点是什么？"></a>索引的作用？和它的优点缺点是什么？</h2>答：索引就一种特殊的查询表，数据库的搜索引擎可以利用它加速对数据的检索。它很类似与现实生活中书的目录，不需要查询整本书内容就可以找到想要的数据。索引可以是唯一的，创建索引允许指定单个列或者是多个列。缺点是它减慢了数据录入的速度，同时也增加了数据库的尺寸大小。<h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><h2 id="进程和线程有什么区别？"><a href="#进程和线程有什么区别？" class="headerlink" title="进程和线程有什么区别？"></a>进程和线程有什么区别？</h2></li>
</ul>
</li>
<li>进程和线程都是CPU工作时间段的描述。</li>
<li>进程是cpu资源分配的最小单位，线程是cpu调度的最小单位</li>
<li>线程的划分尺度小于进程，使得多线程程序的并发性高。</li>
<li>线程执行开销小，但不利于资源的管理和保护；</li>
<li>一个进程可以有多个线程</li>
<li>进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路径。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个线程死掉就等于整个进程死掉，所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要差一些.<h2 id="什么是死锁，死锁产生的4个条件"><a href="#什么是死锁，死锁产生的4个条件" class="headerlink" title="什么是死锁，死锁产生的4个条件"></a>什么是死锁，死锁产生的4个条件</h2><h3 id="死锁定义："><a href="#死锁定义：" class="headerlink" title="死锁定义："></a>死锁定义：</h3>　在两个或多个并发进程中，如果每个进程持有某种资源而又都等待别的进程释放它或它们现在保持着的资源，在未改变这种状态之前都不能向前推进，称这一组进程产生了死锁。通俗地讲，就是两个或多个进程被无限期地阻塞、相互等待的一种状态。<h3 id="产生条件："><a href="#产生条件：" class="headerlink" title="产生条件："></a>产生条件：</h3></li>
<li>1：互斥条件        – 一个资源一次只能被一个进程使用</li>
<li>2：请求保持条件 – 一个进程因请求资源而阻塞时，对已经获得资源保持不放 </li>
<li>3：不可抢占条件 – 进程已获得的资源在未使用完之前不能强行剥夺</li>
<li>4：循环等待条件 – 若干进程之间形成一种头尾相接的循环等待资源的关系</li>
</ul>
<h2 id="预防避免死锁的方法"><a href="#预防避免死锁的方法" class="headerlink" title="预防避免死锁的方法"></a>预防避免死锁的方法</h2><ul>
<li>1：破坏“请求和保持”条件：规定所有进程在开始运行之前，都必须一次性的申请其在整个运行过程所需要的全部资源。<ul>
<li>优点：简单，安全。 <ul>
<li>缺点：资源严重浪费，恶化了系统的利用率；</li>
</ul>
</li>
</ul>
</li>
<li>2：破坏“不剥夺”条件：进程逐个的提出资源请求，当一个已经保持了某些资源的进程，再提出新的资源请求而不能立即得到满足时，必须释放它已经保持了的所有资源，待以后需要时再重新申请。<ul>
<li>缺点：实现复杂，代价大，反复地申请和释放资源，而使进程的执行无限的推迟、延长了进程的周转时间增加系统开销、降低系统吞吐量。</li>
</ul>
</li>
<li>3：破坏“环路等待”条件：将所有的资源按类型进行线性排队，并赋予不同的序号。所有进程请求资源必须按照资源递增的次序提出，防止出现环路。 <ul>
<li>缺点：<ul>
<li>1、序号必须相对稳定，限制了新设备类型的增加</li>
<li>2、作业（进程）使用资源顺序和系统规定的顺序不同而造成资源的浪费</li>
<li>3、限制了用户编程 </li>
</ul>
</li>
</ul>
</li>
</ul>
<p>　　注意：由于互斥条件是非共享设备所必需的，不能改变</p>
<hr>
<h1 id="JQUERY"><a href="#JQUERY" class="headerlink" title="JQUERY"></a>JQUERY</h1><h2 id="1-你在公司是怎么用jquery的？"><a href="#1-你在公司是怎么用jquery的？" class="headerlink" title="1 你在公司是怎么用jquery的？"></a>1 你在公司是怎么用jquery的？</h2><p>答：在项目中是怎么用的是看看你有没有项目经验(根据自己的实际情况来回答) 你用过的选择器啊，复选框啊，表单啊，ajax啊，事件等配置<a href="http://lib.csdn.net/base/jquery">jQuery</a>环境 下载jquery类库 在jsp页面引用jquery类库即可</p>
<p><script type="text/[JavaScript](http://lib.csdn.net/base/javascript)" src="jquery/jquery-1.7.2.min.js"/>接下来通过在<script> $(function(){ }); </script></p>
<h2 id="2-你为什么要使用jquery？"><a href="#2-你为什么要使用jquery？" class="headerlink" title="2 你为什么要使用jquery？"></a>2 你为什么要使用jquery？</h2><p>答：因为jQuery是轻量级的框架，大小不到30kb,它有强大的选择器，出色的DOM操作的封装，有可靠的事件处理机制(jQuery在处理事件绑定的时候相当的可靠)，完善的ajax(它的ajax封装的非常的好，不需要考虑复杂浏览器的兼容性和XMLHttpRequest对象的创建和使用的问题。) 出色的浏览器的兼容性。 而且支持链式操作，隐式迭代。行为层和结构层的分离，还支持丰富的插件，jquery的文档也非常的丰富。</p>
<h2 id="3-你觉得jquery有哪些好处？-答案同上"><a href="#3-你觉得jquery有哪些好处？-答案同上" class="headerlink" title="3 你觉得jquery有哪些好处？ 答案同上"></a>3 你觉得jquery有哪些好处？ 答案同上</h2><h2 id="4-你使用jquery遇到过哪些问题，你是怎么解决的？"><a href="#4-你使用jquery遇到过哪些问题，你是怎么解决的？" class="headerlink" title="4 你使用jquery遇到过哪些问题，你是怎么解决的？"></a>4 你使用jquery遇到过哪些问题，你是怎么解决的？</h2><p>答：这个答案是开发的，看你是否有相关的项目经验。例前台拿不到值，JSON 可是出现的错误(多了一个空格等)这编译是不会报错的 jquery库与其他库冲突：1&gt;如果其他库在jquery库之前导入的话1.我们可以通过jquery.noconflict()将变量的$的控制权过度给其他库2.自定义快捷键,用一个变量接住jquery.noconflict()3.通过函数传参2&gt;如果jquery库在其他库之前导入就直接使用jquery今天在处理一个数据问题时，发现jQuery.ajax()方法返回的值一直有问题，清除缓存后数据无误，多次<a href="http://lib.csdn.net/base/softwaretest" target="_blank" rel="external">测试</a>后发现返回的值都是之前的值，并且一直未执行url(后台为<a href="http://lib.csdn.net/base/javase" target="_blank" rel="external">Java</a>，设置断点一直未进入)。在网上查找下,发现是未设置type的原因。 如果没设置jQuery.ajax的type=”Post”，那么ajax就会默认type=”Get”，这就会导致之前数据被缓存起来。加上type=”Post”，问题解决！</p>
<h2 id="5-你知道jquery中的选择器吗，请讲一下有哪些选择器？"><a href="#5-你知道jquery中的选择器吗，请讲一下有哪些选择器？" class="headerlink" title="5 你知道jquery中的选择器吗，请讲一下有哪些选择器？"></a>5 你知道jquery中的选择器吗，请讲一下有哪些选择器？</h2><p>答 ：jQuery中的选择器大致分为:基本选择器，层次选择器，过滤选择器，表单选择器</p>
<h2 id="6-jquery中的选择器-和-css中的选择器有区别吗？"><a href="#6-jquery中的选择器-和-css中的选择器有区别吗？" class="headerlink" title="6 jquery中的选择器 和 css中的选择器有区别吗？"></a>6 jquery中的选择器 和 css中的选择器有区别吗？</h2><p>答：jQuery选择器支持CSS里的选择器，jQuery选择器可用来添加样式和添加相应的行为CSS 中的选择器是只能添加相应的样式</p>
<h2 id="7-你觉得jquery中的选择器有什么优势？"><a href="#7-你觉得jquery中的选择器有什么优势？" class="headerlink" title="7 你觉得jquery中的选择器有什么优势？"></a>7 你觉得jquery中的选择器有什么优势？</h2><p>答：简单的写法 $(‘ID’) 来代替 document.getElementById()函数支持CSS1 到<a href="http://lib.csdn.net/base/css3" target="_blank" rel="external">CSS3</a> 选择器完善的处理机制(就算写错了id也不会报错)</p>
<h2 id="8-你在使用选择器的时候有有没有什么觉得要注意的地方？"><a href="#8-你在使用选择器的时候有有没有什么觉得要注意的地方？" class="headerlink" title="8 你在使用选择器的时候有有没有什么觉得要注意的地方？"></a>8 你在使用选择器的时候有有没有什么觉得要注意的地方？</h2><p>答: 1 选择器中含有”.”,”#”,”[“ 等特殊字符的时候需要进行转译2 属性选择器的引号问题3 选择器中含有空格的注意事项</p>
<h2 id="9-jquery对象和dom对象是怎样转换的？"><a href="#9-jquery对象和dom对象是怎样转换的？" class="headerlink" title="9 jquery对象和dom对象是怎样转换的？"></a>9 jquery对象和dom对象是怎样转换的？</h2><p>答 ：jquery转DOM对象:jQuery 对象是一个数组对象，可以通过[index]的丰富得到相应的DOM对象还可以通过get[index]去得到相应的DOM对象。DOM对象转jQuery对象:$(DOM对象)</p>
<h2 id="10-你是如何使用jquery中的ajax的？"><a href="#10-你是如何使用jquery中的ajax的？" class="headerlink" title="10 你是如何使用jquery中的ajax的？"></a>10 你是如何使用jquery中的ajax的？</h2><p>答: 如果是一些常规的ajax程序的话，使用load(),$.get(),$.post(),就可以搞定了，一般我会使用的是$.post() 方法。如果需要设定beforeSend(提交前回调函数),error(失败后处理),success(成功后处理)及complete(请求完成后处理)回调函数等，这个时候我会使用$.ajax()</p>
<h2 id="11-你觉得jquery中的ajax好用吗，为什么？"><a href="#11-你觉得jquery中的ajax好用吗，为什么？" class="headerlink" title="11 你觉得jquery中的ajax好用吗，为什么？"></a>11 你觉得jquery中的ajax好用吗，为什么？</h2><p>答: 好用的。 因为jQuery提供了一些日常开发中夙瑶的快捷操作，例 load，ajax，get，post等等，所以使用jQuery开发ajax将变得极其简单，我们就可以集中精力在业务和用户的体验上，不需要去理会那些繁琐的XMLHttpRequest对象了。</p>
<h2 id="12-jquery中-get-提交和-post-提交有区别吗？"><a href="#12-jquery中-get-提交和-post-提交有区别吗？" class="headerlink" title="12 jquery中$.get()提交和$.post()提交有区别吗？"></a>12 jquery中$.get()提交和$.post()提交有区别吗？</h2><p>答: 1 $.get() 方法使用GET方法来进行异步请求的。$.post() 方法使用POST方法来进行异步请求的。2 get请求会将参数跟在URL后进行传递，而POST请求则是作为HTTP消息的实体内容发送给Web服务器的，这种传递是对用户不可见的。3 get方式传输的数据大小不能超过2KB 而POST要大的多4 GET 方式请求的数据会被浏览器缓存起来，因此有安全问题。</p>
<h2 id="13-jquery中的load方法一般怎么用的？"><a href="#13-jquery中的load方法一般怎么用的？" class="headerlink" title="13 jquery中的load方法一般怎么用的？"></a>13 jquery中的load方法一般怎么用的？</h2><p>答：load方法一般在 载入远程HTML 代码并插入到DOM中的时候用，通常用来从Web服务器上获取静态的数据文件。如果要传递参数的话，可以使用$.get() 或 $.post()。</p>
<h2 id="14-在jquery中你是如何去操作样式的？"><a href="#14-在jquery中你是如何去操作样式的？" class="headerlink" title="14 在jquery中你是如何去操作样式的？"></a>14 在jquery中你是如何去操作样式的？</h2><p>答: addClass() 来追加样式 ，removeClass() 来删除样式，toggle() 来切换样式</p>
<h2 id="15-简单的讲叙一下jquery是怎么处理事件的，你用过哪些事件？"><a href="#15-简单的讲叙一下jquery是怎么处理事件的，你用过哪些事件？" class="headerlink" title="15 简单的讲叙一下jquery是怎么处理事件的，你用过哪些事件？"></a>15 简单的讲叙一下jquery是怎么处理事件的，你用过哪些事件？</h2><p>答: 首先去装载文档，在页面家在完毕后，浏览器会通过javascript 为DOM元素添加事件。</p>
<h2 id="16-你使用过jquery中的动画吗，是怎样用的？"><a href="#16-你使用过jquery中的动画吗，是怎样用的？" class="headerlink" title="16 你使用过jquery中的动画吗，是怎样用的？"></a>16 你使用过jquery中的动画吗，是怎样用的？</h2><p>答:使用过。hide() 和 show() 同时修改多个样式属性。像高度，宽度，不透明度。 fadeIn() 和fadeOut() fadeTo() 只改变不透明度slideUp() 和 slideDown() slideToggle() 只改变高度animate() 属于自定义动画的方法.</p>
<h2 id="17-你使用过jquery中的插件吗？-答-看个人的实力和经验来回答了。"><a href="#17-你使用过jquery中的插件吗？-答-看个人的实力和经验来回答了。" class="headerlink" title="17 你使用过jquery中的插件吗？ 答:看个人的实力和经验来回答了。"></a>17 你使用过jquery中的插件吗？ 答:看个人的实力和经验来回答了。</h2><h2 id="18-你一般用什么去提交数据，为什么？"><a href="#18-你一般用什么去提交数据，为什么？" class="headerlink" title="18 你一般用什么去提交数据，为什么？"></a>18 你一般用什么去提交数据，为什么？</h2><p>答:一般我会使用的是$.post() 方法。如果需要设定beforeSend(提交前回调函数),error(失败后处理),success(成功后处理及complete(请求完成后处理)回调函数等，这个时候我会使用$.ajax()</p>
<h2 id="19-在jquery中引入css有几种方式？"><a href="#19-在jquery中引入css有几种方式？" class="headerlink" title="19 在jquery中引入css有几种方式？"></a>19 在jquery中引入css有几种方式？</h2><p>答:四种 行内式，内嵌式，导入式，链接式</p>
<h2 id="20-你在jquery中使用过哪些插入节点的方法，它们的区别是什么？"><a href="#20-你在jquery中使用过哪些插入节点的方法，它们的区别是什么？" class="headerlink" title="20 你在jquery中使用过哪些插入节点的方法，它们的区别是什么？"></a>20 你在jquery中使用过哪些插入节点的方法，它们的区别是什么？</h2><p>答:append(),appendTo(),prepend(),prependTo(),after(),insertAfter()，before(),insertBefore() 大致可以分为 内部追加和外部追加append() 表式向每个元素内部追加内容。appendTo()表示 讲所有的元素追加到指定的元素中。例$(A)appendTo(B) 是将A追加到B中下面的方法解释类似。</p>
<h2 id="21-你使用过包裹节点的方法吗，包裹节点有方法有什么好处？"><a href="#21-你使用过包裹节点的方法吗，包裹节点有方法有什么好处？" class="headerlink" title="21 你使用过包裹节点的方法吗，包裹节点有方法有什么好处？"></a>21 你使用过包裹节点的方法吗，包裹节点有方法有什么好处？</h2><p>答: wrapAll(),wrap(), wrapInner() 需要在文档中插入额外的结构化标记的时候可以使用这些包裹的方法应为它不会帛画原始文档的语义</p>
<h2 id="22-jquery中如何来获取或和设置属性？"><a href="#22-jquery中如何来获取或和设置属性？" class="headerlink" title="22 jquery中如何来获取或和设置属性？"></a>22 jquery中如何来获取或和设置属性？</h2><p>jQuery中可以用attr()方法来获取和设置元素属性removeAttr() 方法来删除元素属性</p>
<h2 id="23-如何来设置和获取HTML-和文本的值？"><a href="#23-如何来设置和获取HTML-和文本的值？" class="headerlink" title="23 如何来设置和获取HTML 和文本的值？"></a>23 如何来设置和获取HTML 和文本的值？</h2><p>答：html()方法 类似于innerHTML属性 可以用来读取或者设置某个元素中的HTML内容注意：html() 可以用于xhtml文档 不能用于xml文档text() 类似于innerText属性 可以用来读取或设置某个元素中文本内容。val() 可以用来设置和获取元素的值</p>
<h2 id="24-你jquery中有哪些方法可以遍历节点？"><a href="#24-你jquery中有哪些方法可以遍历节点？" class="headerlink" title="24 你jquery中有哪些方法可以遍历节点？"></a>24 你jquery中有哪些方法可以遍历节点？</h2><p>答 ：children() 取得匹配元素的子元素集合,只考虑子元素不考虑后代元素 next() 取得匹配元素后面紧邻的同辈元素prev() 取得匹配元素前面紧邻的同辈元素siblings() 取得匹配元素前后的所有同辈元素closest() 取得最近的匹配元素find() 取得匹配元素中的元素集合 包括子代和后代</p>
<h2 id="25-子元素选择器-和后代选择器元素有什么区别？"><a href="#25-子元素选择器-和后代选择器元素有什么区别？" class="headerlink" title="25 子元素选择器 和后代选择器元素有什么区别？"></a>25 子元素选择器 和后代选择器元素有什么区别？</h2><p>答:子代元素是找子节点下的所有元素,后代元素是找子节点或子节点的子节点中的元素</p>
<h2 id="26-在jquery中可以替换节点吗？"><a href="#26-在jquery中可以替换节点吗？" class="headerlink" title="26 在jquery中可以替换节点吗？"></a>26 在jquery中可以替换节点吗？</h2><p>答：可以 在jQuery中有两者替换节点的方式 replaceWith() 和 replaceAll()例如在</p><p title="hao are you">hao are you</p>替换成<strong>I am fine</strong>$(‘p’).replaceWith(‘<strong>I am fine</strong>‘); replaceAll 与replaceWith的用法前后调换一下即可。<em>**</em><p></p>
<h2 id="27-你觉得beforeSend方法有什么用？"><a href="#27-你觉得beforeSend方法有什么用？" class="headerlink" title="27 你觉得beforeSend方法有什么用？"></a>27 你觉得beforeSend方法有什么用？</h2><p>答：发送请求前可以修改XMLHttpRequest对象的函数，在beforeSend中如果返回false 可以取消本次的Ajax请求。XMLHttpRequest对象是唯一的参数所以在这个方法里可以做验证</p>
<h2 id="28-siblings-方法-和-‘prev-div’-选择器是一样的嘛？"><a href="#28-siblings-方法-和-‘prev-div’-选择器是一样的嘛？" class="headerlink" title="28 siblings() 方法 和 $(‘prev~div’)选择器是一样的嘛？"></a>28 siblings() 方法 和 $(‘prev~div’)选择器是一样的嘛？</h2><p>答: $(‘prev~div’) 只能选择’#prev’元素后面的同辈<div>元素而siblings()方法与前后的文职无关，只要是同辈节点就都能匹配。</div></p>
<h2 id="29-你在ajax中使用过JSON吗，你是如何用的？"><a href="#29-你在ajax中使用过JSON吗，你是如何用的？" class="headerlink" title="29 你在ajax中使用过JSON吗，你是如何用的？"></a>29 你在ajax中使用过JSON吗，你是如何用的？</h2><p>答:使用过，在$.getJSON() 方法的时候就是。因为 $.getJSON() 就是用于加载JSON文件的</p>
<h2 id="30-有哪些查询节点的选择器？"><a href="#30-有哪些查询节点的选择器？" class="headerlink" title="30 有哪些查询节点的选择器？"></a>30 有哪些查询节点的选择器？</h2><p>答：我在公司使用过 :first 查询第一个，:last 查询最后一个，:odd查询奇数但是索引从0开始:even 查询偶数，:eq(index)查询相等的 ,:gt(index)查询大于index的 ,:lt查询小于index:header 选取所有的标题等</p>
<h2 id="31-nextAll-能-替代-‘prev-siblindgs’-选择器吗？"><a href="#31-nextAll-能-替代-‘prev-siblindgs’-选择器吗？" class="headerlink" title="31 nextAll() 能 替代$(‘prev~siblindgs’)选择器吗？"></a>31 nextAll() 能 替代$(‘prev~siblindgs’)选择器吗？</h2><p>答:能。 使用nextAll() 和使用$(‘prev~siblindgs’) 是一样的</p>
<h2 id="32-jQuery中有几种方法可以来设置和获取样式"><a href="#32-jQuery中有几种方法可以来设置和获取样式" class="headerlink" title="32 jQuery中有几种方法可以来设置和获取样式"></a>32 jQuery中有几种方法可以来设置和获取样式</h2><p>答 ：addClass() 方法，attr() 方法</p>
<h2 id="33-document-ready-方法和window-onload有什么区别？"><a href="#33-document-ready-方法和window-onload有什么区别？" class="headerlink" title="33 $(document).ready()方法和window.onload有什么区别？"></a>33 $(document).ready()方法和window.onload有什么区别？</h2><p>答: 两个方法有相似的功能，但是在实行时机方面是有区别的。 1window.onload方法是在网页中所有的元素(包括元素的所有关联文件)完全加载到浏览器后才执行的。2 $(document).ready() 方法可以在DOM载入就绪时就对其进行操纵，并调用执行绑定的函数。</p>
<h2 id="34-jQuery是如何处理缓存的？"><a href="#34-jQuery是如何处理缓存的？" class="headerlink" title="34 jQuery是如何处理缓存的？"></a>34 jQuery是如何处理缓存的？</h2><p>答 ：要处理缓存就是禁用缓存.1 通过$.post() 方法来获取数据，那么默认就是禁用缓存的。2 通过$.get()方法 来获取数据，可以通过设置时间戳来避免缓存。可以在URL后面加上+(+new Date)例 $.get(‘ajax.xml?’+(+new Date),function () { //内容 }); 3 通过$.ajax 方法来获取数据，只要设置cache:false即可。</p>
<h2 id="35-getScript-方法-和-getJson-方法有什么区别？"><a href="#35-getScript-方法-和-getJson-方法有什么区别？" class="headerlink" title="35 $.getScript()方法 和 $.getJson() 方法有什么区别？"></a>35 $.getScript()方法 和 $.getJson() 方法有什么区别？</h2><p>答: 1 $.getScript() 方法可以直接加载.js文件，并且不需要对javascript文件进行处理，javascript文件会自动执行。2 $.getJson() 是用于加载JSON 文件的 ，用法和$.getScript()</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[ms]]></title>
      <url>http://carryguan.com/2016/06/27/ms/</url>
      <content type="html"><![CDATA[<h1 id="HTML-amp-CSS"><a href="#HTML-amp-CSS" class="headerlink" title="HTML&amp;CSS"></a>HTML&amp;CSS</h1><h2 id="常见的行内元素与块级元素都有哪些，分别举例-，并说一说区别5"><a href="#常见的行内元素与块级元素都有哪些，分别举例-，并说一说区别5" class="headerlink" title="常见的行内元素与块级元素都有哪些，分别举例 ，并说一说区别5%"></a>常见的行内元素与块级元素都有哪些，分别举例 ，并说一说区别5%</h2><ul>
<li>行内元素(inline)：a b span input select strong samll</li>
<li>块级元素(block)：p div ul ol li dl dt dd h1 table form center</li>
<li>行内块级元素(inline-block):img（可以设置宽高，多个元素占一行，可设置所有margin和padding）</li>
<li><p>常见的空元素：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;br/&gt; &lt;hr/&gt;  &lt;link/&gt; &lt;meta/&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>行内元素与块级元素的区别：</li>
<li>行内元素一行占好多个，块级元素独占一行</li>
<li>设置宽度width ,height 无效，可以通过line-height来设置。</li>
<li>设置左右margin/padding有效，上下margin/padding无效</li>
</ul>
</li>
</ul>
<hr>
<h2 id="margin"><a href="#margin" class="headerlink" title="margin"></a>margin</h2><p>margin :上   右   下   左<br>margin: 上  右  下<br>margin : 上下  左右</p>
<h2 id="居中的常见方法-水平，竖直-5"><a href="#居中的常见方法-水平，竖直-5" class="headerlink" title="居中的常见方法(水平，竖直) 5%"></a>居中的常见方法(水平，竖直) 5%</h2><h3 id="1-水平居中"><a href="#1-水平居中" class="headerlink" title="1.水平居中"></a>1.水平居中</h3><ul>
<li>自身宽高，块级元素</li>
<li>margin：0 auto; <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">.box&#123;</span><br><span class="line">    width: 300px;</span><br><span class="line">    height: 300px;</span><br><span class="line">    border: 3px solid red;</span><br><span class="line">&#125;</span><br><span class="line">img&#123;</span><br><span class="line">    display: block;</span><br><span class="line">    width: 100px;</span><br><span class="line">    height: 100px;</span><br><span class="line">    margin: 0 auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="2-水平居中-父元素-text-align：center；"><a href="#2-水平居中-父元素-text-align：center；" class="headerlink" title="2.水平居中 父元素 text-align：center；"></a>2.水平居中 父元素 text-align：center；</h3><p>子元素的display：inline-block；在不受float影响下进行<br>是在父元素上添加：text-align：center；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">.box&#123;</span><br><span class="line">    width: 300px;</span><br><span class="line">    height: 300px;</span><br><span class="line">    border: 3px solid red;</span><br><span class="line">    text-align: center;</span><br><span class="line">&#125;</span><br><span class="line">img&#123;</span><br><span class="line">    display: inline-block;</span><br><span class="line">    width: 100px;</span><br><span class="line">    height: 100px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="水平垂直居中（一）"><a href="#水平垂直居中（一）" class="headerlink" title="水平垂直居中（一）"></a>水平垂直居中（一）</h4><p> 自身宽高,position,left,top ,margin-left,top为自身宽高负值一半<br>(left,top,right,bottom使用要，在position ：relative/absolute)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">img&#123;</span><br><span class="line">    width: 100px;</span><br><span class="line">    height: 150px;</span><br><span class="line">    position: absolute;</span><br><span class="line">    top: 50%;</span><br><span class="line">    left: 50%;</span><br><span class="line">    margin-top: -75px;/*自身 高度的一半 */</span><br><span class="line">    margin-left: -50px;/*自身 宽度的一半 */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="水平垂直居中（三）绝对定位和transfrom"><a href="#水平垂直居中（三）绝对定位和transfrom" class="headerlink" title="水平垂直居中（三）绝对定位和transfrom"></a>水平垂直居中（三）绝对定位和transfrom</h3><p>不需要知道居中元素的宽高<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">img&#123;</span><br><span class="line">        position: absolute;</span><br><span class="line">        top: 50%;</span><br><span class="line">        left: 50%;</span><br><span class="line">        transform: translate(-50%,-50%);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="水平垂直居中（二）"><a href="#水平垂直居中（二）" class="headerlink" title="水平垂直居中（二）"></a>水平垂直居中（二）</h3><p>自身宽高，position,定位上下左右为0，margin:atuo（auto等分其余空间）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">img&#123;</span><br><span class="line">       width: 100px;</span><br><span class="line">       height: 150px;</span><br><span class="line">       position: absolute;</span><br><span class="line">       top: 0;</span><br><span class="line">       left: 0;</span><br><span class="line">       right: 0;</span><br><span class="line">       bottom: 0;</span><br><span class="line">       margin: auto;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="水平垂直居中（四）diplay：table-cell"><a href="#水平垂直居中（四）diplay：table-cell" class="headerlink" title="水平垂直居中（四）diplay：table-cell"></a>水平垂直居中（四）diplay：table-cell</h3><p>其实这个就是把其变成表格样式，再利用表格的样式来进行居中，很方便<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">box&#123;</span><br><span class="line">            width: 300px;</span><br><span class="line">            height: 300px;</span><br><span class="line">            background:#e9dfc7; </span><br><span class="line">            border:1px solid red;</span><br><span class="line"></span><br><span class="line">            display: table-cell;</span><br><span class="line">            vertical-align: middle;</span><br><span class="line">            text-align: center;</span><br><span class="line">        &#125;</span><br><span class="line">        img&#123;</span><br><span class="line">            width: 100px;</span><br><span class="line">            height: 150px;</span><br><span class="line">            /*margin: 0 auto;*/  这个也行</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="水平垂直居中（五）flexBox居中"><a href="#水平垂直居中（五）flexBox居中" class="headerlink" title="水平垂直居中（五）flexBox居中"></a>水平垂直居中（五）flexBox居中</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">.box&#123;</span><br><span class="line">            width: 300px;</span><br><span class="line">            height: 300px;</span><br><span class="line">            background:#e9dfc7; </span><br><span class="line">            border:1px solid red;</span><br><span class="line">            display: flex;</span><br><span class="line">            justify-content: center;</span><br><span class="line">            align-items:center;</span><br><span class="line">        &#125;</span><br><span class="line">        img&#123;</span><br><span class="line">            width: 150px;</span><br><span class="line">            height: 100px;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p><a href="http://www.jianshu.com/p/a7552ce07c88" target="_blank" rel="external">http://www.jianshu.com/p/a7552ce07c88</a></p>
<hr>
<h2 id="常见的垂直居中的方式"><a href="#常见的垂直居中的方式" class="headerlink" title="常见的垂直居中的方式"></a>常见的垂直居中的方式</h2><ul>
<li>vertical-align:middle(table)</li>
<li>translateY(-50%)<br>-webkit-transform: translateY(-50%);</li>
<li>css3 flex<br>不定宽高水平垂直居中<br>align-items:center;//子元素垂直居中<br>justify-content:center;//子元素水平居中<br>display:-webkit-flex;</li>
</ul>
<hr>
<h2 id="如何让几行文本垂直居中？如何让一行文本进行垂直居中？"><a href="#如何让几行文本垂直居中？如何让一行文本进行垂直居中？" class="headerlink" title="如何让几行文本垂直居中？如何让一行文本进行垂直居中？"></a>如何让几行文本垂直居中？如何让一行文本进行垂直居中？</h2><ul>
<li>一行文本垂直居中：height = line-height</li>
<li>多行文本固定高度垂直居中：vertical-align（兼容IE7及IE7）<br>因为想使用vertical-align:middle，就要模拟表格：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">父元素:</span><br><span class="line">display:table</span><br><span class="line">子元素：</span><br><span class="line">display:table-cell</span><br><span class="line">vertical-align:middle;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li>多行文本垂直居中：vertical-align+（兼容IE6以上）<br>在IE6中对父元素进行定位后，如果再对子元素进行百分比计算时，计算的基础似乎是有继承性的（使用百分比计算的基础将不再是该元素的高度，而从父元素继承来的定位高度）。<br>父亲元素的外层： display:table;<br>父亲：top:50%<br>孩子：top:-50%<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">.wrap&#123;  </span><br><span class="line">    display:table;  </span><br><span class="line">    position:relative;  </span><br><span class="line">    overflow:hidden;  </span><br><span class="line">&#125;  </span><br><span class="line">父亲元素</span><br><span class="line">.subwrap&#123;  </span><br><span class="line">    vertical-align:middle;  </span><br><span class="line">    display:table-cell;  </span><br><span class="line">    position:absolute;  </span><br><span class="line">    top:50%;  </span><br><span class="line">&#125;  </span><br><span class="line">子元素 ：</span><br><span class="line">.content&#123;  </span><br><span class="line">    position:relative;  </span><br><span class="line">    top:-50%;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h2 id="flex弹性布局："><a href="#flex弹性布局：" class="headerlink" title="flex弹性布局："></a>flex弹性布局：</h2><ul>
<li>flex布局好处？不需要再给子元素设置定位，使用flex属性就可以让浏览器自己计算位置</li>
<li>父块元素：display: flex;</li>
<li>父行级元素：display: inline-flex;</li>
<li>设置了flex布局后，子元素的float、clear和vertical-align属性就会失效</li>
<li>具体描述：<br>设置了 flex的父亲成为：flex容器，孩子成为flex项目<ul>
<li>父亲容器属性：<ul>
<li>flex-direction(孩子横向还是竖向)：row(孩子水平)| row-reverse | column(孩子竖直) | column-reverse;</li>
<li>flex-wrap(孩子换行)：nowrap | wrap | wrap-reverse;</li>
<li>justify-content（孩子对齐方式）: flex-start | flex-end | center | space-between | space-around;</li>
<li>align-items: stretch|center|flex-start|flex-end|baseline|initial|inherit;</li>
<li>孩子項目屬性：<ul>
<li>order ：属性定义项目的排列顺序。数值越小，排列越靠前，默认为0</li>
<li>flex-grow：设置或检索弹性盒的扩展比率。根据弹性盒子元素所设值作为比率来分配剩余空间。</li>
<li>flex-shrink：属性定义了项目的缩小比例，默认为1，如果没有显示定义该属性，将会自动按照默认值1在所有因子相加之后计算比率来进行空间收缩。</li>
</ul>
</li>
<li>flex-basis：设置或检索弹性盒伸缩基准值，如果所有子元素的基准值之和大于剩余空间，则会根据每项设置的基准值，按比率伸缩剩余空间。<ul>
<li>align-self：属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>【问题】：<br>flex弹性盒模型，主轴有几个方向？后代 flex：1代表什么？</p>
<p>【答案】：</p>
<ul>
<li>flex 是 flex-grow、flex-shrink、flex-basis的缩写。故其取值可以考虑以下情况：</li>
<li>flex 的默认值是 0 1 auto</li>
<li>flex : none，则计算值为 0 0 auto</li>
<li>flex : auto，则计算值为 1 1 auto</li>
<li>flex :非负值，则该数字为 flex-grow 值，flex-shrink 取 1，flex-basis 取 0%</li>
<li>flex 长度或百分比，则视为 flex-basis 值，flex-grow 取 1，flex-shrink 取 1</li>
<li>flex : 非负值　非负值，则分别视为 flex-grow 和 flex-shrink 的值，flex-basis 取 0%，如下是等同的：</li>
</ul>
<hr>
<h2 id="浮动"><a href="#浮动" class="headerlink" title="浮动"></a>浮动</h2><ul>
<li>浮动元素会脱离文档流并向左/向右浮动（不在正常位置，并且他后面的不浮动元素会占他的位置），浮动直到碰到父元素或者另一个浮动元素。</li>
<li>浮动不会影响同级别普通元素的布局，同时也存在盖住普通元素的风险。</li>
<li>clear属性不允许被清除浮动的元素的左边/右边挨着浮动元素，底层原理是在被清除浮动的元素上边或者下边添加足够的清除空间。<br><img src="http://upload-images.jianshu.io/upload_images/2377897-a0f4eff0c7cd5c66.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></li>
</ul>
<h2 id="说一下为什么要清除浮动以及常见的清除浮动的方法-4"><a href="#说一下为什么要清除浮动以及常见的清除浮动的方法-4" class="headerlink" title="说一下为什么要清除浮动以及常见的清除浮动的方法 4%"></a>说一下为什么要清除浮动以及常见的清除浮动的方法 4%</h2><p>当一个内层元素是浮动的时候，如果没有关闭浮动时，其父元素也就不会再包含这个浮动的内层元素，因为此时浮动元素已经脱离了文档流。也就是为什么外层不能被撑开了！<br>（2）：边框不能撑开 （3）：margin ,padding设置值不能正确显示（1）：背景不能显示</p>
<h3 id="方法一：在被清除浮动元素内部末尾添加新元素-、应用-clear：both"><a href="#方法一：在被清除浮动元素内部末尾添加新元素-、应用-clear：both" class="headerlink" title="方法一：在被清除浮动元素内部末尾添加新元素 、应用 clear：both"></a>方法一：在被清除浮动元素内部末尾添加新元素 、应用 clear：both</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">div class=&quot;outer&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;div1&quot;&gt;1&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;div2&quot;&gt;2&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;div3&quot;&gt;3&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;clear&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">.clear&#123;clear:both; height: 0; line-height: 0; font-size: 0&#125;</span><br></pre></td></tr></table></figure>
<h3 id="方法二：触发BFC"><a href="#方法二：触发BFC" class="headerlink" title="方法二：触发BFC"></a>方法二：触发BFC</h3><p>父级div定义 overflow: hidden（hidden可以兼容IE，就是对seo不太友好,auto不可以兼容IE）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">父亲 </span><br><span class="line">.over-flow&#123;</span><br><span class="line">    overflow: hidden; // 是在处理兼容性问题</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>###方法三： clearfix:before,after<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 全浏览器通用的clearfix方案【推荐】</span><br><span class="line">// 同时加入:before以解决现代浏览器上边距折叠的问题</span><br><span class="line">.clearfix:before,</span><br><span class="line">.clearfix:after &#123;</span><br><span class="line">    display: table;//block</span><br><span class="line">    content: &quot; &quot;;// &apos;.&apos;</span><br><span class="line">&#125;</span><br><span class="line">.clearfix:after &#123;</span><br><span class="line">    clear: both;</span><br><span class="line">&#125;</span><br><span class="line">.clearfix&#123;</span><br><span class="line">    *zoom: 1;//引入了zoom以支持IE6/7</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><a href="https://my.oschina.net/leipeng/blog/221125" target="_blank" rel="external">https://my.oschina.net/leipeng/blog/221125</a><br><a href="http://www.jianshu.com/p/5138706046b1" target="_blank" rel="external">http://www.jianshu.com/p/5138706046b1</a><br><a href="http://www.jianshu.com/p/09bd5873bed4" target="_blank" rel="external">http://www.jianshu.com/p/09bd5873bed4</a></p>
<hr>
<h2 id="BFC"><a href="#BFC" class="headerlink" title="BFC"></a>BFC</h2><p>BFC可以做:BFC清除浮动，BFC解决垂直边距折叠<br>BFC全称是块状格式化上下文，它是按照块级盒子布局的。我们了解他的特征、触发方式、常见使用场景这些就够了。</p>
<p>BFC的主要特征</p>
<p>✦ BFC容器是一个隔离的容器，和其他元素互不干扰；所以我们可以用触发两个元素的BFC来解决垂直边距折叠问题。<br>✦ BFC可以包含浮动；通常用来解决浮动父元素高度坍塌的问题。</p>
<p>其中，BFC清除浮动就是用的“包含浮动”这条特性。<br>那么，怎样才能触发BFC呢？</p>
<p>BFC的触发方式</p>
<p>我们可以给父元素添加以下属性来触发BFC(一下任意一条就可以)：<br>✦ float 为 left | right(不为none)<br>✦ overflow 为 hidden | auto | scorll(不为visible   )<br>✦ display 为 table-cell | table-caption | inline-block | flex | inline-flex<br>✦ position 为 absolute | fixed</p>
<hr>
<h2 id="介绍一下标准的CSS的盒子模型？低版本IE的盒子模型有什么不同的？"><a href="#介绍一下标准的CSS的盒子模型？低版本IE的盒子模型有什么不同的？" class="headerlink" title="介绍一下标准的CSS的盒子模型？低版本IE的盒子模型有什么不同的？"></a>介绍一下标准的CSS的盒子模型？低版本IE的盒子模型有什么不同的？</h2><p>每个HTML元素都是长方形盒子。<br>  （1）有两种， IE 盒子模型、W3C 盒子模型；<br>  （2）盒模型： 内容(content)、填充(padding)、边界(margin)、 边框(border)；<br>  （3）区  别：<br> 标准盒模型的width为内容区的width，盒子总宽度：width+padding+border+margin<br> IE的width是内容区宽度+padding+border，盒子总宽度：width+margin</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2377897-2fc97e71155223a0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/2377897-502ce3aaecc4b38b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<hr>
<h2 id="position-的几种值-，详细说明一下每种的区别-3"><a href="#position-的几种值-，详细说明一下每种的区别-3" class="headerlink" title="position 的几种值 ，详细说明一下每种的区别 3%"></a>position 的几种值 ，详细说明一下每种的区别 3%</h2><ul>
<li>static    默认。位置设置为 static 的元素，它始终会处于页面流给予的位置（static 元素会忽略任何 top、bottom、left 或 right 声明）。</li>
<li>relative    位置被设置为 relative 的元素，可将其移至相对于其正常位置的地方，因此 “left:20” 会将元素移至元素正常位置左边 20 个像素的位置。</li>
<li>absolute    位置设置为 absolute 的元素，可定位于相对于包含它的元素的指定坐标。此元素的位置可通过 “left”、”top”、”right” 以及 “bottom” 属性来规定。</li>
<li>fixed    位置被设置为 fixed 的元素，可定位于相对于浏览器窗口的指定坐标。此元素的位置可通过 “left”、”top”、”right” 以及”bottom” 属性来规定。不论窗口滚动与否，元素都会留在那个位置。工作于 IE7（strict 模式）。</li>
</ul>
<hr>
<h2 id="如果position设置成absolute属性该元素的display属性会变成什么"><a href="#如果position设置成absolute属性该元素的display属性会变成什么" class="headerlink" title="如果position设置成absolute属性该元素的display属性会变成什么"></a>如果position设置成absolute属性该元素的display属性会变成什么</h2><ul>
<li>position: absolute,float会隐式的改变display类型， 不论之前是什么类型的元素（ display: none除外），<ul>
<li>只要设置了position: absolute或float， 都会让元素以display: inline - block的方式显示， 可以设置长宽，</li>
</ul>
</li>
<li>就算是显示的设置display: inline或display: block， 仍然无效。</li>
</ul>
<hr>
<h2 id="display-有几个值-3"><a href="#display-有几个值-3" class="headerlink" title="display 有几个值  3%"></a>display 有几个值  3%</h2><p>每个元素都有display属性，确定该元素的类型，<br>每个元素都有默认的display值，<br>如div的display默认值为“block”，则为“块级”元素；<br>span默认display属性值为“inline”，是“行内”元素。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2377897-0a9d9c4eb7fc996e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<hr>
<h2 id="伪类-伪元素"><a href="#伪类-伪元素" class="headerlink" title="伪类 伪元素"></a>伪类 伪元素</h2><p>伪类是给元素模拟添加类 ，来实现某种效果（：）<br>常见伪类：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2377897-394530a71e54ed9f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<p>伪元素是模拟添加个元素来实现效果（::）(css3出现后做的区分)<br>常见伪元素：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2377897-e655b83124da94d9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<p><a href="http://web.jobbole.com/86181/" target="_blank" rel="external">http://web.jobbole.com/86181/</a></p>
<hr>
<h2 id="CSS3新增伪类有那些？"><a href="#CSS3新增伪类有那些？" class="headerlink" title="CSS3新增伪类有那些？"></a>CSS3新增伪类有那些？</h2><pre><code>举例：
  p:first-of-type    选择属于其父元素的首个 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。
  p:last-of-type    选择属于其父元素的最后 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。
  p:only-of-type    选择属于其父元素唯一的 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。
  p:only-child        选择属于其父元素的唯一子元素的每个 &lt;p&gt; 元素。
  p:nth-child(2)    选择属于其父元素的第二个子元素的每个 &lt;p&gt; 元素。

 inptut
    :enabled          
   :disabled         控制表单控件的禁用状态。
  :checked        单选框或复选框被选中。
</code></pre><hr>
<h2 id="CSS选择器有哪些？哪些属性可以继承？"><a href="#CSS选择器有哪些？哪些属性可以继承？" class="headerlink" title="CSS选择器有哪些？哪些属性可以继承？"></a>CSS选择器有哪些？哪些属性可以继承？</h2><pre><code> 1.id选择器（ # myid）
2.类选择器（.myclassname）
3.标签选择器（div, h1, p）
4.相邻选择器（h1 + p）
5.子选择器（ul &gt; li）
6.后代选择器（li a）
7.通配符选择器（ * ）
8.属性选择器（a[rel = &quot;external&quot;]）
9.伪类选择器（a:hover, li:nth-child）
</code></pre><ul>
<li><p>可继承的样式： font-size font-family color, UL LI DL DD DT;</p>
</li>
<li><p>不可继承的样式：border padding margin width height ;</p>
</li>
</ul>
<hr>
<h2 id="CSS优先级算法如何计算？"><a href="#CSS优先级算法如何计算？" class="headerlink" title="CSS优先级算法如何计算？"></a>CSS优先级算法如何计算？</h2><ul>
<li>优先级就近原则，同权重情况下样式定义最近者为准;</li>
<li>载入样式以最后载入的定位为准;<h3 id="同权重"><a href="#同权重" class="headerlink" title="同权重"></a>同权重</h3><ul>
<li>1、 位于 &lt; head / &gt; 标签里的 &lt; style / &gt; 中所定义的CSS拥有最高级的优先权。　　</li>
<li>2、 第二级的优先属性由位于 &lt; style / &gt; 标签中的 @import 引入样式表所定义。　　</li>
<li>3、 第三级的优先属性由 &lt; link / &gt; 标签所引入的样式表定义。</li>
<li>4、 第四级的优先属性由 &lt; link / &gt; 标签所引入的样式表内的 @import 导入样式表定义。　　</li>
<li>5、 第五级优先的样式有用户设定。　　 最低级的优先权由浏览器默认。 </li>
</ul>
</li>
</ul>
<p>权重的进制是256</p>
<h3 id="属性选择器的权重问题"><a href="#属性选择器的权重问题" class="headerlink" title="属性选择器的权重问题:"></a>属性选择器的权重问题:</h3><pre><code>// !important ---------&gt;   无穷
// 行间样式-------------&gt;   1000
// id------------------&gt;   100
// class|属性|伪类------&gt;   10
// 标签|伪元素 ---------&gt;    1
// 通配符---------------&gt;   0
</code></pre><hr>
<h2 id="页面导入样式时，使用link和-import有什么区别？"><a href="#页面导入样式时，使用link和-import有什么区别？" class="headerlink" title="页面导入样式时，使用link和@import有什么区别？"></a>页面导入样式时，使用link和@import有什么区别？</h2><p>1 : 属于link属于xml 标签，除了加载css以外，还能定义rss和rel等 。@import是css提供的，只能用于加载css<br>2 :页面加载页面在加载时候，link同时被加载；而@import引用的css等页面加载完毕再加载<br>3：兼容性@import是CSS2.1 提出的，只在IE5以上才能被识别，而link是XHTML标签，无兼容问题;<br>4：link方式的样式权重高于@import的权重。<br>5：使用dom控制样式时的差别。当使用javascript控制dom去改变样式的时候，只能使用link标签，因为@import不是dom可以控制的。<br>6：. 最后一个很有意思， @import url有最大次数的限制， IE6最多引入31次， firefox并没有发现<br>7： @import的优点： 多个样式表导入一个样式表中， 页面只需要引入一个即可</p>
<hr>
<h2 id="引入css的几种方式-2"><a href="#引入css的几种方式-2" class="headerlink" title="引入css的几种方式 2%"></a>引入css的几种方式 2%</h2><h3 id="1-行内样式"><a href="#1-行内样式" class="headerlink" title="1.行内样式"></a>1.行内样式</h3><p>最直接最简单的一种，直接对HTML标签使用style=””，例如：</p>
<p style="color:#F00; "></p>

<p>缺点：HTML页面不纯净，文件体积大，不利于蜘蛛爬行，后期维护不方便。</p>
<h3 id="2-内嵌样式"><a href="#2-内嵌样式" class="headerlink" title="2.内嵌样式"></a>2.内嵌样式</h3><p>内嵌样式就是将CSS代码写在<head></head>之间，并且用<style></style>进行声明，例如：</p>
<style type="text/css">

body,div,a,img,p{margin:0; padding:0;}

</style>

<p>优缺点：页面使用公共CSS代码，也是每个页面都要定义的，如果一个网站有很多页面，每个文件都会变大，后期维护难度也大，如果文件很少，CSS代码也不多，这种样式还是很不错的。</p>
<h3 id="3-链接样式"><a href="#3-链接样式" class="headerlink" title="3.链接样式"></a>3.链接样式</h3><p>链接样式是使用频率最高，最实用的样式，只需要在<head></head>之间加上<link…>就可以了，如下：</link…></p>
<link type="text/css" rel="stylesheet" href="style.css">

<p>优缺点：实现了页面框架代码与表现CSS代码的完全分离，使得前期制作和后期维护都十分方便</p>
<h3 id="4-导入样式（不建议使用）"><a href="#4-导入样式（不建议使用）" class="headerlink" title="4.导入样式（不建议使用）"></a>4.导入样式（不建议使用）</h3><p>导入样式和链接样式比较相似，采用@import样式导入CSS样式表，在HTML初始化时，会被导入到HTML或者CSS文件中，成为文件的一部分，类似第二种内嵌样式。</p>
<ul>
<li>@import在html中使用，如下：</li>
</ul>
<style type="text/css">
@import url(style.css);
</style>

<ul>
<li>@import在CSS中使用，如下：</li>
</ul>
<p>@import url(style.css);</p>
<h3 id="四种CSS引入方式的优先级"><a href="#四种CSS引入方式的优先级" class="headerlink" title="四种CSS引入方式的优先级"></a>四种CSS引入方式的优先级</h3><p>1.就近原则<br>2.理论上：行内&gt;内嵌&gt;链接&gt;导入<br>3.实际上：内嵌、链接、导入在同一个文件头部，谁离相应的代码近，谁的优先级高</p>
<hr>
<h2 id="锚点-1"><a href="#锚点-1" class="headerlink" title="锚点 1%"></a>锚点 1%</h2><p>html 锚点 到底是干吗的？<br>通俗简单地说，比如一篇很长的文章，你想按分段精确来看，那就可以用到锚点了<br>代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href=&quot;#001&quot;&gt;跳到001&lt;/a&gt;</span><br><span class="line">...文字省略</span><br><span class="line">&lt;a name=&quot;001&quot; id=&quot;001&quot; &gt;&lt;/a&gt;</span><br><span class="line">...文字省略</span><br></pre></td></tr></table></figure></p>
<p>(兼容到ie8)<br>其实锚点只需name就可以可，加id是为了让它兼容性更好.<br>href的值要跟name \ i d 一致，前面必须加”#”，以上代码在ie6/7,ff中都可以兼容，但在ie8中就不行。<br>因为我们锚点的<a></a>值为空，为不影响美观我们加个空格就行了,</p>
<p>另一问题，想显示某页面(如：123.html)的某锚点内容呢？ </p>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">代码如下</span><br><span class="line">&lt;a href=&quot;123.html#001&quot;&gt;跳到001&lt;/a&gt;</span><br><span class="line">...文字省略</span><br><span class="line">&lt;a name=&quot;001&quot; id=&quot;001&quot; &gt; &lt;/a&gt;</span><br><span class="line">...文字省略</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="两栏布局（左固定，右自适应）"><a href="#两栏布局（左固定，右自适应）" class="headerlink" title="两栏布局（左固定，右自适应）"></a>两栏布局（左固定，右自适应）</h2><h3 id="1-float-margin"><a href="#1-float-margin" class="headerlink" title="1:float+margin"></a>1:float+margin</h3><p>左定宽高左浮动， 右设置margin - left:左边宽<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.left &#123;</span><br><span class="line">    width: 100 px;</span><br><span class="line">    height: 100 px;</span><br><span class="line">    float: left;</span><br><span class="line">&#125;</span><br><span class="line">.right &#123;</span><br><span class="line">    height: 100 px;</span><br><span class="line">    margin - left: 100 px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="2：float-BFC"><a href="#2：float-BFC" class="headerlink" title="2：float+BFC"></a>2：float+BFC</h3><p>左定宽高左浮动，右触发BFC</p>
<h3 id="3-left-0-left-左宽-right-0"><a href="#3-left-0-left-左宽-right-0" class="headerlink" title="3:left:0,left:-左宽,right:0;"></a>3:left:0,left:-左宽,right:0;</h3><p>左定宽高 ,设置定位position absolute, left 0 ;<br>        .left {<br>            width: 100 px;<br>            height: 100 px;<br>            background - color: red;<br>            position: absolute;<br>            left: 0;<br>        }<br>        .right {<br>            height: 100 px;<br>            background - color: green;<br>            right: 0;<br>        }</p>
<h3 id="三个元素都浮动，左定宽高，右宽-cal-100-x"><a href="#三个元素都浮动，左定宽高，右宽-cal-100-x" class="headerlink" title="三个元素都浮动，左定宽高，右宽 cal(100%-x)"></a>三个元素都浮动，左定宽高，右宽 cal(100%-x)</h3><hr>
<h2 id="实现三列布局（两边固定，中间自适应）"><a href="#实现三列布局（两边固定，中间自适应）" class="headerlink" title="实现三列布局（两边固定，中间自适应）"></a>实现三列布局（两边固定，中间自适应）</h2><p>1：绝对定位法：左右绝对定位，left:0,right:0,中间margin: 0 x;<br>此方法的优点是，理解容易，上手简单，受内部元素影响而破坏布局的概率低，就是比较经得起折腾。<br>缺点在于：如果中间栏含有最小宽度限制.布局可能受内部影响。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">.con &#123;</span><br><span class="line">       overflow: hidden;</span><br><span class="line">       height: 500px;</span><br><span class="line">   &#125;</span><br><span class="line">   .left,.right &#123;</span><br><span class="line">       width: 200px;</span><br><span class="line">       height: 100%;</span><br><span class="line">       position: absolute;</span><br><span class="line">       top: 0;//为了防止将后一个块级元素挤下去</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   .left &#123;</span><br><span class="line">       left: 0;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   .right &#123;</span><br><span class="line">       right: 0；</span><br><span class="line">   &#125;</span><br><span class="line">.main &#123;</span><br><span class="line">       margin: 0 210px;</span><br><span class="line">       overflow: hidden;</span><br><span class="line">       height: 100%;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>2：浮动方法：左右各浮动+中设margin<br>简便，但是灵活性低下<br>dom顺序有限制：因为左右浮动的缘故，只能将mid放在左右后面<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">    .con &#123;</span><br><span class="line">        overflow: hidden;</span><br><span class="line">        height: 500px;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    .main &#123;</span><br><span class="line">        height: 100%;</span><br><span class="line">        margin: 0 210px;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    .left,</span><br><span class="line">    .right &#123;</span><br><span class="line">        width: 200px;</span><br><span class="line">        height: 100%;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    .left &#123;</span><br><span class="line">        float: left;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    .right &#123;</span><br><span class="line">        float: right;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">    &lt;div class=&quot;con&quot;&gt;</span><br><span class="line"></span><br><span class="line">        &lt;div class=&quot;left&quot;&gt;我是左边&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">        &lt;div class=&quot;right&quot;&gt;我是右边&lt;/div&gt;</span><br><span class="line">        &lt;div class=&quot;main&quot;&gt;</span><br><span class="line"></span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure></p>
<p>3:flex，将mid设置属性flex:1<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">.con &#123;</span><br><span class="line">        height: 500px;</span><br><span class="line">        display: flex;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    .main &#123;</span><br><span class="line">        height: 100%;</span><br><span class="line">        flex: 1;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    .left,</span><br><span class="line">    .right &#123;</span><br><span class="line">        width: 200px;</span><br><span class="line">        height: 100%;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>4：圣杯布局：三个都浮动+左右margin负值<br>优点：三栏相互关联，可谓真正意义上的自适应，有一定的抗性——布局不易受内部影响。<br>缺点：相对比较难理解些，上手不容易，代码相对复杂。出现百分比宽度，过多的负值定位，如果出现布局的bug，排查不易。<br>【dom结构】：先自适应的div，然后再左右顺序可以不定<br>mid外层: width:100%，float:left<br>mid :margin 0 x;<br>左右 左浮动<br>第一个兄弟：margin-left:-100%<br>第二个兄弟：margin-left:-xpx;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;con&quot;&gt;</span><br><span class="line">        &lt;div class=&quot;main&quot;&gt;</span><br><span class="line">            &lt;div class=&quot;main-con&quot;&gt;</span><br><span class="line">                我是中间</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">        &lt;div class=&quot;left&quot;&gt;我是左边&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">        &lt;div class=&quot;right&quot;&gt;我是右边&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">    &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">.con &#123;</span><br><span class="line">        overflow: hidden;</span><br><span class="line">        height: 500px;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    .mid-wraper &#123;</span><br><span class="line">        width: 100%;</span><br><span class="line">        height: 100%;</span><br><span class="line">        float: left;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    .mid &#123;</span><br><span class="line">        margin: 0 210px;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    .left,</span><br><span class="line">    .right &#123;</span><br><span class="line">        width: 200px;</span><br><span class="line">        height: 100%;</span><br><span class="line">        float: left;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    .left &#123;</span><br><span class="line">        margin-left: -100%</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    .right &#123;</span><br><span class="line">        margin-left: -220px;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="BFC的通俗理解："><a href="#BFC的通俗理解：" class="headerlink" title="BFC的通俗理解："></a>BFC的通俗理解：</h2><ul>
<li>Block Formatting Context（ 块级格式化上下文） 是W3C CSS 2.1 规范中的一个概念， 它决定了元素如何对其内容进行定位， 以及与其他元素的关系和相互作用。 简单来讲， 我们可以把它理解为， 我们在进行盒模型布局的时候， 如果一个元素符合了成为BFC的条件，<ul>
<li>该元素成为一个隔离了的独立容器， 元素内部元素会垂直的沿着其父元素的边框排列， 和外部元素互不影响。 比如浮动元素会触发BFC，<br>浮动元素内部的子元素主要受到该浮动元素的影响， 而两个浮动元素之间是互不影响的。</li>
<li>在CSS3 中， BFC 叫做Flow Root。 在早期的ie中也有类似的概念haslayout IE6、 7 的很多布局产生的bug（ 如3px间隙、 绝对定位的继承宽度）都可以通过触发hasLayout修复， 比较推荐的方法为zoom: 1 与height: 1 % ，不会破坏已有的样式， 相信大家对它并不陌生。</li>
<li>同样的以往集中在float、 绝对定位、 margin collaspe中的很多困惑， 在理解了bfc后， 都能够被我们一一解除。<h2 id="BFC规范中的定义："><a href="#BFC规范中的定义：" class="headerlink" title="BFC规范中的定义："></a>BFC规范中的定义：</h2>w3c规范对BFC的解释：</li>
<li>浮动元素和绝对定位元素， 不是块级盒子的块容器（ 如 inline - blocks, table - cells, 和 table - captions）， 以及设置了overflow属性（ 除了visible）的块级盒子， 都会为他们的内容创建新的BFC（ 块级格式上下文）。<ul>
<li>在BFC中， 盒子从顶端开始垂直地 一个接一个地排列， 两个盒子之间的垂直的间隙是由他们的margin 值所决定的。 在一个BFC中， 两个相邻的块级盒子的</li>
<li>垂直外边距会产生折叠。 在BFC中， 每一个盒子的左外边缘（ margin - left） 会触碰到容器的左边缘(border - left)（ 对于从右到左的格式来说， 则触碰到右边缘）。</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre><code>    触发BFC的方法：(任一即可)

float 元素
position（ absolute， fixed）
display(table - cell， table - caption， inline - block)
overflow 除了visible 以外的值（ hidden， auto， scroll）
fieldset元素
早期IE的hasLayout会触发一个新的block formatting context
</code></pre><h3 id="BFC的特性"><a href="#BFC的特性" class="headerlink" title="BFC的特性"></a>BFC的特性</h3><ul>
<li>边缘不和浮动元素重叠</li>
<li>不存在collapsing margins问题</li>
<li>第一个特性特别有用， 因为元素触发了BFC的话， 就不会被float元素覆盖， 当子元素全部浮动的时候也能够正确地包含了<ul>
<li>第二个margin不会叠加的特性， 可以理解为两个处于普通流的盒子， 会有margin叠加的问题， 是因为他们属于相同的BFC， 当他自身创建了一个新的BFC时， 这个问题就不存在了<h3 id="BFC的常见应用"><a href="#BFC的常见应用" class="headerlink" title="BFC的常见应用"></a>BFC的常见应用</h3><ol>
<li>通过边缘不和浮动元素重叠的特性， 实现两栏结构。</li>
<li>清除元素内部浮动</li>
<li>解决合并外边距的问题</li>
</ol>
</li>
</ul>
</li>
</ul>
<hr>
<h2 id="常见的浏览器端的存储技术都有哪些，以及他们的优缺点和使用场景？"><a href="#常见的浏览器端的存储技术都有哪些，以及他们的优缺点和使用场景？" class="headerlink" title="常见的浏览器端的存储技术都有哪些，以及他们的优缺点和使用场景？"></a>常见的浏览器端的存储技术都有哪些，以及他们的优缺点和使用场景？</h2><p>有时需要将网页中的一些数据保存在浏览器端，这样做的好处是，当下次访问页面时，不需要再次向服务器请求数据，直接就可以从本地读取数据。目前常用的有以下几种方法：</p>
<h3 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a><strong>cookie</strong></h3><p>cookie会随着每次HTTP请求头信息一起发送，无形中增加了网络流量，另外，cookie能存储的数据容量有限，根据浏览器类型不同而不同，IE6大约只能存储2K，cookie数据大小不能超过4k</p>
<h3 id="Flash-ShareObject"><a href="#Flash-ShareObject" class="headerlink" title="Flash ShareObject"></a><strong>Flash ShareObject</strong></h3><p>这种方式能能解决上面提到的cookie存储的两个弊端，而且能够跨浏览器，应该说是目前最好的本地存储方案。不过，需要在页面中插入一个Flash，当浏览器没有安装Flash控件时就不能用了。所幸的是，没有安装Flash的用户极少。<br>缺点：需要安装Flash插件。</p>
<h3 id="sessionStorage"><a href="#sessionStorage" class="headerlink" title="sessionStorage"></a><strong>sessionStorage</strong></h3><p>使用于Firefox2+的火狐浏览器，用这种方式存储的数据仅窗口级别有效，同一个窗口（或者Tab）页面刷新或者跳转，都能获取到本地存储的数据，当新开窗口或者页面时，原来的数据就失效了。<br>缺点：IE不支持、不能实现数据的持久保存。</p>
<h3 id="localStorage"><a href="#localStorage" class="headerlink" title="localStorage"></a><strong>localStorage</strong></h3><p>localStorage是Web Storage互联网存储规范中的一部分，现在在Firefox 3.5、Safari 4和IE8中得到支持。<br>缺点：低版本浏览器不支持。</p>
<p>提示：localStorage储存的值都是字符串类型，使用时要注意。另外，可以在浏览器调试器中的Resources的localStorage中看到储存的信息。</p>
<blockquote>
<p>//存储信息   （存储的信息名称，要存储的字符串）<br>localStorage.setItem(“CC_email_list”,input_eamil[i])<br>//读取信息   （要读取的信息名称）<br>localStorage.getItem(“CC_email_list”)<br>//清除信息    （要清除的信息名称）<br>localStorage.removeItem(“CC_email_list”);</p>
</blockquote>
<h3 id="globalStorage"><a href="#globalStorage" class="headerlink" title="globalStorage"></a><strong>globalStorage</strong></h3><p>使用于Firefox2+的火狐浏览器，类似于IE的userData。<br>1 //赋值 2 globalStorage[location.hostname][‘name’] = ‘tugai’; 3 //读取 4 globalStorage[location.hostname][‘name’]; 5 //删除 6 globalStorage[location.hostname].removeItem(‘name’);</p>
<h3 id="Google-Gear"><a href="#Google-Gear" class="headerlink" title="Google Gear"></a><strong>Google Gear</strong></h3><p>Google开发出的一种本地存储技术。<br>缺点：需要安装Gear组件。</p>
<h3 id="userData"><a href="#userData" class="headerlink" title="userData"></a><strong>userData</strong></h3><p>IE浏览器可以使用userData来存储数据，容量可达到640K，这种方案是很可靠的，不需要安装额外的插件。缺点：它仅在IE下有效。<br>缺点：IE不支持。</p>
<p>结论：Flash shareobject是不错的选择，如果你不想在页面上嵌入Flash，可以结合使用userData(IE6+)和globalStorage(Firefox2+)和localStorage(chrome3+)实现跨浏览器。</p>
<hr>
<h2 id="请描述一下-cookies，sessionStorage-和-localStorage-的区别？"><a href="#请描述一下-cookies，sessionStorage-和-localStorage-的区别？" class="headerlink" title="请描述一下 cookies，sessionStorage 和 localStorage 的区别？"></a>请描述一下 cookies，sessionStorage 和 localStorage 的区别？</h2><pre><code>cookie是网站为了标示用户身份而储存在用户本地终端（Client Side）上的数据（通常经过加密）。
cookie数据始终在同源的http请求中携带（即使不需要），记会在浏览器和服务器间来回传递。
sessionStorage和localStorage不会自动把数据发给服务器，仅在本地保存。
</code></pre><h3 id="存储大小："><a href="#存储大小：" class="headerlink" title="存储大小："></a>存储大小：</h3><pre><code>cookie数据大小不能超过4k。
sessionStorage和localStorage 虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大。
</code></pre><h3 id="有期时间："><a href="#有期时间：" class="headerlink" title="有期时间："></a>有期时间：</h3><pre><code>localStorage    存储持久数据，浏览器关闭后数据不丢失除非主动删除数据；
sessionStorage  数据在当前浏览器窗口关闭后自动删除。
cookie          设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭
</code></pre><hr>
<h1 id="HTML5"><a href="#HTML5" class="headerlink" title="HTML5"></a>HTML5</h1><h2 id="新特性"><a href="#新特性" class="headerlink" title="新特性"></a>新特性</h2><h3 id="1-标签语义化，"><a href="#1-标签语义化，" class="headerlink" title="1:标签语义化，"></a>1:标签语义化，</h3><p>比如header，footer，nav，aside，article，section等，新增了很多表单元素，入email，url等，除去了center等样式标签，还有除去了有性能问题的frame，frameset等标签</p>
<h3 id="2、音视频元素，"><a href="#2、音视频元素，" class="headerlink" title="2、音视频元素，"></a>2、音视频元素，</h3><p>video，audio的增加使得我们不需要在依赖外部的插件就可以往网页中加入音视频元素。</p>
<h3 id="3、新增很多api，"><a href="#3、新增很多api，" class="headerlink" title="3、新增很多api，"></a>3、新增很多api，</h3><p>比如获取用户地理位置的window.navigator.geoloaction</p>
<h3 id="、websocket"><a href="#、websocket" class="headerlink" title="、websocket"></a>、websocket</h3><p>websocket是伴随html5到来的基于tcp/ip的全双工通信的协议。<br>主要通信过程：先借http完成握手，达到了长连接<br>第一步：浏览器基于tcp，发送http请求<br>第二步：服务器端，接收到请求后。将 tcp用户网络层协议变为websocket协议，完成了握手<br>第三步：服务器端和浏览器完成握手，他们之间形成一条通道，可以源源不断的传送信息<br>websocket是一种协议，可以让我们建立客户端到服务器端的全双工通信，这就意味着服务器端可以主动推送数据到客户端。</p>
<hr>
<h3 id="、HTML5-能够本地存储数据，在之前都是使用-cookies-使用的。"><a href="#、HTML5-能够本地存储数据，在之前都是使用-cookies-使用的。" class="headerlink" title="、HTML5 能够本地存储数据，在之前都是使用 cookies 使用的。"></a>、HTML5 能够本地存储数据，在之前都是使用 cookies 使用的。</h3><p>HTML5 提供了下面本地存储方案：webstorage包括localeStorage和sessionStorage，localeStorage是持久化存储在客户端，只要用户不主动删除，就不会消失，sessionStorage也是存储在客户端，但是他的存在时间是一个回话，一旦浏览器的关于该回话的页面关闭了，sessionStorage就消失了，</p>
<hr>
<h3 id="：请描述一下-cookies，sessionStorage-和-localStorage-的区别？"><a href="#：请描述一下-cookies，sessionStorage-和-localStorage-的区别？" class="headerlink" title="：请描述一下 cookies，sessionStorage 和 localStorage 的区别？"></a>：请描述一下 cookies，sessionStorage 和 localStorage 的区别？</h3><p>  cookie是网站为了标示用户身份而储存在客户端上的数据（通常经过加密）。<br>  cookie数据始终在同源的http请求中携带（即使不需要），记会在浏览器和服务器间来回传递。<br>  sessionStorage和localStorage不会自动把数据发给服务器，仅在本地保存。</p>
<p>  存储大小：<br>      cookie数据大小不能超过4k。<br>      sessionStorage和localStorage 虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大。</p>
<p>  有期时间：<br>      localStorage    存储持久数据，浏览器关闭后数据不丢失除非主动删除数据；<br>      sessionStorage  数据在当前浏览器窗口关闭后自动删除。<br>      cookie  在过期时间之前一直有效，即使窗口或浏览器关闭</p>
<hr>
<h3 id="、应用程序缓存："><a href="#、应用程序缓存：" class="headerlink" title="、应用程序缓存："></a>、应用程序缓存：</h3><p>在用户没有与因特网连接时，可以正常访问站点或应用，在用户与因特网连接时，更新用户机器上的缓存文件。<br>  原理：HTML5的离线存储是基于一个新建的.appcache文件的缓存机制(不是存储技术)，通过这个文件上的解析清单离线存储资源，这些资源就会像cookie一样被存储了下来。之后当网络在处于离线状态下时，浏览器会通过被离线存储的数据进行页面展示。</p>
<p>html5允许我们自己控制哪些文件需要缓存，哪些不需要，具体的做法如下：</p>
<p>1、首先给html添加manifest属性，并赋值为cache.manifest<br>2、cache.manifest的内容为:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">  CACHE MANIFEST</span><br><span class="line">  #v1.2</span><br><span class="line">  CACHE :           //表示需要缓存的文件</span><br><span class="line">    a.js</span><br><span class="line">    b.js</span><br><span class="line">NETWORK:    //表示只在用户在线的时候才需要的文件，不会缓存</span><br><span class="line">  c.js</span><br><span class="line">FALLBACK</span><br><span class="line">/        /index.html     //表示如果找不到第一个资源就用第二个资源代替</span><br></pre></td></tr></table></figure></p>
<hr>
<h3 id="、web-worker，web-worker"><a href="#、web-worker，web-worker" class="headerlink" title="、web worker，web worker"></a>、web worker，web worker</h3><p>是运行在浏览器后台的js程序，他不影响主程序的运行，是另开的一个js线程，可以用这个线程执行复杂的数据操作，然后把操作结果通过postMessage传递给主线程，这样在进行复杂且耗时的操作时就不会阻塞主线程了。</p>
<hr>
<h1 id="CSS3"><a href="#CSS3" class="headerlink" title="CSS3"></a>CSS3</h1><ul>
<li>css3的新特性哪些，你都用过哪些 5%<h2 id="媒体查询具体到语句-5"><a href="#媒体查询具体到语句-5" class="headerlink" title="媒体查询具体到语句 5%"></a>媒体查询具体到语句 5%</h2>作用：媒体查询可以让我们根据设备显示器的特性（如视口宽度、屏幕比例、设备方向：横向或纵向）为其设定CSS样式，检测的媒体特性有 width 、 height 和 color （等）。</li>
</ul>
<h2 id="响应式布局meta-scale-怎样使用media"><a href="#响应式布局meta-scale-怎样使用media" class="headerlink" title="响应式布局meta,scale 怎样使用media?"></a>响应式布局meta,scale 怎样使用media?</h2><h3 id="meta-scale"><a href="#meta-scale" class="headerlink" title="meta,scale"></a>meta,scale</h3><p>第一步：<br> 首先需要在html文档中添加以下代码，用来兼容移动设备的显示效果</p>
<meta name="viewport content=" width="device-width,initial-scale=1,maximum-scale=1,user-scalable=no"/">

ps:
>width=device-width:宽度等于当前设备的宽度
initial-scale=1：初始的缩放比例（默认为1）
maximum-scale=1：允许用户缩放到得最大比例（默认为1）
user-scalable=no：用户不能手动缩放

### 第二步：媒体查询 语句
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@media screen and (max-width:720px) and (min-width:320px)&#123;</span><br><span class="line"></span><br><span class="line">      body&#123;</span><br><span class="line"></span><br><span class="line">       background-color:red;</span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">@media screen and (max-width:320px)&#123;</span><br><span class="line"></span><br><span class="line">      body&#123;</span><br><span class="line"></span><br><span class="line">         background-color:blue;</span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

## css 伪类 5%
### 伪类选择器
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">p:first-of-type	选择属于其父元素的首个 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。</span><br><span class="line">p:last-of-type	选择属于其父元素的最后 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。</span><br><span class="line">p:only-of-type	选择属于其父元素唯一的 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。</span><br><span class="line">p:only-child		选择属于其父元素的唯一子元素的每个 &lt;p&gt; 元素。</span><br><span class="line">p:nth-child(2)	选择属于其父元素的第二个子元素的每个 &lt;p&gt; 元素。</span><br></pre></td></tr></table></figure>

***
### 伪类 伪元素
伪类是给元素模拟添加类 ，来实现某种效果（：）
常见伪类：

![Paste_Image.png](http://upload-images.jianshu.io/upload_images/2377897-394530a71e54ed9f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

伪元素是模拟添加个元素来实现效果（::）(css3出现后做的区分)
常见伪元素：

![Paste_Image.png](http://upload-images.jianshu.io/upload_images/2377897-e655b83124da94d9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

http://web.jobbole.com/86181/

## 说一下flex 3%
### 请解释一下CSS3的Flexbox（弹性盒布局模型）,以及适用场景？
 一个用于页面布局的全新CSS3功能，Flexbox可以把列表放在同一个方向（从上到下排列，从左到右），并让列表能延伸到占用可用的空间。
   较为复杂的布局还可以通过嵌套一个伸缩容器（flex container）来实现。
   采用Flex布局的元素，称为Flex容器（flex container），简称"容器"。
   它的所有子元素自动成为容器成员，称为Flex项目（flex item），简称"项目"。
   常规布局是基于块和内联流方向，而Flex布局是基于flex-flow流可以很方便的用来做局中，能对不同屏幕大小自适应。
   在布局上有了比以前更加灵活的空间
http://www.w3cplus.com/css3/flexbox-basics.html

***
## 动画 2%

  二维动画——animation  这个属性必须配合@keyframes动画关键帧来使用。keyframes里面包含一个百分数，后面跟上在这段时间内变换的css样式。
     animation是一个复合属性，它包括以下几个组成部分：
   * 1.animation-name：执行动画的keyframes的名字。
    * 2.animation-duration：执行动画的总时长。
    * 3.animation-timing-function：指定过渡函数。
    * 4.animation-delay：执行延迟时间。
    *  5.animation-direction：动画播放的方式。这个属性的值主要有：normal正常播放模式、reverse倒序播放、alternate
                  动画在奇数次正向播放偶数次倒序播放、alternate-reverse动画在奇数次倒序播放偶数次正向播放。
     *  6.animation-iteration-count：动画执行的次数。infinite是无限次，写一个数字就是要执行几次。
      *  7.animation-fill-mode：执行完动画后物体停止的位置。forwards是停在结束的位置上、backwards是快速执行初始帧
                  （这个最好配合延迟来观察）、
                  none是回到初始帧的位置、both是同时具有forwards和backwards的效果。
        *  8.animation-play-state：控制动画的播放状态。running是播放、paused是暂停。
***
## css3动画卡了

    transform: transition3d(0, 0, 0);
    transform: translateZ(0);
    这两个属性可以开启GPU加速模式
    然而面试官问我为什么，你知道原理么？
    这两个属性都会开启GPU硬件加速模式，从而让浏览器在渲染动画的时候从CPU转向GPU
## less
*  Less 有了解过吗？有什么好处？
   什么是CSS 预处理器 / 后处理器？
    * 预处理器例如：LESS、Sass、Stylus，用来预编译Sass或less，增强了css代码的复用性，
    还有层级、mixin、变量、循环、函数等，具有很方便的UI组件模块化开发能力，极大的提高工作效率。
   * 后处理器例如：PostCSS，通常被视为在完成的样式表中根据CSS规范处理CSS，让其更有效；目前最常做的是给CSS属性添加浏览器私有前缀，实现跨浏览器兼容性的问题。
## 常见的浏览器端的存储技术都有哪些，以及他们的优缺点和使用场景？
有时需要将网页中的一些数据保存在浏览器端，这样做的好处是，当下次访问页面时，不需要再次向服务器请求数据，直接就可以从本地读取数据。目前常用的有以下几种方法：
### **cookie**
cookie会随着每次HTTP请求头信息一起发送，无形中增加了网络流量，另外，cookie能存储的数据容量有限，根据浏览器类型不同而不同，IE6大约只能存储2K，cookie数据大小不能超过4k
### **Flash ShareObject**
这种方式能能解决上面提到的cookie存储的两个弊端，而且能够跨浏览器，应该说是目前最好的本地存储方案。不过，需要在页面中插入一个Flash，当浏览器没有安装Flash控件时就不能用了。所幸的是，没有安装Flash的用户极少。
缺点：需要安装Flash插件。
### **sessionStorage**
使用于Firefox2+的火狐浏览器，用这种方式存储的数据仅窗口级别有效，同一个窗口（或者Tab）页面刷新或者跳转，都能获取到本地存储的数据，当新开窗口或者页面时，原来的数据就失效了。
缺点：IE不支持、不能实现数据的持久保存。
### **localStorage**
localStorage是Web Storage互联网存储规范中的一部分，现在在Firefox 3.5、Safari 4和IE8中得到支持。
缺点：低版本浏览器不支持。

提示：localStorage储存的值都是字符串类型，使用时要注意。另外，可以在浏览器调试器中的Resources的localStorage中看到储存的信息。
>//存储信息   （存储的信息名称，要存储的字符串）
localStorage.setItem("CC_email_list",input_eamil[i])
//读取信息   （要读取的信息名称）
localStorage.getItem("CC_email_list")
//清除信息    （要清除的信息名称）
localStorage.removeItem("CC_email_list");

### **globalStorage**
使用于Firefox2+的火狐浏览器，类似于IE的userData。
1 //赋值 2 globalStorage[location.hostname]['name'] = 'tugai'; 3 //读取 4 globalStorage[location.hostname]['name']; 5 //删除 6 globalStorage[location.hostname].removeItem('name');
### **Google Gear**
Google开发出的一种本地存储技术。
缺点：需要安装Gear组件。
### **userData**
IE浏览器可以使用userData来存储数据，容量可达到640K，这种方案是很可靠的，不需要安装额外的插件。缺点：它仅在IE下有效。
缺点：IE不支持。

结论：Flash shareobject是不错的选择，如果你不想在页面上嵌入Flash，可以结合使用userData(IE6+)和globalStorage(Firefox2+)和localStorage(chrome3+)实现跨浏览器。
***
## 请描述一下 cookies，sessionStorage 和 localStorage 的区别？

    cookie是网站为了标示用户身份而储存在用户本地终端（Client Side）上的数据（通常经过加密）。
    cookie数据始终在同源的http请求中携带（即使不需要），记会在浏览器和服务器间来回传递。
    sessionStorage和localStorage不会自动把数据发给服务器，仅在本地保存。
### 存储大小：
        cookie数据大小不能超过4k。
        sessionStorage和localStorage 虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大。
### 有期时间：
        localStorage    存储持久数据，浏览器关闭后数据不丢失除非主动删除数据；
        sessionStorage  数据在当前浏览器窗口关闭后自动删除。
        cookie          设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭

***
## html 获取页面，浏览器，屏幕宽高
一个页面的展示，从外到内的容器为：屏幕->浏览器->页面本身。
HTML元素展现在页面内->页面展现在浏览器内->而浏览器展现在屏幕内。
通过Js的一些对象可以获取这些容器的高度、宽度。
1：总

![Paste_Image.png](http://upload-images.jianshu.io/upload_images/2377897-c6dff4f74e7f2eb3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)


2:屏幕
![Paste_Image.png](http://upload-images.jianshu.io/upload_images/2377897-f47a188d60bd97a4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
3:浏览器

![Paste_Image.png](http://upload-images.jianshu.io/upload_images/2377897-8e3d9af0d6d264b0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

![Paste_Image.png](http://upload-images.jianshu.io/upload_images/2377897-5e416993bde1fdb7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)


5:可视区 
定义：可视区域是指能显示网页内容区域的宽高。
拉动控制台的时候网页可视区域的宽高也会随之改变。
可视区宽高跟内容宽高没关系。

如果内容超过可视区域的高度或者宽度就出现滚动条。要获取可视区域的宽高每个浏览器的获取方法不一样

[参照](http://www.cnblogs.com/polk6/p/5051935.html)
***
## Doctype
1.Doctype作用
位置：<!DOCTYPE>声明位于html第一行
作用： 告知浏览器用什么标准解析html文档
            <!DOCTYPE>不存在，或者格式不正确，会导致文档以兼容模 (怪异模式)式出现

语法：
      HTML 顶级元素 可用性 "注册//组织//类型 标签//定义 语言""URL"
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN"> 
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Strict//EN">

其中，DTD的是W3C所发布的一个文档类型定义，简单的说，就是告诉浏览器你的这个HTML，是根据那个标准写的，解析的时候用哪个标准解析。




http://www.qdfuns.com/notes/21146/12ba5b538dd5974b1bee88f77c71b0a0.html
***

##为什么HTML5就只要写<!DOCTYPE HTML>?
HTML 4.01 中的 doctype 需要对 DTD 进行引用，因为 HTML 4.01 基于 SGML。 HTML 5 不基于 SGML，因此不需要对 DTD 进行引用，但是需要 doctype 来规范浏览器的行为。
其中，SGML是标准通用标记语言,简单的说，就是比HTML,XML更老的标准，这两者都是由SGML发展而来的。BUT，HTML5不是的。
***
## 标准模式与兼容模式（怪异模式）各有什么区别?

A：在标准模式中，浏览器根据规范呈现页面；在混杂模式中，页面以一种比较宽松向后兼容的方式显示。简单的说，就是尽可能的显示能显示的东西给用户看。（但是会有些样式失效）

1：width不同
在严格模式中 ：width是内容宽度 ，元素真正的宽度 = width+（padding+border+margin）2
在兼容模式中 ：width则是元素的实际宽度 ，内容宽度 = width - ( padding2+border2)

2.兼容模式下可设置百分比的高度和行内元素的高宽
    在Standards模式下，给span等行内元素设置wdith和height都不会生效，而在兼容模式下，则会生效。
    在standards模式下，一个元素的高度是由其包含的内容来决定的，如果父元素没有设置高度，子元素设置一个百分比的高度是无效的。

3.用margin:0 auto设置水平居中在IE下会失效
    使用margin:0 auto在standards模式下可以使元素水平居中，但在兼容模式下却会失效（用text-align属性解决）
    body{text-align:center};#content{text-align:left}

4.兼容模式下Table中的字体属性不能继承上层的设置，white-space:pre会失效，设置图片的padding会失效

***
## 介绍一下你对浏览器内核的理解？
主要分成两部分：渲染引擎(layout engineer或Rendering Engine)和JS引擎。
  渲染引擎：负责取得网页的内容（HTML、XML、图像等等）、整理讯息（例如加入CSS等），以及计算网页的显示方式，然后会输出至显示器或打印机。浏览器的内核的不同对于网页的语法解释会有不同，所以渲染的效果也不相同。所有网页浏览器、电子邮件客户端以及其它需要编辑、显示网络内容的应用程序都需要内核。

JS引擎则：解析和执行javascript来实现网页的动态效果。
***
常见的浏览器内核有哪些？
 Trident内核：IE,MaxThon,TT,The World,360,搜狗浏览器等。[又称MSHTML]
  Gecko内核：Netscape6及以上版本，FF,MozillaSuite/SeaMonkey等
  Presto内核：Opera7及以上。      [Opera内核原为：Presto，现为：Blink;]
  Webkit内核：Safari,Chrome等。   [ Chrome的：Blink（WebKit的分支）]
***
## HTML、XML、XHTML 有什么区别？
HTML是被设计用来显示数据的，重点是:显示数据以及如何显示数据更好上面。
XML是被设计用来描述数据的，重点是:什么是数据，如何存放数据。
XHTML基于HTML的基础上进行了扩展和规范，让XHTML更加严格，主要目的是促进HTML向XML过渡。

HTML的弊端：
编码不规范，结构混乱臃肿，需要智能的终端才能很好的显示；
表现和结构混乱，不利于开发和维护；
不能使用于更多的网络设备中，比如手机；
为了让HTML逐渐过渡到XML阶段，w3c又定制了XHTML标准。

而XML的弊端也不少：
在数据中寻找信息非常难
大数据量效率低
使用XML传输数据时没有数据库系统那样的信息管理功能
因此XML因为自身严苛限制等因素逐渐被HTML5取代。
***
## 怎样理解 HTML 语义化？
HTML语义化能提高网页语义的清晰度，方便爬虫工具识别网站内容，爬虫工具在识别网站内容时不会受到网站样式的影响，只会关注网站内容本身
HTML的语义化能够提高团队对网站的维护和改进效率
改善网页的可访问性，遇到视觉障碍用户时屏幕阅读器能够更好的系别网页内容

***
## iframe有那些缺点？

  * iframe会阻塞主页面的Onload事件；
  * 搜索引擎的检索程序无法解读这种页面，不利于SEO;

  * iframe和主页面共享连接池，而浏览器对相同域的连接有限制，所以会影响页面的并行加载。

  使用iframe之前需要考虑这两个缺点。如果需要使用iframe，最好是通过javascript
  动态给iframe添加src属性值，这样可以绕开以上两个问题。
***

## 为什么要初始化CSS样式。
- 因为浏览器的兼容问题，不同浏览器对有些标签的默认值是不同的，如果没对CSS初始化往往会出现浏览器之间的页面显示差异。

  - 当然，初始化样式会对SEO有一定的影响，但鱼和熊掌不可兼得，但力求影响最小的情况下初始化。
淘宝的样式初始化代码：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">body, h1, h2, h3, h4, h5, h6, hr, p, blockquote, dl, dt, dd, ul, ol, li, pre, form, fieldset, legend, button, input, textarea, th, td &#123; margin:0; padding:0; &#125;</span><br><span class="line">body, button, input, select, textarea &#123; font:12px/1.5tahoma, arial, \5b8b\4f53; &#125;</span><br><span class="line">h1, h2, h3, h4, h5, h6&#123; font-size:100%; &#125;</span><br><span class="line">address, cite, dfn, em, var &#123; font-style:normal; &#125;</span><br><span class="line">code, kbd, pre, samp &#123; font-family:couriernew, courier, monospace; &#125;</span><br><span class="line">small&#123; font-size:12px; &#125;</span><br><span class="line">ul, ol &#123; list-style:none; &#125;</span><br><span class="line">a &#123; text-decoration:none; &#125;</span><br><span class="line">a:hover &#123; text-decoration:underline; &#125;</span><br><span class="line">sup &#123; vertical-align:text-top; &#125;</span><br><span class="line">sub&#123; vertical-align:text-bottom; &#125;</span><br><span class="line">legend &#123; color:#000; &#125;</span><br><span class="line">fieldset, img &#123; border:0; &#125;</span><br><span class="line">button, input, select, textarea &#123; font-size:100%; &#125;</span><br><span class="line">table &#123; border-collapse:collapse; border-spacing:0; &#125;</span><br></pre></td></tr></table></figure>

## 用纯CSS创建一个三角形的原理是什么？
 把上、左、右三条边隐藏掉（颜色设为 transparent）

>  #demo {
    width: 0;
    height: 0;
    border-width: 20px;
    border-style: solid;
    border-color: transparent transparent red transparent;
  }
***
## 经常遇到的浏览器的兼容性有哪些？原因，解决方法是什么，常用hack的技巧 ？
 * png24位的图片在iE6浏览器上出现背景，解决方案是做成PNG8.

  * 浏览器默认的margin和padding不同。解决方案是加一个全局的*{margin:0;padding:0;}来统一。

  * IE6双边距bug:块属性标签float后，又有横行的margin情况下，在ie6显示margin比设置的大。

    浮动ie产生的双倍距离 #box{ float:left; width:10px; margin:0 0 0 100px;}

    这种情况之下IE会产生20px的距离，解决方案是在float的标签样式控制中加入 ——_display:inline;将其转化为行内属性。(_这个符号只有ie6会识别)

    渐进识别的方式，从总体中逐渐排除局部。

    首先，巧妙的使用“\9”这一标记，将IE游览器从所有情况中分离出来。
    接着，再次使用“+”将IE8和IE7、IE6分离开来，这样IE8已经独立识别。

    css
        .bb{
            background-color:red;/*所有识别*/
            background-color:#00deff\9; /*IE6、7、8识别*/
            +background-color:#a200ff;/*IE6、7识别*/
            _background-color:#1e0bd1;/*IE6识别*/
        }


  *  IE下,可以使用获取常规属性的方法来获取自定义属性,
     也可以使用getAttribute()获取自定义属性;
     Firefox下,只能使用getAttribute()获取自定义属性。
     解决方法:统一通过getAttribute()获取自定义属性。

  *  IE下,even对象有x,y属性,但是没有pageX,pageY属性;
     Firefox下,event对象有pageX,pageY属性,但是没有x,y属性。

  *  解决方法：（条件注释）缺点是在IE浏览器下可能会增加额外的HTTP请求数。

  *  Chrome 中文界面下默认会将小于 12px 的文本强制按照 12px 显示,
     可通过加入 CSS 属性 -webkit-text-size-adjust: none; 解决。

  超链接访问过后hover样式就不出现了 被点击访问过的超链接样式不在具有hover和active了解决方法是改变CSS属性的排列顺序:
  L-V-H-A :  a:link {} a:visited {} a:hover {} a:active {}
***
## 什么是外边距合并？
外边距合并指的是，当两个垂直外边距相遇时，它们将形成一个外边距。
  合并后的外边距的高度等于两个发生合并的外边距的高度中的较大者。
  w3school介绍网址： http://www.w3school.com.cn/css/css_margin_collapsing.asp
***
## zoom:1的清除浮动原理?
清除浮动，触发hasLayout；
  Zoom属性是IE浏览器的专有属性，它可以设置或检索对象的缩放比例。解决ie下比较奇葩的bug。
  譬如外边距（margin）的重叠，浮动清除，触发ie的haslayout属性等。

  来龙去脉大概如下：
  当设置了zoom的值之后，所设置的元素就会就会扩大或者缩小，高度宽度就会重新计算了，这里一旦改变zoom值时其实也会发生重新渲染，运用这个原理，也就解决了ie下子元素浮动时候父元素不随着自动扩大的问题。

  Zoom属是IE浏览器的专有属性，火狐和老版本的webkit核心的浏览器都不支持这个属性。然而，zoom现在已经被逐步标准化，出现在 CSS 3.0 规范草案中。

  目前非ie由于不支持这个属性，它们又是通过什么属性来实现元素的缩放呢？
  可以通过css3里面的动画属性scale进行缩放。 
  ***
## 如何居中div？

水平居中：给div设置一个宽度，然后添加margin:0 auto属性

 div{
     width:200px;
     margin:0 auto;
  }
让绝对定位的div居中

 div {
     position: absolute;
     width: 300px;
     height: 300px;
     margin: auto;
     top: 0;
     left: 0;
     bottom: 0;
     right: 0;
     background-color: pink;    /* 方便看效果 */
 }

水平垂直居中一

 确定容器的宽高 宽500 高 300 的层
 设置层的外边距

 div {
     position: relative;        /* 相对定位或绝对定位均可 */
     width:500px;
     height:300px;
     top: 50%;
     left: 50%;
     margin: -150px 0 0 -250px;         /* 外边距为自身宽高的一半 */
     background-color: pink;         /* 方便看效果 */

  }

水平垂直居中二

 未知容器的宽高，利用 `transform` 属性

 div {
     position: absolute;        /* 相对定位或绝对定位均可 */
     width:500px;
     height:300px;
     top: 50%;
     left: 50%;
     transform: translate(-50%, -50%);
     background-color: pink;         /* 方便看效果 */

 }

水平垂直居中三

 利用 flex 布局
 实际使用时应考虑兼容性

 .container {
     display: flex;
     align-items: center;         /* 垂直居中 */
     justify-content: center;    /* 水平居中 */

 }
 .container div {
     width: 100px;
     height: 100px;
     background-color: pink;        /* 方便看效果 */
 } 
## position的值relative和absolute定位原点是？

    absolute
      生成绝对定位的元素，相对于值不为 static的第一个父元素进行定位。
    fixed （老IE不支持）
      生成绝对定位的元素，相对于浏览器窗口进行定位。
    relative
      生成相对定位的元素，相对于其正常位置进行定位。
    static
      默认值。没有定位，元素出现在正常的流中（忽略 top, bottom, left, right z-index 声明）。
    inherit
      规定从父元素继承 position 属性的值。
***

# HTML5
## 新特性
### 1:标签语义化，
比如header，footer，nav，aside，article，section等，新增了很多表单元素，入email，url等，除去了center等样式标签，还有除去了有性能问题的frame，frameset等标签

### 2、音视频元素，
video，audio的增加使得我们不需要在依赖外部的插件就可以往网页中加入音视频元素。

### 3、新增很多api，
比如获取用户地理位置的window.navigator.geoloaction

### 、websocket
websocket是伴随html5到来的基于tcp/ip的全双工通信的协议。
主要通信过程：先借http完成握手，达到了长连接
第一步：浏览器基于tcp，发送http请求
第二步：服务器端，接收到请求后。将 tcp用户网络层协议变为websocket协议，完成了握手
第三步：服务器端和浏览器完成握手，他们之间形成一条通道，可以源源不断的传送信息
websocket是一种协议，可以让我们建立客户端到服务器端的全双工通信，这就意味着服务器端可以主动推送数据到客户端。
***
### 、HTML5 能够本地存储数据，在之前都是使用 cookies 使用的。
HTML5 提供了下面本地存储方案：webstorage包括localeStorage和sessionStorage，localeStorage是持久化存储在客户端，只要用户不主动删除，就不会消失，sessionStorage也是存储在客户端，但是他的存在时间是一个回话，一旦浏览器的关于该回话的页面关闭了，sessionStorage就消失了，
***
### ：请描述一下 cookies，sessionStorage 和 localStorage 的区别？
  cookie是网站为了标示用户身份而储存在客户端上的数据（通常经过加密）。
  cookie数据始终在同源的http请求中携带（即使不需要），记会在浏览器和服务器间来回传递。
  sessionStorage和localStorage不会自动把数据发给服务器，仅在本地保存。

  存储大小：
      cookie数据大小不能超过4k。
      sessionStorage和localStorage 虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大。

  有期时间：
      localStorage    存储持久数据，浏览器关闭后数据不丢失除非主动删除数据；
      sessionStorage  数据在当前浏览器窗口关闭后自动删除。
      cookie  在过期时间之前一直有效，即使窗口或浏览器关闭
## 具体应用
### cookie:
document.cookie = name, value, expires, domain, path, secure
encodeURIComponent
decodeURIComponent(document.cookie.substring(cookieStart + cookieName.length, cookieEnd)
### localStoragey用法
localStorage储存的值都是字符串类型，使用时要注意。另外，可以在浏览器调试器中的Resources的localStorage中看到储存的信息。
>//存储信息   （存储的信息名称，要存储的字符串）
storage = window.localStorage
storage.setItem("CC_email_list",input_eamil[i])
//读取信息   （要读取的信息名称）
storage.getItem("CC_email_list")
//清除信息    （要清除的信息名称）
storage.removeItem("CC_email_list");
storage.clear();
### sessionStorage:
sessionStorage用法和localStorage完全一致，差别只在有效期：

***

### 1.什么是cookie？
    答：cookie是用于在客户端存储会话信息的。
### 4.如何操作cookie？
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">var CookieUtil = &#123;</span><br><span class="line">    // 设置cookie</span><br><span class="line">    set : function (name, value, expires, domain, path, secure) &#123;</span><br><span class="line">        var cookieText = &quot;&quot;;</span><br><span class="line">        cookieText += encodeURIComponent(name) + &quot;=&quot; + encodeURIComponent(value);</span><br><span class="line">        if (expires instanceof Date) &#123;</span><br><span class="line">            cookieText += &quot;; expires=&quot; + expires.toGMTString();</span><br><span class="line">        &#125;</span><br><span class="line">        if (path) &#123;</span><br><span class="line">            cookieText += &quot;; path=&quot; + path;</span><br><span class="line">        &#125;</span><br><span class="line">        if (domain) &#123;</span><br><span class="line">            cookieText += &quot;; domain=&quot; + domain;</span><br><span class="line">        &#125;</span><br><span class="line">        if (secure) &#123;</span><br><span class="line">            cookieText += &quot;; secure&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        document.cookie = cookieText;</span><br><span class="line">    &#125;,</span><br><span class="line">    // name=value; expires=expiration_time; path=domain_path; domain=domain_name; secure</span><br><span class="line">    // 获取cookie</span><br><span class="line">    get : function (name) &#123;</span><br><span class="line">        var cookieName = encodeURIComponent(name) + &quot;=&quot;,</span><br><span class="line">            cookieStart = document.cookie.indexOf(cookieName),</span><br><span class="line">            cookieValue = &quot;&quot;;</span><br><span class="line">        if (cookieStart &gt; -1) &#123;</span><br><span class="line">            var cookieEnd = document.cookie.indexOf (&quot;;&quot;, cookieStart);</span><br><span class="line">            if (cookieEnd == -1) &#123;</span><br><span class="line">                cookieEnd = document.cookie.length;</span><br><span class="line">            &#125;</span><br><span class="line">            cookieValue = decodeURIComponent(document.cookie.substring(cookieStart + cookieName.length, cookieEnd));</span><br><span class="line">        &#125;</span><br><span class="line">        return cookieValue; </span><br><span class="line">    &#125;,</span><br><span class="line">    // 删除cookie</span><br><span class="line">    unset : function (name, domain, path, secure) &#123;</span><br><span class="line">        this.set(name, &quot;&quot;, Date(0), domain, path, secure);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">// 测试</span><br><span class="line">CookieUtil.set(&quot;name&quot;, &quot;zhang&quot;);</span><br><span class="line">var name = CookieUtil.get(&quot;name&quot;);</span><br><span class="line">alert(name);    // zhang</span><br><span class="line">CookieUtil.unset(&quot;name&quot;);</span><br><span class="line">alert(CookieUtil.get(&quot;name&quot;));  // 空</span><br></pre></td></tr></table></figure>

### 2.cookie的组成部分？
    ①名称：一个唯一确定cookie 的名称。建议区分大小写。cookie 的名称必须是经过URL 编码的。
    ②值：储存在cookie 中的字符串值。值必须被URL 编码。
    ③域：cookie 对于哪个域是有效的。所有向该域发送的请求中都会包含这个cookie 信息。这个值可以包含子域（subdomain，如www.wrox.com），也可以不包含它（如.wrox.com，则对于wrox.com的所有子域都有效）。如果没有明确设定，那么这个域会被认作来自设置cookie 的那个域。
    ④路径：对于指定域中的那个路径，应该向服务器发送cookie。例如，你可以指定cookie 只有从http://www.wrox.com/books/ 中才能访问，那么http://www.wrox.com 的页面就不会发送cookie 信息，即使请求都是来自同一个域的。
    ⑤失效时间：表示cookie 何时应该被删除的时间戳。默认情况下，浏览器会话结束时即将所有cookie 删除；不过也可以自己设置删除时间。这个值是个GMT 格式的日期（Wdy, DD-Mon-YYYY HH:MM:SS GMT），用于指定应该删除cookie 的准确时间。因此，cookie 
    可在浏览器关闭后依然保存在用户的机器上。如果你设置的失效日期是个以前的时间，则cookie 会被立刻删除。
    ⑥安全标志：指定后，cookie 只有在使用SSL 连接的时候才发送到服务器。例如，cookie 信息只能发送给https://www.wrox.com，而http://www.wrox.com 的请求则不能发送cookie。
### 3.列举一个cookie的例子？
    以下是一个完整的cookie的例子，我们将把它分解开来：
    Set-Cookie: name=value; expires=Mon, 22-Jan-07 07:10:24 GMT; domain=.wrox.com; path=/; secure
    ①名称: name字符串表示
    ②值：value字符串表示
    ③过期时间：Mon, 22-Jan-07 07:10:24 GMT
    ④域名：.wrox.com
    ⑤路径：当前目录/
    ⑥安全标志：secure
***
### 、应用程序缓存：
在用户没有与因特网连接时，可以正常访问站点或应用，在用户与因特网连接时，更新用户机器上的缓存文件。
  原理：HTML5的离线存储是基于一个新建的.appcache文件的缓存机制(不是存储技术)，通过这个文件上的解析清单离线存储资源，这些资源就会像cookie一样被存储了下来。之后当网络在处于离线状态下时，浏览器会通过被离线存储的数据进行页面展示。

html5允许我们自己控制哪些文件需要缓存，哪些不需要，具体的做法如下：

1、首先给html添加manifest属性，并赋值为cache.manifest
2、cache.manifest的内容为: 
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">  CACHE MANIFEST</span><br><span class="line">  #v1.2</span><br><span class="line">  CACHE :           //表示需要缓存的文件</span><br><span class="line">    a.js</span><br><span class="line">    b.js</span><br><span class="line">NETWORK:    //表示只在用户在线的时候才需要的文件，不会缓存</span><br><span class="line">  c.js</span><br><span class="line">FALLBACK</span><br><span class="line">/        /index.html     //表示如果找不到第一个资源就用第二个资源代替</span><br></pre></td></tr></table></figure>

***
### 、web worker，web worker
是运行在浏览器后台的js程序，他不影响主程序的运行，是另开的一个js线程，可以用这个线程执行复杂的数据操作，然后把操作结果通过postMessage传递给主线程，这样在进行复杂且耗时的操作时就不会阻塞主线程了。
***
### 标签页的通信
localstorge在一个标签页里被添加、修改或删除时，都会触发一个storage事件，通过在另一个标签页里监听storage事件，即可得到localstorge存储的值，实现不同标签页之间的通信。
标签页1：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;input id=&quot;name&quot;&gt;  </span><br><span class="line">&lt;input type=&quot;button&quot; id=&quot;btn&quot; value=&quot;提交&quot;&gt;  </span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;  </span><br><span class="line">    $(function()&#123;    </span><br><span class="line">        $(&quot;#btn&quot;).click(function()&#123;    </span><br><span class="line">            var name=$(&quot;#name&quot;).val();    </span><br><span class="line">            localStorage.setItem(&quot;name&quot;, name);   </span><br><span class="line">        &#125;);    </span><br><span class="line">    &#125;);    </span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

标签页2：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;  </span><br><span class="line">    $(function()&#123;   </span><br><span class="line">        window.addEventListener(&quot;storage&quot;, function(event)&#123;    </span><br><span class="line">            console.log(event.key + &quot;=&quot; + event.newValue);    </span><br><span class="line">        &#125;);     </span><br><span class="line">    &#125;);  </span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

使用cookie+setInterval，将要传递的信息存储在cookie中，每隔一定时间读取cookie信息，即可随时获取要传递的信息。
标签页1： 
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;input id=&quot;name&quot;&gt;  </span><br><span class="line">&lt;input type=&quot;button&quot; id=&quot;btn&quot; value=&quot;提交&quot;&gt;  </span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;  </span><br><span class="line">    $(function()&#123;    </span><br><span class="line">        $(&quot;#btn&quot;).click(function()&#123;    </span><br><span class="line">            var name=$(&quot;#name&quot;).val();    </span><br><span class="line">            document.cookie=&quot;name=&quot;+name;    </span><br><span class="line">        &#125;);    </span><br><span class="line">    &#125;);    </span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

标签页2：  
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;  </span><br><span class="line">    $(function()&#123;   </span><br><span class="line">        function getCookie(key) &#123;    </span><br><span class="line">            return JSON.parse(&quot;&#123;\&quot;&quot; + document.cookie.replace(/;\s+/gim,&quot;\&quot;,\&quot;&quot;).replace(/=/gim, &quot;\&quot;:\&quot;&quot;) + &quot;\&quot;&#125;&quot;)[key];    </span><br><span class="line">        &#125;     </span><br><span class="line">        setInterval(function()&#123;    </span><br><span class="line">            console.log(&quot;name=&quot; + getCookie(&quot;name&quot;));    </span><br><span class="line">        &#125;, 10000);    </span><br><span class="line">    &#125;);  </span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

# 重排重绘
## 浏览器从下载文档到显示页面的过程
  * 浏览器引擎会解析HTML文档来构建DOM树
  * 根据DOM元素的几何属性构建一棵用于渲染的树
渲染树的每个节点都有大小和边距等属性，类似于盒子模型（由于隐藏元素不需要显示，渲染树中并不包含DOM树中隐藏的元素）。当渲染树构建完成后，浏览器就可以将元素放置到正确的位置了
  * 根据渲染树节点的样式属性绘制出页面。
## 重绘redraw
重绘是一个元素外观的改变所触发的浏览器行为，例如改变visibility、背景色等属性。浏览器会根据元素的新属性重新绘制，使元素呈现新的外观。
重绘不会带来重新布局，并不一定伴随重排。
## 重排
重排是几何上的改变，可以理解为渲染树需要重新计算。
###  触发重排：
   * 1.DOM元素的几何属性变化（定位，位置）
      * 渲染树中的相关节点就会失效，重新构建渲染树中失效的节点，根据新的渲染树重新绘制这部分页面
       * 例如：动画
       * 一个元素重排可能会使其他元素重排重绘
    * 2.DOM树的结构变化（dom增删，移动）
        * 例如节点的增减、移动等，也会触发重排
     * 3.获取某些属性（offsetWidth和offsetHeight）
　浏览器引擎可能会针对重排做了优化。比如Opera，它会等到有足够数量的变化发生，或者等到一定的时间，或者等一个线程结束，再一起处理，这样就只发生一次重排。但除了渲染树的直接变化，当获取一些属性时，浏览器为取得正确的值也会触发重排。这样就使得浏览器的优化失效了。这些属性包括：offsetTop、offsetLeft、 offsetWidth、offsetHeight、scrollTop、scrollLeft、scrollWidth、scrollHeight、clientTop、clientLeft、clientWidth、clientHeight、getComputedStyle() (currentStyle in IE)。
所以，在多次使用这些值时应进行缓存。

### 减少重排
 * 将多次改变样式属性封装成一个类，用js加上类
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">div.changeDiv &#123;</span><br><span class="line">background: #eee;</span><br><span class="line">color: #093;</span><br><span class="line">height: 200px;</span><br><span class="line">&#125;</span><br><span class="line">document.getElementById(‘changeDiv’).className = ‘changeDiv’;</span><br></pre></td></tr></table></figure>

   * 将需要多次重排的元素，position属性设为absolute或fixed
这样此元素就脱离了文档流，它的变化不会影响到其他元素。例如有动画效果的元素就最好设置为绝对定位。
* 最小化DOM深度
减少你的DOM树的大小和每个分支的元素数量。你的文档越小，越浅，重排就会越快。如果你不支持旧版的浏览器，可能你要移除不需要的包裹元素。
* 保证n次创建，1次写入。
例如要异步获取表格数据，渲染到页面。可以先取得数据后在内存中构建整个表格的html片段，再一次性添加到文档中去，而不是循环添加每一行。
* dom 复杂操作时，先隐藏，再显示
由于display属性为none的元素不在渲染树中，对隐藏的元素操作不会引发其他元素的重排。如果要对一个元素进行复杂的操作时，可以先隐藏它，操作完成后再显示。这样只在隐藏和显示时触发2次重排。
* 
在多次使用这些值时应进行缓存。
## 表格排序考虑到减少重排重绘
保证n次创建，1次写入。

***
# CSS3
## css3的新特性哪些，你都用过哪些 5%
CSS3有哪些新内容，请至少说出5个。

   1）border-radius。CSS3圆角表格

   2）font-effect。以往对网页上的文字加特效只能用filter属性，但是在CSS3中专门制定了一个加文字特效的属性，而且不止加阴影这种效果。

   3）text-underline-style，text-underline-color，text-underline-mode，text-underline-position。丰富了对链接下划线的样式，以往的下划线都是直线，这次可不一样了，有波浪线、点线、虚线等等，更可对下划线的颜色和
位置进行任意改变，哈哈~~下划线的世界从此不再单一。（还有对应顶线和中横线的样式，效果与下划线类似）

   4）font-emphasize-style和font-emphasize-position。我们在做笔记时经常要在文字下点几个点或打个圈什么的，以示重点，CSS3也开始加入了这项功能，这应该在某些特定网页上很有用。

   5）Font-face可以用来加载字体样式，而且它还能够加载服务器端的字体文件，显示客户端没有安装的字体。
***
## 媒体查询具体到语句 5%
作用：媒体查询可以让我们根据设备显示器的特性（如视口宽度、屏幕比例、设备方向：横向或纵向）为其设定CSS样式，检测的媒体特性有 width 、 height 和 color （等）。

##  响应式布局meta,scale 怎样使用media?
### meta,scale
第一步：
 首先需要在html文档中添加以下代码，用来兼容移动设备的显示效果
<meta name="viewport content=" width="device-width,initial-scale=1,maximum-scale=1,user-scalable=no"/">

<p>ps:</p>
<blockquote>
<p>width=device-width:宽度等于当前设备的宽度<br>initial-scale=1：初始的缩放比例（默认为1）<br>maximum-scale=1：允许用户缩放到得最大比例（默认为1）<br>user-scalable=no：用户不能手动缩放</p>
</blockquote>
<h3 id="第二步：媒体查询-语句"><a href="#第二步：媒体查询-语句" class="headerlink" title="第二步：媒体查询 语句"></a>第二步：媒体查询 语句</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@media screen and (max-width:720px) and (min-width:320px)&#123;</span><br><span class="line"></span><br><span class="line">      body&#123;</span><br><span class="line"></span><br><span class="line">       background-color:red;</span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">@media screen and (max-width:320px)&#123;</span><br><span class="line"></span><br><span class="line">      body&#123;</span><br><span class="line"></span><br><span class="line">         background-color:blue;</span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="css-伪类-5"><a href="#css-伪类-5" class="headerlink" title="css 伪类 5%"></a>css 伪类 5%</h2><h3 id="伪类选择器"><a href="#伪类选择器" class="headerlink" title="伪类选择器"></a>伪类选择器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">p:first-of-type	选择属于其父元素的首个 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。</span><br><span class="line">p:last-of-type	选择属于其父元素的最后 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。</span><br><span class="line">p:only-of-type	选择属于其父元素唯一的 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。</span><br><span class="line">p:only-child		选择属于其父元素的唯一子元素的每个 &lt;p&gt; 元素。</span><br><span class="line">p:nth-child(2)	选择属于其父元素的第二个子元素的每个 &lt;p&gt; 元素。</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="伪类-伪元素-1"><a href="#伪类-伪元素-1" class="headerlink" title="伪类 伪元素"></a>伪类 伪元素</h3><p>伪类是给元素模拟添加类 ，来实现某种效果（：）<br>常见伪类：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2377897-394530a71e54ed9f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<p>伪元素是模拟添加个元素来实现效果（::）(css3出现后做的区分)<br>常见伪元素：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2377897-e655b83124da94d9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<p><a href="http://web.jobbole.com/86181/" target="_blank" rel="external">http://web.jobbole.com/86181/</a></p>
<h2 id="说一下flex-3"><a href="#说一下flex-3" class="headerlink" title="说一下flex 3%"></a>说一下flex 3%</h2><h3 id="请解释一下CSS3的Flexbox（弹性盒布局模型）-以及适用场景？"><a href="#请解释一下CSS3的Flexbox（弹性盒布局模型）-以及适用场景？" class="headerlink" title="请解释一下CSS3的Flexbox（弹性盒布局模型）,以及适用场景？"></a>请解释一下CSS3的Flexbox（弹性盒布局模型）,以及适用场景？</h3><p> 一个用于页面布局的全新CSS3功能，Flexbox可以把列表放在同一个方向（从上到下排列，从左到右），并让列表能延伸到占用可用的空间。<br>   较为复杂的布局还可以通过嵌套一个伸缩容器（flex container）来实现。<br>   采用Flex布局的元素，称为Flex容器（flex container），简称”容器”。<br>   它的所有子元素自动成为容器成员，称为Flex项目（flex item），简称”项目”。<br>   常规布局是基于块和内联流方向，而Flex布局是基于flex-flow流可以很方便的用来做局中，能对不同屏幕大小自适应。<br>   在布局上有了比以前更加灵活的空间<br><a href="http://www.w3cplus.com/css3/flexbox-basics.html" target="_blank" rel="external">http://www.w3cplus.com/css3/flexbox-basics.html</a></p>
<hr>
<h2 id="动画-2"><a href="#动画-2" class="headerlink" title="动画 2%"></a>动画 2%</h2><p>  二维动画——animation  这个属性必须配合@keyframes动画关键帧来使用。keyframes里面包含一个百分数，后面跟上在这段时间内变换的css样式。<br>     animation是一个复合属性，它包括以下几个组成部分：</p>
<ul>
<li>1.animation-name：执行动画的keyframes的名字。<ul>
<li>2.animation-duration：执行动画的总时长。</li>
<li>3.animation-timing-function：指定过渡函数。</li>
<li>4.animation-delay：执行延迟时间。</li>
<li>5.animation-direction：动画播放的方式。这个属性的值主要有：normal正常播放模式、reverse倒序播放、alternate<pre><code>动画在奇数次正向播放偶数次倒序播放、alternate-reverse动画在奇数次倒序播放偶数次正向播放。
</code></pre></li>
<li>6.animation-iteration-count：动画执行的次数。infinite是无限次，写一个数字就是要执行几次。<ul>
<li>7.animation-fill-mode：执行完动画后物体停止的位置。forwards是停在结束的位置上、backwards是快速执行初始帧<pre><code>（这个最好配合延迟来观察）、
none是回到初始帧的位置、both是同时具有forwards和backwards的效果。
</code></pre></li>
<li>8.animation-play-state：控制动画的播放状态。running是播放、paused是暂停。</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h2 id="css3动画卡了"><a href="#css3动画卡了" class="headerlink" title="css3动画卡了"></a>css3动画卡了</h2><pre><code>transform: transition3d(0, 0, 0);
transform: translateZ(0);
这两个属性可以开启GPU加速模式
然而面试官问我为什么，你知道原理么？
这两个属性都会开启GPU硬件加速模式，从而让浏览器在渲染动画的时候从CPU转向GPU。
</code></pre><hr>
<h1 id="移动端"><a href="#移动端" class="headerlink" title="移动端"></a>移动端</h1><p><a href="https://www.v2ex.com/t/359985?p=1" target="_blank" rel="external">https://www.v2ex.com/t/359985?p=1</a><br><a href="http://caibaojian.com/vw-vh.html" target="_blank" rel="external">http://caibaojian.com/vw-vh.html</a><br><a href="https://aotu.io/notes/2017/04/28/2017-4-28-CSS-viewport-units/" target="_blank" rel="external">https://aotu.io/notes/2017/04/28/2017-4-28-CSS-viewport-units/</a></p>
<h2 id="移动端适配："><a href="#移动端适配：" class="headerlink" title="移动端适配："></a>移动端适配：</h2><ul>
<li>通常<br>通常使用响应式布局和弹性布局+媒体查询配置多个响应断点<br>缺陷：布局在响应断点范围内的分辨率下维持不变，而在响应断点切换的瞬间，布局带来断层式的切换变化，如同卡带的唱机般“咔咔咔”地一下又一下。</li>
<li>rem单位动态计算<br>rem单位的动态计算的弹性布局，则是需要在头部内嵌一段脚本来进行监听分辨率的变化来动态改变根元素字体大小，使得 CSS 与 JS 耦合了在一起。</li>
<li>vh,vw视口单位实现适配<ul>
<li>优点：既能解决响应式断层问题，又能解觉rem决脚本依赖的问题的。</li>
<li>缺点：由于相对于视口为单位，随着视口增大而增大，失去了最大最小宽度限制</li>
</ul>
</li>
<li>vw+rem<ul>
<li>rem 弹性布局的核心在于动态改变根元素大小，那么我们可以通过：<ul>
<li>给根元素大小设置随着视口变化而变化的 vw 单位，这样就可以实现动态改变其大小。</li>
<li>限制根元素字体大小的最大最小值，配合g body 加上最大宽度和最小宽度</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h2 id="自适应，响应式布局："><a href="#自适应，响应式布局：" class="headerlink" title="自适应，响应式布局："></a>自适应，响应式布局：</h2><ul>
<li><p>设置meta viewport</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">　&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot; /&gt;</span><br><span class="line">目的是：</span><br><span class="line">网页宽度默认等于屏幕宽度（width=device-width）</span><br><span class="line"> ，原始缩放比例（initial-scale=1）为1.0，</span><br><span class="line">即网页初始大小占屏幕面积的100%。</span><br></pre></td></tr></table></figure>
</li>
<li><p>媒体查询</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@media screen and (max-device-width: 400px) &#123;&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>不指定像素宽度<br>宽度定百分比或者width:auto</p>
</li>
<li><p>相对大小的字体em,rem</p>
</li>
<li><p>流动布局<br>各个区块的位置都是浮动的（float），不是固定不变的,绝对定位的使用也要 非常小心</p>
</li>
</ul>
<hr>
<h2 id="meta-viewport"><a href="#meta-viewport" class="headerlink" title="meta viewport"></a>meta viewport</h2><h3 id="视窗基本属性"><a href="#视窗基本属性" class="headerlink" title="视窗基本属性"></a>视窗基本属性</h3><ul>
<li>width：控制 viewport 的大小，你可以给它指定一个值，如：600，或者甚至还可以给它一个特殊的值，如：device-width，device-width为设备的宽度（单位为缩放为 100% 时的 CSS 的像素）。</li>
<li>height：与 width 相对应，指定viewport 高度。</li>
<li>initial-scale：初始缩放比例，也即是当页面第一次 load 的时候缩放比例。</li>
<li>maximum-scale：允许用户缩放到的最大比例。</li>
<li>minimum-scale：允许用户缩放到的最小比例。</li>
<li>user-scalable：是否允许用户手动缩放。<h3 id="三个视窗"><a href="#三个视窗" class="headerlink" title="三个视窗"></a>三个视窗</h3></li>
<li>布局视窗：css定义的网页内容宽度，网页内容宽度跟移动端浏览器窗口无关</li>
<li>视觉视窗：用户正看的区域window.innerWidth/Height</li>
<li>理想视窗：定义理想视口是浏览器的工作，而不是设备或操作系统的工作。因此，同一设备上的不同浏览器拥有不同的理想视口。screen.width/height返回是理想视口的尺寸<br><a href="http://www.cnblogs.com/xiaohuochai/p/5496995.html" target="_blank" rel="external">三个视窗</a><br><a href="http://yunkus.com/meta-viewport-usage/" target="_blank" rel="external">meta-viewport</a></li>
</ul>
<hr>
<h2 id="媒体查询"><a href="#媒体查询" class="headerlink" title="媒体查询"></a>媒体查询</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@media screen and (max-width:480px)&#123;</span><br><span class="line"> .ads &#123;</span><br><span class="line">   display:none;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">@media screen and (min-width:600px) and (max-width:900px)&#123;</span><br><span class="line">  body &#123;background-color:#f5f5f5;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="flex弹性布局：-1"><a href="#flex弹性布局：-1" class="headerlink" title="flex弹性布局："></a>flex弹性布局：</h2><ul>
<li>flex布局好处？不需要再给子元素设置定位，使用flex属性就可以让浏览器自己计算位置</li>
<li>父块元素：display: flex;</li>
<li>父行级元素：display: inline-flex;</li>
<li>设置了flex布局后，子元素的float、clear和vertical-align属性就会失效</li>
<li>具体描述：<br>设置了 flex的父亲成为：flex容器，孩子成为flex项目<ul>
<li>父亲容器属性：<ul>
<li>flex-direction(孩子横向还是竖向)：row(孩子水平)| row-reverse | column(孩子竖直) | column-reverse;</li>
<li>flex-wrap(孩子换行)：nowrap | wrap | wrap-reverse;</li>
<li>justify-content（孩子对齐方式）: flex-start | flex-end | center | space-between | space-around;</li>
<li>孩子項目屬性：<ul>
<li>order ：属性定义项目的排列顺序。数值越小，排列越靠前，默认为0</li>
<li>flex-basis：属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。</li>
<li>flex-grow：属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大</li>
<li>flex-shrink：属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。</li>
<li>align-self：属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。<br>【问题】：<br>flex弹性盒模型，主轴有几个方向？后代 flex：1代表什么？<br>【答案】：</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>flex-grow:0; 定义弹性盒子项的拉伸因子，即子项分配父项剩余空间的比，默认值为 0flex-shrink:1; 指定了 flex 元素的收缩规则，子项的收缩所占的份数，默认值为1 [ 当所有子项相加的宽度大于父项的宽度，每个子项减少的多出的父项宽度的 1/n ]felx-basis:auto; 指定了 flex 元素在主轴方向上的初始大小，即子项的宽度</p>
<hr>
<h2 id="grid-system-，网格布局，栅格化"><a href="#grid-system-，网格布局，栅格化" class="headerlink" title="grid system ，网格布局，栅格化"></a>grid system ，网格布局，栅格化</h2><p>栅格化？<br><a href="http://www.cnblogs.com/dojo-lzz/p/4621627.html" target="_blank" rel="external">http://www.cnblogs.com/dojo-lzz/p/4621627.html</a><br><a href="http://www.w3cplus.com/css/learncssgrid.html" target="_blank" rel="external">http://www.w3cplus.com/css/learncssgrid.html</a><br>网格布局的好处？<br>规范网页中的版面布局以及信息分布，让网页设计不再无规律可循。<br>有规律的网页设计，可以为网页前端开发带来很多便利。<br>栅格化主要好处是：快速开发、提高整站布局的一致性。<br>缺点：灵活性可能稍嫌不足。但我觉得，划分 12 栏的网格系统其实也已具有较大的灵活性了。<br><a href="http://www.chinaz.com/design/2009/0527/77426.shtml" target="_blank" rel="external">http://www.chinaz.com/design/2009/0527/77426.shtml</a></p>
<ul>
<li>创建网格容器<br>display: grid/inline-grid<br>网格项目默认纵项排列</li>
<li>设置网格项目的高或者宽<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">grid-template-columns/rows: 10px;</span><br><span class="line">grid-template-columns: 1fr 1fr 2fr;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h2 id="px-em-rem，-的区别"><a href="#px-em-rem，-的区别" class="headerlink" title="px,em,rem，%的区别?"></a>px,em,rem，%的区别?</h2><ul>
<li>px<br>相对屏幕分辨率</li>
<li><p>em</p>
<ul>
<li>若自身定义了font-size，按照自身算</li>
<li>自身没定义就按照父元素算</li>
<li>em的值并不是固定的</li>
<li>具体使用方案：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">   body选择器中声明Font-size=62.5%；</span><br><span class="line">   16px*62.5% = 10px</span><br><span class="line">    1em = 10px; </span><br><span class="line">    IE浏览器:Font-size=63%</span><br><span class="line">   将你的原来的px数值除以10，然后换上em作为单位；</span><br><span class="line"></span><br><span class="line">重新计算那些被放大的字体的em数值。避免字体大小的重复声明。如：行高、字体大小。</span><br><span class="line">缺陷：整个页面内1em不是一个固定的值，设置em要知道父元素font-size</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>rem </p>
<ul>
<li>相对于html根元素来算，免字体大小逐层复合</li>
<li>除了IE8及更早版本外，所有浏览器均已支持rem</li>
</ul>
</li>
<li>百分比<ul>
<li>相对于父元素的百分比</li>
<li>使用：如果是随着父容器或者是整体页面布局而改变尺寸，则使用百分比更好，如元素的高度和宽度设置。</li>
</ul>
</li>
</ul>
<hr>
<h2 id="知道css新属性-vw-vh-？【4】"><a href="#知道css新属性-vw-vh-？【4】" class="headerlink" title="知道css新属性 vw vh ？【4】"></a>知道css新属性 vw vh ？【4】</h2><ul>
<li>定义<ul>
<li>css3的新单位</li>
<li>css3引入的”vw”和”vh”基于宽度/高度相对于窗口大小</li>
<li>”vw”=”view width”, “vh”=”view height”; </li>
<li>相对于浏览器窗口的大小定义的最佳方式</li>
<li>字体大小会随着你窗口改变而改变</li>
</ul>
</li>
<li>应用<br>根据<a href="https://drafts.csswg.org/css-values-3/#viewport-relative-lengths" target="_blank" rel="external">CSS3规范</a>，视口单位主要包括以下4个：·<br>vw : 1vw 等于视口宽度的1%<br>vh : 1vh 等于视口高度的1%<br>vmin : 选取 vw 和 vh 中最小的那个<br>vmax : 选取 vw 和 vh 中最大的那个<br>视口单位区别于%单位，视口单位是依赖于视口的尺寸，根据视口尺寸的百分比来定义的；而%单位则是依赖于元素的祖先元素。</li>
<li>兼容性<br>兼容主流浏览,IE兼容IE10</li>
</ul>
<hr>
<h2 id="设备像素物理像素？"><a href="#设备像素物理像素？" class="headerlink" title="设备像素物理像素？"></a>设备像素物理像素？</h2><h3 id="设备像素-物理像素"><a href="#设备像素-物理像素" class="headerlink" title="设备像素(物理像素)"></a>设备像素(物理像素)</h3><p>又叫 物理像素，设备能控制显示的最小单位，</p>
<h3 id="设备独立像素（css像素）"><a href="#设备独立像素（css像素）" class="headerlink" title="设备独立像素（css像素）"></a>设备独立像素（css像素）</h3><ul>
<li>独立于设备的用于逻辑衡量像素的单位。平时用的虚拟像素，但不是屏幕分辨率。</li>
<li>移动端，PC端通过screen.width/height获取的这个值是设备独立像素（CSS 像素），而不是设备的屏幕分辨率，因为设备的屏幕分辨率对于WEB开发者来说是无法通过代码来获得的，是完全透明的。 <h3 id="物理像素与设备独立像素"><a href="#物理像素与设备独立像素" class="headerlink" title="物理像素与设备独立像素"></a>物理像素与设备独立像素</h3></li>
<li>在PC端浏览器默认情况下（100%，即页面没被缩放），一个物理像素 = 一个设备独立像素</li>
<li>在移动端时候，一般物理像素与设备独立像素不相等，有一定的换算关系。<br>设备像素比 = 物理像素/设备独立像素（在某个方向上）</li>
<li>获取设备像素比 : window.devicePixelRatio<h3 id="PPI"><a href="#PPI" class="headerlink" title="PPI"></a>PPI</h3>像素密度（pixel density）.<br>全称是（pixel per inch）就是每英寸内有多少个设备像素点.<br>PPI的值越高，画质越好，也就是越细腻，看起来更有逼格。<br>标准的PPI是160, 不过现在屏幕标准的少了, 都超过了160.<br>PPI 值超过300的叫做超高密度屏幕，Apple 给它换了个高大尚的名称：Retina视网膜屏幕</li>
</ul>
<hr>
<p><a href="http://yunkus.com/physical-pixel-device-independent-pixels/" target="_blank" rel="external">设备像素</a><br><a href="http://www.jianshu.com/p/af6dad66e49a" target="_blank" rel="external">物理像素</a></p>
<hr>
<h2 id="用宽确定高，百分比（元素宽度为窗口的多少）"><a href="#用宽确定高，百分比（元素宽度为窗口的多少）" class="headerlink" title="用宽确定高，百分比（元素宽度为窗口的多少）"></a>用宽确定高，百分比（元素宽度为窗口的多少）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1 使用padding，根据宽来定高，注意，元素有内容时，需要去除文本高度</span><br><span class="line">width: 50%;padding: 25% 0;</span><br><span class="line">2使用vw</span><br><span class="line"> width: 50vw;</span><br><span class="line"> height: 50vw;</span><br></pre></td></tr></table></figure>
<h3 id="css一个正方形，宽度是屏幕的一半，水平垂直居中"><a href="#css一个正方形，宽度是屏幕的一半，水平垂直居中" class="headerlink" title="css一个正方形，宽度是屏幕的一半，水平垂直居中"></a>css一个正方形，宽度是屏幕的一半，水平垂直居中</h3><ul>
<li>vw 获取屏幕的width</li>
<li><p>垂直水平居中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">width: 50vw;</span><br><span class="line">height: 50vw;</span><br><span class="line">position: absolute;</span><br><span class="line">left: 50%;</span><br><span class="line">top: 50%;</span><br><span class="line">transform: translate(-50%, -50%);</span><br><span class="line">background: pink;</span><br></pre></td></tr></table></figure>
</li>
<li><p>当元素无内容的时候，padding: 25% 0;可以当作元素的高；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">width: 50%;</span><br><span class="line">padding: 25% 0;</span><br><span class="line">position: absolute;</span><br><span class="line">top: 50%;</span><br><span class="line">left: 50%;</span><br><span class="line">transform: translate(-50%, -50%);</span><br><span class="line">background: red;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h2 id="ul-gt-li列表，小于480时一行显示两个，大于480-lt-960时候一行显示三个"><a href="#ul-gt-li列表，小于480时一行显示两个，大于480-lt-960时候一行显示三个" class="headerlink" title="ul&gt;li列表，小于480时一行显示两个，大于480&lt;960时候一行显示三个"></a>ul&gt;li列表，小于480时一行显示两个，大于480&lt;960时候一行显示三个</h2><ul>
<li>media ,vw,可以弄出元素的宽高<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">@media screen and (max-width:480px) &#123;</span><br><span class="line">           li &#123;</span><br><span class="line">               width: 38vw;</span><br><span class="line">               height: 38vw;</span><br><span class="line">               background: pink;</span><br><span class="line">               float: left;</span><br><span class="line">               margin-left: 1vw;</span><br><span class="line">               margin-bottom: 1vw;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">       @media screen and (min-width:481px)and (max-width:960px) &#123;</span><br><span class="line">           li &#123;</span><br><span class="line">               width: 27vw;</span><br><span class="line">               height: 27vw;</span><br><span class="line">               background: greenyellow;</span><br><span class="line">               float: left;</span><br><span class="line">               margin-left: 1vw;</span><br><span class="line">               margin-bottom: 1vw;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">       @media screen and (min-width:962px) &#123;</span><br><span class="line">           li &#123;</span><br><span class="line">               width: 30vw;</span><br><span class="line">               height: 30vw;</span><br><span class="line">               background: purple;</span><br><span class="line">               float: left;</span><br><span class="line">               margin-left: 1vw;</span><br><span class="line">               margin-bottom: 1vw;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">       ul &#123;</span><br><span class="line">           position: relative;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line"></span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class="line">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, minimum-scale=1, maximum-scale=1, user-scalable=no&quot;&gt;</span><br><span class="line">    &lt;title&gt;响应式&lt;/title&gt;</span><br><span class="line">    &lt;style type=&quot;text/css&quot;&gt;</span><br><span class="line">        @media screen and (max-width:480px) &#123;</span><br><span class="line">            li &#123;</span><br><span class="line">                width: 44%;</span><br><span class="line">                padding: 22% 0;</span><br><span class="line">                background: pink;</span><br><span class="line">                float: left;</span><br><span class="line">                margin-left: 1%;</span><br><span class="line">                margin-bottom: 1%;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        @media screen and (min-width:480px)and (max-width:960px) &#123;</span><br><span class="line">            li &#123;</span><br><span class="line">                width: 30%;</span><br><span class="line">                padding: 15% 0;</span><br><span class="line">                background: green;</span><br><span class="line">                float: left;</span><br><span class="line">                margin-left: 1%;</span><br><span class="line">                margin-bottom: 1%;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        ul &#123;</span><br><span class="line">            position: relative;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        ul&gt;li &#123;</span><br><span class="line">            list-style-type: none;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        @media screen and (min-width:960px) &#123;</span><br><span class="line">            li &#123;</span><br><span class="line">                width: 30%;</span><br><span class="line">                padding: 15% 0;</span><br><span class="line">                background: red;</span><br><span class="line">                float: left;</span><br><span class="line">                margin-left: 1%;</span><br><span class="line">                margin-bottom: 1%;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line"></span><br><span class="line">&lt;/head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div class=&apos;con&apos;&gt;</span><br><span class="line">        &lt;ul&gt;</span><br><span class="line">            &lt;li&gt;1&lt;/li&gt;</span><br><span class="line">            &lt;li&gt;2&lt;/li&gt;</span><br><span class="line">            &lt;li&gt;3&lt;/li&gt;</span><br><span class="line">            &lt;li&gt;4&lt;/li&gt;</span><br><span class="line">            &lt;li&gt;5&lt;/li&gt;</span><br><span class="line">            &lt;li&gt;6&lt;/li&gt;</span><br><span class="line">        &lt;/ul&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="JS"><a href="#JS" class="headerlink" title="JS"></a>JS</h1><h2 id="js数据类型有哪些-5"><a href="#js数据类型有哪些-5" class="headerlink" title="js数据类型有哪些 5%"></a>js数据类型有哪些 5%</h2><p>数据类型分为：简单数据类型和引用<br> (五大)简单数据类型 ：数字 ，字符串 ， 布尔值(true/false)， null，undifined<br>引用：数组，函数，正则表达式，对象</p>
<hr>
<h2 id="null-和undefined"><a href="#null-和undefined" class="headerlink" title="null 和undefined"></a>null 和undefined</h2><p><a href="http://www.ruanyifeng.com/blog/2014/03/undefined-vs-null.html" target="_blank" rel="external">http://www.ruanyifeng.com/blog/2014/03/undefined-vs-null.html</a></p>
<ul>
<li>相似性：<ul>
<li>undefined和null在if语句中，都会被自动转为false<ul>
<li>undefined == null // true</li>
</ul>
</li>
</ul>
</li>
<li>null：<ul>
<li>null表示”没有对象”，即该处不应该有值</li>
<li>用法：<ul>
<li>原型链的终点</li>
<li>作为函数的参数，表示该函数的参数不是对象</li>
</ul>
</li>
</ul>
</li>
<li>undefined<ul>
<li>undefined表示”缺少值”，就是此处应该有一个值，但是还没有定义</li>
<li>典型用法是：<ul>
<li>变量定义了没有赋值</li>
<li>函数应该传递的参数没有传递</li>
<li>对象定义属性没有赋值</li>
<li>函数没有返回值的时候 返回undefined</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h2 id="简单说一下作用域与作用域链-5"><a href="#简单说一下作用域与作用域链-5" class="headerlink" title="简单说一下作用域与作用域链 5%"></a>简单说一下作用域与作用域链 5%</h2><h3 id="作用域和作用域链"><a href="#作用域和作用域链" class="headerlink" title="作用域和作用域链"></a>作用域和作用域链</h3><p>因为当某个函数第一次被调用时候，会创建相应的执行环境和作用域链<br>并把作用域链赋值给内部属性：scope,使用this,arguments和函数的初始参数为活动对象（活动对象就是函数执行上下文中的变量）<br>当在函数中访问变量的时候，需要在作用域链中进行查找，先访问自己的内部的，再访问外部的，再访问外部外部的，直到作用域链的终点：全局执行环境<br>创建函数时，会创建包含函数外部对象的 作用域链，作用域链保存在当前函数的scope中<br>调用函数时，会创建执行环境，创建执行环境的作用域链：是靠复制函数的scope里面的对象<br>作用域链的本质是指向变量对象的指针链表，指引用，不实际包含变量对象</p>
<h3 id="谈一下关于作用域"><a href="#谈一下关于作用域" class="headerlink" title="谈一下关于作用域"></a>谈一下关于作用域</h3><p>  函数里外变量名相同,取函数内部的。Es6 作用域和他一样吗</p>
<ul>
<li>es5函数作用域，作用域链<br>es5只有全局作用域和函数作用域<ul>
<li>作用域<br>作用域指的是变量的作用范围。</li>
<li>作用域链<br>函数内部作用域由函数的参数，局部变量，函数构成。内部作用域和外部的作用域一层层的链接起来形成作用域链。<br>当在函数内部要访问一个变量的时候，首先查找自己的内部作用域有没有这个变量，如果没有就到这个函数所在的外层作用域中找，直到到window所在的作用域。</li>
</ul>
</li>
<li>es6作用域<br>函数内部访问一个变量,由于块级作用域，只能在函数内部查找是否有这个变量，若函数内部没有这个变量还去访问会报错。</li>
</ul>
<hr>
<h2 id="原型-原型链-原型继承（说一下原型-原型链，考了几道题-让你现在作答）-5"><a href="#原型-原型链-原型继承（说一下原型-原型链，考了几道题-让你现在作答）-5" class="headerlink" title="原型 原型链 原型继承（说一下原型 原型链，考了几道题 让你现在作答） 5%"></a>原型 原型链 原型继承（说一下原型 原型链，考了几道题 让你现在作答） 5%</h2><p>请简单说一下原型,原型链，继承</p>
<h3 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h3><ul>
<li>来由：原型是在创建对象时原型模式里提出的概念</li>
<li>定义：创建的每个函数都有一个原型prototype属性，这个属性是一个指针,指向一个对象，这个对象包含着这个函数所有实例可以共享的函数和方法。<br>这个原型对象就是:函数每个原型</li>
<li>优点：可以让所有实例共享原型对象中的属性和方法</li>
<li>缺点：因为共享的特性，实例改写引用类型属性 会更改原型对象属性 使得其他实例属性也改变；还有一个：无法给函数初始化参数</li>
<li>prototype与在构造函数中定义属性和方法有什么区别？<ul>
<li>构造函数中的属性和方法，每个实例都将构造函数中的所有属性创建一遍副本，</li>
<li>缺点：无法共享一套属性 <ul>
<li>优点：每个实例改写属性后互不影响</li>
</ul>
</li>
</ul>
</li>
<li>使用构造函数模式+原型模式创建对象取两者优点<ul>
<li>可传递参数</li>
<li>每个实例都可以利用原型对象共享方法</li>
<li>将引用类型属性放到构造函数中，实例改写后互不影响<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function Person(name, age, job) &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.age = age;</span><br><span class="line">    this.job = job;</span><br><span class="line">    this.friends = [&apos;a&apos;, &apos;b&apos;];</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">    constructor: Person,</span><br><span class="line">    sayName: function() &#123;</span><br><span class="line">        console.log(this.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h3 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h3><ul>
<li>来由：原型链这个概念是在讲继承的时候提出的</li>
<li>定义：原型与实例层层递进构成的链条叫做原型链。某个原型对象等于另一函数的实例:child.prototype = new father()，孩子原型.proto指向父原型，父原型的.proto指向 父原型的原型，直到Object.prototype.proto = null</li>
<li>确定原型和实例的关系<ul>
<li>instance instanceof SubType</li>
<li>father.prototype.isPrototypeOf(child)<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3></li>
</ul>
</li>
<li><p>原型链继承 child.prototype = new father()</p>
<ul>
<li><p>缺点：</p>
<ul>
<li>访问重写父亲引用属性，会更改父原型</li>
<li>创建子类无法给父构造函数传递参数</li>
</ul>
</li>
<li><p>代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">function SuperType() &#123;</span><br><span class="line">    this.property = true;</span><br><span class="line">&#125;</span><br><span class="line">SuperType.prototype.getSuperValue = function() &#123; </span><br><span class="line">    return this.property;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function SubType() &#123;</span><br><span class="line">    this.subproperty = false;</span><br><span class="line">&#125;</span><br><span class="line">//先继承</span><br><span class="line">SubType.prototype = new SuperType(); </span><br><span class="line">//再添加方法</span><br><span class="line">SubType.prototype.getSubValue = function() &#123;</span><br><span class="line">    return this.subproperty;</span><br><span class="line">&#125;</span><br><span class="line">var instance = new SubType(); </span><br><span class="line">console.log(instance.getSuperValue()); //true</span><br><span class="line">//SuperType.prototype : constructor,getSuperValue(),proto</span><br><span class="line">//SubType.prototype : proto, property = true;getSubValue()</span><br><span class="line">// instance : proto , subproperty = false;</span><br><span class="line">//确定原型和实例的关系 instanceof /father.prototype.isPrototypeOf(child)</span><br><span class="line">console.log(instance instanceof SubType);</span><br><span class="line">console.log(instance instanceof SuperType);</span><br><span class="line">console.log(instance instanceof Object);</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>借用构造函数继承/经典继承</p>
<ul>
<li>定义：在子类构造函数中调用父类构造函数 ，子向父类传递参数</li>
<li>子类中Father.apply(this,param)</li>
<li>缺点：无法达到共享或者复用性（构造模式的问题）</li>
<li>优点：可给父类传递参数，副本属性</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function SuperType(name) &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">&#125;  </span><br><span class="line">function SubType() &#123;</span><br><span class="line">    //在子类构造函数中调用父类构造函数 实现了继承 还传递了参数</span><br><span class="line">    SuperType.call(this, &apos;carry&apos;);</span><br><span class="line">    //给子添加 属性</span><br><span class="line">    this.age = 19;</span><br><span class="line">&#125;</span><br><span class="line">var instance = new SubType();</span><br><span class="line">instance.name; //carry</span><br></pre></td></tr></table></figure>
<ul>
<li><p>组合继承（原型链继承+借用构造函数继承）</p>
<ul>
<li>定义：原型链继承(可继承方法：达到共享)+借用构造函数继承(可继承属性：有自己的副本属性)</li>
<li>组合继承是js中最常用的继承方式</li>
<li>优点：属性互不影响，又可以共用方法，两全其美</li>
<li>缺点：要调用两次父类的构造函数，造成了属性副本在子类原型中的多余 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">function SuperType(name) &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.colors = [&apos;green&apos;, &apos;red&apos;];</span><br><span class="line">&#125;</span><br><span class="line">SuperType.prototype.sayName = function() &#123;</span><br><span class="line">    alert(this.name);</span><br><span class="line">&#125;</span><br><span class="line">function SubType(name, age) &#123;</span><br><span class="line">    //继承实例属性</span><br><span class="line">    SuperType.call(this, name);</span><br><span class="line">    this.age = age;</span><br><span class="line">&#125;</span><br><span class="line">//继承父类方法</span><br><span class="line">SubType.prototype = new SuperType();</span><br><span class="line">SubType.prototype.sayAge = function() &#123;</span><br><span class="line">    alert(this.age);</span><br><span class="line">&#125;</span><br><span class="line">var i1 = new SubType(&apos;bill&apos;, 18);</span><br><span class="line">i1.colors.push(&apos;white&apos;);</span><br><span class="line">alert(i1.colors); //&apos;green&apos;, &apos;red&apos;,&apos;white&apos;</span><br><span class="line">i1.sayAge(); //18</span><br><span class="line">i1.sayName(); //bill</span><br><span class="line">var i2 = new SubType(&apos;carry&apos;, 28)</span><br><span class="line">i2.colors; //&apos;green&apos;, &apos;red</span><br><span class="line">i1.sayAge(); //28</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>原型式继承 var childObj = Object.create(fatherObj) //Object.create() = create()  </p>
<ul>
<li>在没有必要兴师动众的创建构造函数的情况下， 只想让两个对象保持差不多一致<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var peron = &#123;</span><br><span class="line">    name: &apos;carry1&apos;,</span><br><span class="line">    friends: [&apos;f1&apos;, &apos;f2&apos;]</span><br><span class="line">&#125;</span><br><span class="line">var np1 = Object.create(peron);</span><br><span class="line">np1.name = &apos;carry2&apos;;</span><br><span class="line">np1.friends.push(&apos;f3&apos;);</span><br><span class="line">var np2 = Object.create(peron, &#123;</span><br><span class="line">    name: &#123;</span><br><span class="line">        value: &apos;carry3&apos;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">console.log(np2.name); //carry3</span><br><span class="line">peron.friends; //f1,f2,f3</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>寄生式继承</p>
<ul>
<li>封装一个仅仅用于实现继承过程的函数 该函数 完成继承操作 然后返回子对象.</li>
<li>寄生式继承就是利用原型式继承的中Object.create(fatherObj)原理实现实例属性的继承，但是又可以在clone函数中定义自己的方法<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function createClone(father) &#123;</span><br><span class="line">    var clone = Object.create(father);</span><br><span class="line">    clone.sayHi = function() &#123;</span><br><span class="line">        alert(&apos;i am clone&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">    return clone;</span><br><span class="line">&#125;</span><br><span class="line">var peron = &#123;</span><br><span class="line">    name: &apos;carry1&apos;,</span><br><span class="line">    friends: [&apos;f1&apos;, &apos;f2&apos;]</span><br><span class="line">&#125;</span><br><span class="line">var child = createClone(Person);</span><br><span class="line">child.name = &apos;carry2&apos;;</span><br><span class="line">child.sayHi(); //&apos;i am clone&apos;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>寄生组合式继承</p>
<ul>
<li>采用 借用构造函数 来继承属性  使用 原型链的混成形式来继承 方法</li>
<li>用来完善组合式继承：因为组合式继承 要调用两次父类的构造函数，造成了在子类中又创建了一遍属性</li>
<li>优点：寄生式组合继承 只使用了一次 父类构造函数，避免了child.prototype上创建没必要的属性，原型链的结构还可以保持不变<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">function inheritPrototype(subType, superType) &#123;</span><br><span class="line">    var prototype = Object.create(SuperType.prototype); //创建对象</span><br><span class="line">    prototype.constructor = subType; //增强对象</span><br><span class="line">    subType.prototype = prototype; //指定对象</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function SuperType(name) &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.colors = [&apos;green&apos;, &apos;red&apos;];</span><br><span class="line">&#125;</span><br><span class="line">SuperType.prototype.sayName = function() &#123;</span><br><span class="line">    alert(this.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function SubType(name, age) &#123;</span><br><span class="line">    //继承属性</span><br><span class="line">    SuperType.call(this, name);</span><br><span class="line">    this.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//继承方法</span><br><span class="line">inheritPrototype(SubType, SuperType)</span><br><span class="line">SubType.prototype.sayAge = function() &#123;</span><br><span class="line">    alert(this.age);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<hr>
<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>闭包大纲</p>
<ul>
<li>什么是闭包？</li>
<li>闭包的原理？</li>
<li>平时如何用闭包，闭包能解决什么问题？</li>
</ul>
<h3 id="a：说一下什么是闭包"><a href="#a：说一下什么是闭包" class="headerlink" title="a：说一下什么是闭包?"></a>a：说一下什么是闭包?</h3><p>使用着另一个函数作用域中的变量的函数，保留变量并不被回收</p>
<h3 id="b-闭包的原理（深刻一点，包括作用域链，垃圾回收机制）"><a href="#b-闭包的原理（深刻一点，包括作用域链，垃圾回收机制）" class="headerlink" title="b:闭包的原理（深刻一点，包括作用域链，垃圾回收机制）"></a>b:闭包的原理（深刻一点，包括作用域链，垃圾回收机制）</h3><p>之所以内层函数可以访问外的变量是因为</p>
<ul>
<li>内部函数的作用域链中包含着外层函数的变量对象（活动对象和全局变量对象）</li>
<li>外层函数执行完毕后，它的执行环境和作用域链会被销毁，但被闭包引用的变量对象不被销毁</li>
</ul>
<p>如何销毁闭包：</p>
<ul>
<li>var a = outerFunction(‘123’);</li>
<li>使用闭包后,想销毁闭包的作用域链</li>
<li>a = null;//通知垃圾回收进行清除</li>
</ul>
<h3 id="c-你是如何应用闭包的"><a href="#c-你是如何应用闭包的" class="headerlink" title="c:你是如何应用闭包的?"></a>c:你是如何应用闭包的?</h3><p>使用闭包定义私有方法和变量</p>
<h4 id="1-模拟块级作用域（私有变量和作用域）"><a href="#1-模拟块级作用域（私有变量和作用域）" class="headerlink" title="1:模拟块级作用域（私有变量和作用域）"></a>1:模拟块级作用域（私有变量和作用域）</h4><p>只让for循环内访问变量i，立即函数模拟块级作用域，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">function foo3(count) &#123;</span><br><span class="line">    for (var i = 0; i &lt; count; i++) &#123;</span><br><span class="line">        console.log(&apos;inner:&apos; + i); //12345</span><br><span class="line">    &#125;</span><br><span class="line">    console.log(&apos;outer:&apos; + i); //5</span><br><span class="line">&#125;</span><br><span class="line">foo3(5);</span><br><span class="line"></span><br><span class="line">//使用立即函数和闭包定义块级作用域</span><br><span class="line">function foo4(count) &#123;</span><br><span class="line">    (function() &#123;</span><br><span class="line">        //块作用域</span><br><span class="line">        for (var i = 0; i &lt; count; i++) &#123;</span><br><span class="line">            console.log(&apos;inner:&apos; + i); //12345</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;)();</span><br><span class="line">    console.log(&apos;outer:&apos; + i); //报错</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="2：构造模式，定义接口，让外界可以访问函数的私有变量"><a href="#2：构造模式，定义接口，让外界可以访问函数的私有变量" class="headerlink" title="2：构造模式，定义接口，让外界可以访问函数的私有变量"></a>2：构造模式，定义接口，让外界可以访问函数的私有变量</h4><p>//定义构造函数，使用闭包访问函数的私有变量<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function Person(name) &#123;</span><br><span class="line">    this.getName = function() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line">    this.setName = function(value) &#123;</span><br><span class="line">        name = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var a = new Person(&apos;carry&apos;);</span><br><span class="line">var k =  a.getName(); //carry;</span><br><span class="line">a.setName(&apos;bill&apos;);</span><br><span class="line">a.getName(); //bill;</span><br></pre></td></tr></table></figure></p>
<h4 id="3：原型模式-私有作用域-定义接口"><a href="#3：原型模式-私有作用域-定义接口" class="headerlink" title="3：原型模式 私有作用域 定义接口"></a>3：原型模式 私有作用域 定义接口</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">(function() &#123;</span><br><span class="line">    //定义私有变量</span><br><span class="line">    var name = &apos;&apos;;</span><br><span class="line">    //定义私有方法</span><br><span class="line">    Person = function(value) &#123;</span><br><span class="line">            name = value;</span><br><span class="line">        &#125;</span><br><span class="line">        //定义接口</span><br><span class="line">    Person.prototype.getName = function() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line">    Person.prototype.setName = function(value) &#123;</span><br><span class="line">        name = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
<h4 id="4：模块化"><a href="#4：模块化" class="headerlink" title="4：模块化"></a>4：模块化</h4><p>retrun {f:f}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">function CoolModule() &#123;</span><br><span class="line">    var something = &quot;cool&quot;;</span><br><span class="line">    var another = [1, 2, 3];</span><br><span class="line"></span><br><span class="line">    function doSomething() &#123;</span><br><span class="line">        alert( something );</span><br><span class="line">    &#125;</span><br><span class="line">    function doAnother() &#123;</span><br><span class="line">        alert( another.join( &quot; ! &quot; ) );</span><br><span class="line">    &#125;</span><br><span class="line">    return &#123;</span><br><span class="line">        doSomething: doSomething,</span><br><span class="line">        doAnother: doAnother</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line">var foo = CoolModule();</span><br><span class="line">foo.doSomething(); // cool</span><br><span class="line">foo.doAnother(); // 1 ! 2 ! 3</span><br></pre></td></tr></table></figure></p>
<hr>
<h3 id="d-使用闭包应该注意？"><a href="#d-使用闭包应该注意？" class="headerlink" title="d:使用闭包应该注意？"></a>d:使用闭包应该注意？</h3><ul>
<li>1:闭包只能取某变量的最后一个值（for循环中的匿名函数）</li>
<li>2:闭包中的this指向全局环境，无法正常的访问作用域中的this和arguments,</li>
</ul>
<h4 id="1-闭包只能取某变量的最后一个值（for循环中的匿名函数）"><a href="#1-闭包只能取某变量的最后一个值（for循环中的匿名函数）" class="headerlink" title="1:闭包只能取某变量的最后一个值（for循环中的匿名函数）"></a>1:闭包只能取某变量的最后一个值（for循环中的匿名函数）</h4><p>下面函数的输出结果是 10个10<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function foo1() &#123;</span><br><span class="line">    var result = [];</span><br><span class="line">    for (var i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">        result[i] = function() &#123;</span><br><span class="line">            console.log(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>使用立即函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function foo1() &#123;</span><br><span class="line">    var result = [];</span><br><span class="line">    for (var i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">        result[i] = function(n) &#123;</span><br><span class="line">            return function() &#123;</span><br><span class="line">                console.log(n);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;(i);</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="2-闭包中的this指向-window"><a href="#2-闭包中的this指向-window" class="headerlink" title="2:闭包中的this指向 window"></a>2:闭包中的this指向 window</h4><p>this在运行时是基于函数的执行环境绑定的<br>匿名函数的执行环境具有全局性，闭包中的this指向window<br>闭包在执行环境中搜索 this和arguments<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var name = &apos;the window&apos;;</span><br><span class="line">var obj = &#123;</span><br><span class="line">    name: &apos;my obj&apos;,</span><br><span class="line">    getName: function() &#123;</span><br><span class="line">        var that = this;</span><br><span class="line">        return function() &#123;</span><br><span class="line">            return that.name;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">console.log(obj.getName());</span><br></pre></td></tr></table></figure></p>
<h3 id="d-闭包的优缺点"><a href="#d-闭包的优缺点" class="headerlink" title="d:闭包的优缺点"></a>d:闭包的优缺点</h3><p>优点：避免全局变量的污染，存在私有变量，使一个成员常驻内存。<br>缺点：闭包会常驻内存，会增大内存使用，使用不当容易造成内存溢出。<br>闭包会保存外层函数的变量对象，会占用更多的内存。<br>V 8优化后的js引擎会尝试回收被闭包占用的内存，但还需慎重使用闭包</p>
<h3 id="f-如何创建闭包"><a href="#f-如何创建闭包" class="headerlink" title="f:如何创建闭包"></a>f:如何创建闭包</h3><p>1.定义外层函数，和变量。<br>2.定义内层函数，并对外部函数的变量进行使用。<br>3.返回内层函数。<br>返回的内层函数，在其他地方被调用，仍然保存着外函数的变量。（通过访问闭包来访问变量，闭包使变量为私有变量）</p>
<h3 id="作用域和作用域链-1"><a href="#作用域和作用域链-1" class="headerlink" title="作用域和作用域链"></a>作用域和作用域链</h3><p>因为当某个函数第一次被调用时候，会创建相应的执行环境和作用域链<br>并把作用域链赋值给内部属性：scope,使用this,arguments和函数的初始参数为活动对象（活动对象就是函数执行上下文中的变量）<br>当在函数中访问变量的时候，需要在作用域链中进行查找，先访问自己的内部的，再访问外部的，再访问外部外部的，直到作用域链的终点：全局执行环境<br>创建函数时，会创建包含函数外部对象的 作用域链，作用域链保存在当前函数的scope中<br>调用函数时，会创建执行环境，创建执行环境的作用域链：是靠复制函数的scope里面的对象<br>作用域链的本质是指向变量对象的指针链表，指引用，不实际包含变量对象</p>
<h3 id="内存泄露，垃圾回收机制"><a href="#内存泄露，垃圾回收机制" class="headerlink" title="内存泄露，垃圾回收机制"></a>内存泄露，垃圾回收机制</h3><p>循环引用会导致内存泄露<br>在IE9之前版本使用闭包，会导致一些特殊的问题。例如，闭包的作用域链中保存着html元素，无法被销毁</p>
<ul>
<li>解决 定义访问的dom元素的副本，element = null; //解除对dom对象的引用<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function foo2() &#123;</span><br><span class="line">    var element = document.getElementById(&apos;someElement&apos;);</span><br><span class="line">    var id = element.id; //定义让闭包访问的副本</span><br><span class="line">    element.onclick = function() &#123;</span><br><span class="line">        alert(id);</span><br><span class="line">    &#125;;</span><br><span class="line">    element = null; //解除对dom对象的引用</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h3 id="函数声明与函数表达式"><a href="#函数声明与函数表达式" class="headerlink" title="函数声明与函数表达式"></a>函数声明与函数表达式</h3><p>function a (){};<br>a();<br>var a = function(){};<br>a();</p>
<p>函数声明方式后不能直接加 ()调用，需要 (function a (){})();</p>
<hr>
<h2 id="js事件-5"><a href="#js事件-5" class="headerlink" title="js事件 5%"></a>js事件 5%</h2><h3 id="事件模型"><a href="#事件模型" class="headerlink" title="事件模型"></a>事件模型</h3><ul>
<li>DOM0 :原始事件模型<ul>
<li>btn.onclick=function(){}这种类型的事件模型（btn.onclick = null;）</li>
<li>基于DOM0的事件，对于同一个dom节点而言，只能注册一个， 取后面事件。后边注册的同种事件会覆盖之前注册的。</li>
</ul>
</li>
<li>DOM2<ul>
<li>冒泡 ：事件从事件的发生地（目标元素），一直向上传递，直到window<ul>
<li>IE只支持事件冒泡</li>
</ul>
</li>
<li>捕获 ：事件是从window向下传递，直到事件的发生地（目标元素）</li>
<li>设置捕获和冒泡：<ul>
<li>IE：默认事件冒泡<ul>
<li>标准： addEventListener()第三个参数:捕获/冒泡 = true/false</li>
</ul>
</li>
</ul>
</li>
<li>绑定或者解除事件<ul>
<li>标准：addEventListener(type,handler),removeEventListener(type,handler)</li>
<li>IE: attachEvent,target.detachEvent(“on”+type,handler);</li>
</ul>
</li>
<li>阻止事件冒泡：evt.stopPropagation()/evt.cancelBubble=true</li>
<li>获取事件对象(标准||IE):var event=window.event||event; </li>
<li>获取事件源对象：var target = event.target||event.srcElement;</li>
<li>同一个节点元素，给她添加捕获和冒泡事件模型，捕获比冒泡快</li>
<li>绑定多个事件的顺序:比如说一下子注册了3个冒泡事件，那么执行顺序就按照注册的顺序来，先注册先执行</li>
</ul>
</li>
</ul>
<hr>
<h3 id="事件委托"><a href="#事件委托" class="headerlink" title="事件委托"></a>事件委托</h3><p>应用场景：动态添加 或删除孩子的时候<br>含义：孩子的事委托父亲做<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul id=&quot;ul1&quot;&gt;</span><br><span class="line">    &lt;li&gt;111&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;222&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;333&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;444&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line"></span><br><span class="line">window.onload = function()&#123;</span><br><span class="line">    var oUl = document.getElementById(&quot;ul1&quot;);</span><br><span class="line">   oUl.onclick = function()&#123;</span><br><span class="line">        alert(123);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里用父级ul做事件处理，当li被点击时，由于冒泡原理，事件就会冒泡到ul上，因为ul上有点击事件，所以事件就会触发.<br>当然，这里当点击ul的时候，也是会触发的，那么问题就来了，如果我想让事件代理的效果跟直接给节点的事件效果一样怎么办，比如说只有点击li才会触发，不怕，我们有绝招：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">window.onload = function()&#123;</span><br><span class="line">　　var oUl = document.getElementById(&quot;ul1&quot;);</span><br><span class="line">　　oUl.onclick = function(event)&#123;</span><br><span class="line">　　　　var ev = event || window.event;</span><br><span class="line">　　　　var target = ev.target || ev.srcElement;</span><br><span class="line">　　　　if(target.nodeName.toLowerCase() == &apos;li&apos;)&#123;</span><br><span class="line">　 　　　　　　 alert(123);</span><br><span class="line">　　　　　　　  alert(target.innerHTML);</span><br><span class="line">　　　　&#125;</span><br><span class="line">　　&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<p>##【事件相关问题】<br>1：阻止默认事件：preventDefault():<br>2：阻止冒泡：stopPropagation();<br>3：什么时候会事件捕获？应用事件捕获解决什么问题？<br>你想作全局的点击事件监听，相对于document结点与document下所有的子结点，在某个条件下要求所有的子结点点击无效，这种情况下冒泡模型就解决不了了，而捕获型却非常适合，可以在最顶层结点添加捕获型事件监听器。<br>3：事件冒泡和事件捕获分别有哪些浏览器支持？<br>IE只支持事件冒泡</p>
<hr>
<h2 id="浏览器对事件的处理过"><a href="#浏览器对事件的处理过" class="headerlink" title="浏览器对事件的处理过"></a>浏览器对事件的处理过</h2><ul>
<li>鼠标点击以后 浏览器对于事件的处理详细过程？<br>当(click)点击某个元素，以PC端为例，操作系统会将(click)鼠标点击事件广播到所有应用中，浏览器应用接受到鼠标事件广播后，查询事件源和对应的回函数（按照先捕获后冒泡的顺序），并压入事件处理队列（Event Queue）。Event Loop 则会从中取出回调函数并执行。<ul>
<li>注册（绑定）事件，浏览器干嘛了？<br>DOM.addEventListener，函数以类似”委托”的形式注册到浏览器内建的队列中，等到某个”事件”被触发后，则回Call之前注册的函数。</li>
<li>执行（响应）事件浏览器干嘛了？<br>当(click)点击某个元素，以PC端为例，操作系统会将(click)鼠标点击事件广播到所有应用中，浏览器应用接受到鼠标事件广播后，查询事件源和对应的回函数（按照先捕获后冒泡的顺序），并压入事件处理队列（Event Queue）。</li>
<li>异步<br>js中的异步没有从语言上约定其异步的特性，是浏览器/执行引擎来实现，我们所探讨的“异步”都是由执行引擎所赋予的。<br>javascript 是的单线程的，于是就产生了一种任务执行机制叫 eventloop。它维护了一个任务队列，完成一个任务才会开始下一个任务。</li>
</ul>
</li>
</ul>
<hr>
<h2 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收?"></a>垃圾回收?</h2><h3 id="为什么要垃圾回收？"><a href="#为什么要垃圾回收？" class="headerlink" title="* 为什么要垃圾回收？"></a>* 为什么要垃圾回收？</h3><p>由于字符串、对象和数组没有固定大小，所有当他们的大小已知时，才能对他们进行动态的存储分配。JavaScript程序每次创建字符串、数组或对象时，解释器都必须分配内存来存储那个实体。只要像这样动态地分配了内存，最终都要释放这些内存以便他们能够被再用，否则，JavaScript的解释器将会消耗完系统中所有可用的内存，造成系统崩溃。</p>
<h3 id="垃圾回收的基本方法？"><a href="#垃圾回收的基本方法？" class="headerlink" title="* 垃圾回收的基本方法？"></a>* 垃圾回收的基本方法？</h3><h4 id="1、标记清除（mark-and-sweep）"><a href="#1、标记清除（mark-and-sweep）" class="headerlink" title="1、标记清除（mark and sweep）"></a><strong>1、标记清除（mark and sweep）</strong></h4><p>　　这是javascript中最常用的垃圾回收方式。当变量进入执行环境是，就标记这个变量为“进入环境”。从逻辑上讲，永远不能释放进入环境的变量所占用的内存，因为只要执行流进入相应的环境，就可能会用到他们。当变量离开环境时，则将其标记为“离开环境”。　　垃圾收集器在运行的时候会给存储在内存中的所有变量都加上标记。然后，它会去掉环境中的变量以及被环境中的变量引用的标记。而在此之后再被加上标记的变量将被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。最后。垃圾收集器完成内存清除工作，销毁那些带标记的值，并回收他们所占用的内存空间。</p>
<h4 id="2。标记清除"><a href="#2。标记清除" class="headerlink" title="2。标记清除"></a>2。标记清除</h4><p>　　另一种不太常见的垃圾回收策略是引用计数。引用计数的含义是跟踪记录每个值被引用的次数。当声明了一个变量并将一个引用类型赋值给该*变量时，则这个值的引用次数就是1。相反，如果包含对这个值引用的变量又取得了另外一个值，则这个值的引用次数就减1。当这个引用次数变成0时，则说明没有办法再访问这个值了，因而就可以将其所占的内存空间给收回来。这样，垃圾收集器下次再运行时，它就会释放那些引用次数为0的值所占的内存。</p>
<h4 id="减少垃圾回收？"><a href="#减少垃圾回收？" class="headerlink" title="* 减少垃圾回收？"></a>* 减少垃圾回收？</h4><p> 1:只保留程序运行时需要的数据，对于已经使用的或者不需要的数据，应该将其值设为 null<br> 2:避免创建对象<br>    清空数组：array.length = 0</p>
<hr>
<h2 id="原生js的-增-删-改-5"><a href="#原生js的-增-删-改-5" class="headerlink" title="原生js的(增 删 改) 5%"></a>原生js的(增 删 改) 5%</h2><p><img src="http://upload-images.jianshu.io/upload_images/2377897-d9abdd592a00f11f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<h3 id="增"><a href="#增" class="headerlink" title="增"></a>增</h3><ul>
<li>若添加新元素：首先创建该元素节点，然后添加</li>
<li>创建元素节点：document.createElement(‘h1’)</li>
<li>创建文本节点：document.createTextNode(‘描述’)</li>
<li>增加：<ul>
<li>添加孩子<ul>
<li>A.append(B) : 把B追加到A内部</li>
<li>A.appendTo(B) : 把A追加到B内部</li>
<li>A.prepend(B) : 在A的开始添加孩子B</li>
<li>A.prependTo(B) : 把A追加到B的开始<ul>
<li>添加兄弟</li>
<li>A.after(B) :  在A后添加B</li>
<li>A.before(B): 在A前追加B</li>
<li>添加class</li>
<li>elm.classList.add(‘nn’)</li>
<li>elm.className+=” nn”  //nn前边有空格</li>
<li>parent.insertBefore(newNode,oldNode):在父节点n里面的B节点前面追加A<br>模拟insertAfter: parent.insertBefore(newNode,oN.nextsilibing());</li>
<li>替换节点：parent.replaceChild(child,oldElem);</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="删"><a href="#删" class="headerlink" title="删"></a>删</h3><ul>
<li>elementNow.remove():删除当前元素</li>
<li>parent.removeChild(child):删除父元素中的子元素</li>
<li>child.parentNode.removeChild(child)：不确定父元素的时候可以这样做<h3 id="改"><a href="#改" class="headerlink" title="改"></a>改</h3><a href="http://www.jianshu.com/writer#/notebooks/10862078/notes/15825654/preview" target="_blank" rel="external">http://www.jianshu.com/writer#/notebooks/10862078/notes/15825654/preview</a><ul>
<li>( 获取，设置) 修改HTML元素内容<ul>
<li>node.textContent:用来设置或是获取某个元素内所有文本内容，包括子元素中的内容。（css等兼容性比innerText好）</li>
<li>node.innerText: 只获取当前节点内容</li>
<li>node.innerHTML：</li>
<li>node.outerHTML：</li>
</ul>
</li>
<li>更改属性<ul>
<li>设置属性：node.setAttribute(‘style’,’color:red’)</li>
<li>获取属性：var a = node.getAttribute(‘’style’’);</li>
</ul>
</li>
<li>修改元素CSS<ul>
<li>node.style.color=”red”<h3 id="查"><a href="#查" class="headerlink" title="查"></a>查</h3></li>
</ul>
</li>
<li>querySelector()、</li>
<li>querySelectorAll()</li>
<li>getElementById()、</li>
<li>getElementsByTagName()、</li>
<li>getElementsByName()、</li>
<li>getElementsByClassName()、</li>
</ul>
</li>
</ul>
<hr>
<h3 id="jq增删改查"><a href="#jq增删改查" class="headerlink" title="jq增删改查"></a>jq增删改查</h3><ul>
<li>内部插入主要方法：<ul>
<li>append(content) 向每个匹配的元素内部追加内容。</li>
<li>prepend(content) 向每个匹配的元素内部前置内容。</li>
</ul>
</li>
<li>外部插入：<ul>
<li>after(content) 在每个匹配的元素之后插入内容。</li>
<li>before(content) 在每个匹配的元素之前插入内容。</li>
</ul>
</li>
<li>删除：<ul>
<li>empty() 删除匹配的元素集合中所有的子节点。</li>
<li>remove([expr]) 从DOM中删除所有匹配的元素。</li>
</ul>
</li>
</ul>
<hr>
<h2 id="深拷贝与浅拷贝"><a href="#深拷贝与浅拷贝" class="headerlink" title="深拷贝与浅拷贝"></a>深拷贝与浅拷贝</h2><p>深拷贝与浅拷贝是之于Array,Object来说的，来由背景，引用类型对象的赋值，一个改变，会引起另一个改变，因为两个变量指向同一个堆空间放的对象</p>
<ul>
<li>深拷贝和浅拷贝最根本的区别在于是否是真正获取了一个对象的复制实体，而不是引用地址<figure class="highlight plain"><figcaption><span>a = &#123;b:'k'&#125;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var c = a;</span><br><span class="line">a.b = &apos;carry&apos;;</span><br><span class="line">c.b? 答案是&apos;carry&apos;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>那么我们如何给引用类型对象赋值（copy），完全隔离，互不影响呢？</p>
<h3 id="数组深拷贝"><a href="#数组深拷贝" class="headerlink" title="数组深拷贝"></a>数组深拷贝</h3><ul>
<li>ES6拷贝数组Array.from， […oldArr]</li>
<li>使用循环遍历拷贝</li>
<li>使用slice，concat进行数组拷贝</li>
</ul>
<h4 id="1-使用slice，concat进行数组拷贝"><a href="#1-使用slice，concat进行数组拷贝" class="headerlink" title="1.使用slice，concat进行数组拷贝"></a>1.使用slice，concat进行数组拷贝</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1. var a = [1,2];</span><br><span class="line">var b = a.slice(0);</span><br><span class="line">b[0] = 3;</span><br><span class="line">alert(a) //1,2</span><br><span class="line">2. var a = [1,2];</span><br><span class="line">var b = a.concat(0);</span><br></pre></td></tr></table></figure>
<h4 id="2-使用循环遍历拷贝"><a href="#2-使用循环遍历拷贝" class="headerlink" title="2.使用循环遍历拷贝"></a>2.使用循环遍历拷贝</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var arr1=[1,2,3,4];</span><br><span class="line">var arr2=[];</span><br><span class="line">for(var i=0; i&lt;arr1.length; i++)&#123;</span><br><span class="line">  arr2[i]=arr1[i];</span><br><span class="line">&#125;</span><br><span class="line">arr1.push(5);</span><br><span class="line">arr2.push(6);</span><br><span class="line">alert(arr1); //12345</span><br><span class="line">alert(arr2); //12346</span><br></pre></td></tr></table></figure>
<h4 id="3-ES6拷贝数组Array-from，-…oldArr"><a href="#3-ES6拷贝数组Array-from，-…oldArr" class="headerlink" title="3. ES6拷贝数组Array.from， […oldArr]"></a>3. ES6拷贝数组Array.from， […oldArr]</h4><ul>
<li>第一种：var newArr = Array.from(oldArr);</li>
<li>第二种：var newArr = […oldArr]<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var arr1=[1,2,3];</span><br><span class="line">var arr2=Array.from(arr1);</span><br><span class="line">arr1.push(4);</span><br><span class="line">alert(arr1);  //1234</span><br><span class="line">alert(arr2);  //123</span><br><span class="line">arr2.push(5);</span><br><span class="line">alert(arr1);  //1234</span><br><span class="line">alert(arr2);  //1235</span><br></pre></td></tr></table></figure>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var arr1=[1,2,3];</span><br><span class="line">var arr2=[...arr1];</span><br><span class="line">arr1.push(4);</span><br><span class="line">alert(arr1);  //1234</span><br><span class="line">alert(arr2);  //123</span><br><span class="line">arr2.push(5);</span><br><span class="line">alert(arr1);  //1234</span><br><span class="line">alert(arr2);  //1235</span><br></pre></td></tr></table></figure>
<h3 id="对象深拷贝"><a href="#对象深拷贝" class="headerlink" title="对象深拷贝"></a>对象深拷贝</h3><ul>
<li>JSON对象的parse和stringify</li>
<li>jQuery中的extend复制方法</li>
</ul>
<h4 id="JSON对象的parse和stringify"><a href="#JSON对象的parse和stringify" class="headerlink" title="JSON对象的parse和stringify"></a>JSON对象的parse和stringify</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var source = &#123;</span><br><span class="line">    name:&quot;source&quot;,</span><br><span class="line">    child:&#123;</span><br><span class="line">        name:&quot;child&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var target = JSON.parse(JSON.stringify(source));</span><br><span class="line">//改变target的name属性</span><br><span class="line">target.name = &quot;target&quot;;</span><br><span class="line">console.log(source.name);   //source</span><br><span class="line">console.log(target.name);   //target</span><br><span class="line">//改变target的child</span><br><span class="line">target.child.name = &quot;target child&quot;;</span><br><span class="line">console.log(source.child.name);  //child</span><br><span class="line">console.log(target.child.name);  //target child</span><br></pre></td></tr></table></figure>
<h4 id="jQuery中的extend复制方法"><a href="#jQuery中的extend复制方法" class="headerlink" title="jQuery中的extend复制方法"></a>jQuery中的extend复制方法</h4><h3 id="自己实现深拷贝"><a href="#自己实现深拷贝" class="headerlink" title="自己实现深拷贝"></a>自己实现深拷贝</h3><ul>
<li>判断对象数据类型 Object.prototype.toString.call(obj);</li>
<li>若为Object则实现深拷贝</li>
<li>Array和Object 用遍历的方式深拷贝<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">//util作为判断变量具体类型的辅助模块</span><br><span class="line">   var util = (function()&#123;</span><br><span class="line">       var class2type = &#123;&#125;;</span><br><span class="line">       [&quot;Null&quot;,&quot;Undefined&quot;,&quot;Number&quot;,&quot;Boolean&quot;,&quot;String&quot;,&quot;Object&quot;,&quot;Function&quot;,&quot;Array&quot;,&quot;RegExp&quot;,&quot;Date&quot;].forEach(function(item)&#123;</span><br><span class="line">           class2type[&quot;[object &quot;+ item + &quot;]&quot;] = item.toLowerCase();</span><br><span class="line">       &#125;)</span><br><span class="line"> </span><br><span class="line">       function isType(obj, type)&#123;</span><br><span class="line">           return getType(obj) === type;</span><br><span class="line">       &#125;</span><br><span class="line">       function getType(obj)&#123;</span><br><span class="line">           return class2type[Object.prototype.toString.call(obj)] || &quot;object&quot;;</span><br><span class="line">       &#125;</span><br><span class="line">       return &#123;</span><br><span class="line">           isType:isType,</span><br><span class="line">           getType:getType</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;)();</span><br><span class="line"> </span><br><span class="line">   function copy(obj,deep)&#123;</span><br><span class="line">        //如果obj不是对象，那么直接返回值就可以了</span><br><span class="line">       if(obj === null || typeof obj !== &quot;object&quot;)&#123;</span><br><span class="line">           return obj;</span><br><span class="line">       &#125;</span><br><span class="line">　　　　//定义需要的局部变脸，根据obj的类型来调整target的类型</span><br><span class="line">       var i, target = util.isType(obj,&quot;array&quot;) ? [] : &#123;&#125;,value,valueType;</span><br><span class="line">       for(i in obj)&#123;</span><br><span class="line">           value = obj[i];</span><br><span class="line">           valueType = util.getType(value);</span><br><span class="line">　　　　　　　//只有在明确执行深复制，并且当前的value是数组或对象的情况下才执行递归复制</span><br><span class="line">           if(deep &amp;&amp; (valueType === &quot;array&quot; || valueType === &quot;object&quot;))&#123;</span><br><span class="line">               target[i] = copy(value);</span><br><span class="line">           &#125;else&#123;</span><br><span class="line">               target[i] = value;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       return target;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h2 id="new"><a href="#new" class="headerlink" title="new"></a>new</h2><h3 id="New一共做了几个操作步骤，要求具体说明"><a href="#New一共做了几个操作步骤，要求具体说明" class="headerlink" title="New一共做了几个操作步骤，要求具体说明"></a>New一共做了几个操作步骤，要求具体说明</h3><ol>
<li><p>创建空对象；<br>　　var obj = {};</p>
</li>
<li><p>设置新对象的constructor属性为构造函数的名称，设置新对象的<strong>proto</strong>属性指向构造函数的prototype对象；<br>　　obj.<strong>proto</strong> = ClassA.prototype;</p>
</li>
<li><p>使用新对象调用函数，函数中的this被指向新实例对象：<br>　　ClassA.call(obj);　　//{}.构造函数();          </p>
</li>
<li><p>将初始化完毕的新对象地址，保存到等号左边的变量中</p>
<h3 id="new一个对象-执行了什么过程？，那-return-‘-’，null-undefined会怎样？"><a href="#new一个对象-执行了什么过程？，那-return-‘-’，null-undefined会怎样？" class="headerlink" title="new一个对象 执行了什么过程？，那 return ‘ ’，null,undefined会怎样？"></a>new一个对象 执行了什么过程？，那 return ‘ ’，null,undefined会怎样？</h3></li>
</ol>
<hr>
<h2 id="如何判定js一个变量值的类型（至少3种）3"><a href="#如何判定js一个变量值的类型（至少3种）3" class="headerlink" title="如何判定js一个变量值的类型（至少3种）3%"></a>如何判定js一个变量值的类型（至少3种）3%</h2><p>Object.prototype.toString.call(obj)<br>[] instanceof Array<br>[].constructor === Object</p>
<hr>
<h2 id="数组和字符串的转换-3"><a href="#数组和字符串的转换-3" class="headerlink" title="数组和字符串的转换 3%"></a>数组和字符串的转换 3%</h2><p>split,join</p>
<hr>
<h2 id="arguments"><a href="#arguments" class="headerlink" title="arguments"></a>arguments</h2><h3 id="是啥？"><a href="#是啥？" class="headerlink" title="是啥？"></a>是啥？</h3><p>函数参数对象，不是数组，但是有length属性，也能arguments[0]取值</p>
<h3 id="转为数组？"><a href="#转为数组？" class="headerlink" title="转为数组？"></a>转为数组？</h3><ul>
<li>Array.prototype.slice.apply(arguments)这是运行效率比较快的方法</li>
<li>Array.prototype.concat.apply(thisArg,arguments)</li>
<li>Array.prototype.slice.call(arguments);<br>对象转为数组</li>
<li>Array.from(arguments) </li>
<li>[…arguments]<h3 id="arguments其他用法？"><a href="#arguments其他用法？" class="headerlink" title="arguments其他用法？"></a>arguments其他用法？</h3><h4 id="利用arguments-callee实现递归"><a href="#利用arguments-callee实现递归" class="headerlink" title="利用arguments.callee实现递归"></a>利用arguments.callee实现递归</h4></li>
</ul>
<hr>
<h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><h3 id="1-arguments-callee"><a href="#1-arguments-callee" class="headerlink" title="1.arguments.callee"></a>1.arguments.callee</h3><p>解决函数名递归带来的危险，arguments.callee指向正在执行的函数，使用它来代替函数名<br>arguments.callee是一个指向正在执行的函数的指针<br>好处：不用使用当前函数进行递归，性能变高<br>缺点：严格模式下不管用</p>
<h3 id="2-使用函数命名表达式"><a href="#2-使用函数命名表达式" class="headerlink" title="2.使用函数命名表达式"></a>2.使用函数命名表达式</h3><p>一个函数两个名字<br>有点：严格模式和非严格模式都适用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var factorial = （ function f(num)&#123;</span><br><span class="line">  return num * f(num-1)</span><br><span class="line">&#125;）</span><br></pre></td></tr></table></figure></p>
<h3 id="3-递归性能上的分析？优化？用es6优化？"><a href="#3-递归性能上的分析？优化？用es6优化？" class="headerlink" title="3.递归性能上的分析？优化？用es6优化？"></a>3.递归性能上的分析？优化？用es6优化？</h3><p>递归非常耗费内存，因为需要同时保存成千上百个调用帧，很容易发生“栈溢出”错误（stack overflow）</p>
<h4 id="使用尾调递归优化递归"><a href="#使用尾调递归优化递归" class="headerlink" title="使用尾调递归优化递归"></a>使用尾调递归优化递归</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function factorial(n) &#123;</span><br><span class="line">  if (n === 1) return 1;</span><br><span class="line">  return n * factorial(n - 1);</span><br><span class="line">&#125;</span><br><span class="line">factorial(5) // 120</span><br></pre></td></tr></table></figure>
<p>比正常递归函数多了一个参数total<br>尾递归，只保留一个调用记录，复杂度 O(1)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function factorial(n, total) &#123;</span><br><span class="line">  if (n === 1) return total;</span><br><span class="line">  return factorial(n - 1, n * total);</span><br><span class="line">&#125;</span><br><span class="line">factorial(5, 1) // 120</span><br></pre></td></tr></table></figure></p>
<h4 id="ES6尾调用"><a href="#ES6尾调用" class="headerlink" title="ES6尾调用"></a>ES6尾调用</h4><p>ES6 的尾调用优化只在严格模式下开启，正常模式是无效的。<br>这是因为在正常模式下，函数内部有两个变量，可以跟踪函数的调用栈。<br>func.arguments：返回调用时函数的参数。<br>func.caller：返回调用当前函数的那个函数。<br>尾调用优化发生时，函数的调用栈会改写，因此上面两个变量就会失真。严格模式禁用这两个变量，所以尾调用模式仅在严格模式下生效。</p>
<hr>
<h2 id="字符串和json的转换3"><a href="#字符串和json的转换3" class="headerlink" title="字符串和json的转换3%"></a>字符串和json的转换3%</h2><p>JSON.stringify( );<br>JSON.parse（）</p>
<h2 id="eval"><a href="#eval" class="headerlink" title="eval()"></a>eval()</h2><p>eval() 函数可计算某个字符串，并执行其中的的 JavaScript 代码。<br>eval(“alert(‘Hello world’)”)<br>eval(“x=10;y=20;document.write(x*y)”)</p>
<h2 id="typeof-输出"><a href="#typeof-输出" class="headerlink" title="typeof 输出"></a>typeof 输出</h2><p>typeof(的)运算数未定义,返回(的)就是 “undefined”.<br>typeof(undifiend)//undifiend</p>
<p>运算数为数字 typeof(x) = “number”<br>字符串 typeof(x) = “string”<br>布尔值 typeof(x) = “boolean”<br>对象,数组和null typeof(x) = “object”<br>函数 typeof(x) = “function”<br>        typeof(‘aa’+4);//string<br>       typeof(‘1’+undifiend);//报错</p>
<hr>
<h2 id="链式调用"><a href="#链式调用" class="headerlink" title="链式调用"></a>链式调用</h2><p>所谓链式调用就是能够返回自身对象<br>$(‘#id’).show().hide().show().hide().show().hide();<br>有点：代码简洁易读，减少了多次重复使用同一个变量</p>
<h3 id="1-方法中直接-return-this"><a href="#1-方法中直接-return-this" class="headerlink" title="1.方法中直接 return this"></a>1.方法中直接 return this</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">   function ClassA()&#123;</span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line">    ClassA.prototype = &#123;</span><br><span class="line">        hide:function()&#123;</span><br><span class="line">            console.log(&apos;hide&apos;);</span><br><span class="line">            return this;</span><br><span class="line">        &#125;,</span><br><span class="line">    getName:function(callback)&#123;</span><br><span class="line">         if(callback)&#123;</span><br><span class="line">            callback.call(this,this.name);</span><br><span class="line">         &#125;</span><br><span class="line">        return this;</span><br><span class="line">      &#125;,</span><br><span class="line">        show:function()&#123;</span><br><span class="line">            console.log(&apos;show&apos;);</span><br><span class="line">            return this;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">var a = new ClassA();</span><br><span class="line">a.show().hide().show().hide().show();</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h2><h2 id="如何解决ajax跨域"><a href="#如何解决ajax跨域" class="headerlink" title="如何解决ajax跨域"></a>如何解决ajax跨域</h2><h3 id="1-CROS方式（跨域资源共享）"><a href="#1-CROS方式（跨域资源共享）" class="headerlink" title="1.CROS方式（跨域资源共享）"></a>1.CROS方式（跨域资源共享）</h3><p> 原理 ：配置的两大基本信息,Origin和headers<br>第一步:配置Php 后台允许跨域<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">header(&apos;Access-Control-Allow-Origin: *&apos;);</span><br><span class="line">header(&apos;Access-Control-Allow-Headers: Origin, X-Requested-With, Content-Type, Accept&apos;);</span><br><span class="line">//主要为跨域CORS配置的两大基本信息,Origin和headers</span><br></pre></td></tr></table></figure></p>
<p>第二步:配置Apache web服务器跨域(httpd.conf中)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;Directory /&gt;</span><br><span class="line">   //AllowOverride none</span><br><span class="line">    //Require all denied</span><br><span class="line">    Options FollowSymLinks</span><br><span class="line">    AllowOverride none</span><br><span class="line">    Order deny,allow</span><br><span class="line">    Allow from all</span><br><span class="line">&lt;/Directory&gt;</span><br></pre></td></tr></table></figure></p>
<hr>
<h3 id="2-JSONP方式"><a href="#2-JSONP方式" class="headerlink" title="2.JSONP方式"></a>2.JSONP方式</h3><ul>
<li>jsonp解决跨域问题是一个比较古老的方案(实际中不推荐使用),</li>
<li>这里做简单介绍(实际项目中如果要使用JSONP,</li>
<li>一般会使用JQ等对JSONP进行了封装的类库来进行ajax请求)</li>
</ul>
<h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><ul>
<li>JSONP之所以能够用来解决跨域方案,</li>
<li>主要是因为 script脚本拥有跨域能力,</li>
<li>而JSONP正是利用这一点来实现。具体原理如图<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">function addScriptTag(src) &#123;</span><br><span class="line">  var script = document.createElement(&apos;script&apos;);</span><br><span class="line">  script.setAttribute(&quot;type&quot;,&quot;text/javascript&quot;);</span><br><span class="line">  script.src = src;</span><br><span class="line">  document.body.appendChild(script);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">window.onload = function () &#123;</span><br><span class="line">  addScriptTag(&apos;http://example.com/ip?callback=foo&apos;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function foo(data) &#123;</span><br><span class="line">  console.log(&apos;response data: &apos; + JSON.stringify(data));</span><br><span class="line">&#125;;</span><br><span class="line">服务端对应的接口在返回参数外面添加函数包裹层</span><br><span class="line">foo(&#123;</span><br><span class="line">  &quot;test&quot;: &quot;testData&quot;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="jsonp的弊端"><a href="#jsonp的弊端" class="headerlink" title="jsonp的弊端"></a>jsonp的弊端</h4><p>JSONP只支持GET请求，CORS支持所有类型的HTTP请求。JSONP的优势在于支持老式浏览器，以及可以向不支持CORS的网站请求数据。</p>
<h2 id="请求代理进行跨域nginx"><a href="#请求代理进行跨域nginx" class="headerlink" title="请求代理进行跨域nginx"></a>请求代理进行跨域nginx</h2><hr>
<p>如何解决ajax跨域</p>
<p>一般ajax跨域解决就是通过JSONP解决或者CORS解决,如以下:(注意，现在已经几乎不会再使用JSONP了，所以JSONP了解下即可)</p>
<h2 id="其他跨域"><a href="#其他跨域" class="headerlink" title="其他跨域"></a>其他跨域</h2><p>2:通过修改document.domain来跨子域<br>仅在相同主域下才有效，且window.domain需要设置为相同的父域 不同的框架之间是可以获取window对象的，但却无法获取相应的属性和方法。<br>比如，有一个页面，它的地址是<a href="http://www.example.com/a.html" target="_blank" rel="external">http://www.example.com/a.html</a> ，<br>在这个页面里面有一个iframe，它的src是<a href="http://example.com/b.html" target="_blank" rel="external">http://example.com/b.html</a>,<br>很显然，这个页面与它里面的iframe框架是不同域的，所以我们是无法通过在页面中书写js代码来获取iframe中的东西的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">    function test()&#123;</span><br><span class="line">        var iframe = document.getElementById(&apos;iframe&apos;);</span><br><span class="line">        var win = document.contentWindow;//可以获取到iframe里的window对象，但该window对象的属性和方法几乎是不可用的</span><br><span class="line">        var doc = win.document;//这里获取不到iframe里的document对象</span><br><span class="line">        var name = win.name;//这里同样获取不到window对象的name属性</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;iframe id = &quot;iframe&quot; src=&quot;http://example.com/b.html&quot; onload = &quot;test()&quot;&gt;&lt;/iframe&gt;</span><br></pre></td></tr></table></figure></p>
<p><img src="http://upload-images.jianshu.io/upload_images/2377897-b81be614658808c3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"><br>3:</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2377897-d51bad8105ff7116.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"><br>4：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2377897-665a15e11ea92788.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"><br>5：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2377897-2e14787d1c2eae05.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<hr>
<h2 id="if-false-的几种情况"><a href="#if-false-的几种情况" class="headerlink" title="if() false 的几种情况"></a>if() false 的几种情况</h2><ul>
<li>if(false)</li>
<li>if(null)</li>
<li>if(undefined)</li>
<li>if(‘’)</li>
<li>if(NaN)-数字NaN</li>
<li>if(0)-数字0</li>
</ul>
<hr>
<h2 id="Ajax实现流程"><a href="#Ajax实现流程" class="headerlink" title="Ajax实现流程"></a>Ajax实现流程</h2><p>创建一个XMLHttpRequest()实例<br>准备一个Ajax请求以待发送<br>发送Ajax请求<br>根据服务器响应的结果，将相应数据填充到xhr对象的属性中 注意url是相对于执行代码的当前页面，也可以是绝对路径。</p>
<p>var xhr = new XMLHttpRequest();<br>xhr.open(Type,URL,Boolean);<br>//请求类型，请求地址，是否异步<br>xhr.send(null);<br>xhr.onreadystatechange = function(){<br>    if(xhr.readyState == 4){<br>        if(xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300 || xhr.status == 304){<br>            alert(xhr.responseText);<br>        }else {<br>            alert(‘unsuccessful ‘ + xhr.status);<br>        }<br>    }<br>};</p>
<hr>
<h2 id="单线程"><a href="#单线程" class="headerlink" title="单线程"></a>单线程</h2><p>为什么javascrip是单线程<br>JavaScript的单线程，与它的用途有关。作为浏览器脚本语言，JavaScript的主要用途是与用户互动，以及操作DOM。这决定了它只能是单线程，否则会带来很复杂的同步问题。<br>浏览器端多线程<br>js<br>css<br>事件<br>数据交互</p>
<hr>
<h2 id="垃圾回收-1"><a href="#垃圾回收-1" class="headerlink" title="垃圾回收"></a>垃圾回收</h2><p>垃圾收集器必须跟踪哪个变量有用哪个变量没用，对于不再有用的变量打上标记，以备将来收回其占用的内存，内存泄露和浏览器实现的垃圾回收机制息息相关， 而浏览器实现标识无用变量的策略主要有下两个方法：<br>第一，引用计数法<br>跟踪记录每个值被引用的次数。当声明一个变量并将引用类型的值赋给该变量时，则这个值的引用次数就是1。如果同一个值又被赋给另一个变量，则该值的引用次 数加1.相反，如果包含对这个值引用的变量又取得另外一个值，则这个值的引用次数减1.当这个值的引用次数变成0时，则说明没有办法访问这个值了，因此就 可以将其占用的内存空间回收回来。</p>
<p>如： var a = {};     //对象{}的引用计数为1<br>     b = a;          //对象{}的引用计数为 1+1<br>     a = null;       //对象{}的引用计数为2-1<br>所以这时对象{}不会被回收;<br>IE 6, 7 对DOM对象进行引用计数回收， 这样简单的垃圾回收机制，非常容易出现循环引用问题导致内存不能被回收， 进行导致内存泄露等问题，一般不用引用计数法。<br>第二，标记清除法<br>到2008年为止，IE,Firefox,Opera,Chrome和Safari的javascript实现使用的都是标记清除式的垃圾收集策略（或类似的策略），只不过垃圾收集的时间间隔互有不同。<br>标记清除的算法分为两个阶段，标记(mark)和清除(sweep). 第一阶段从引用根节点开始标记所有被引用的对象，第二阶段遍历整个堆，把未标记的对象清除。</p>
<hr>
<h2 id="javascript创建对象的几种方式？"><a href="#javascript创建对象的几种方式？" class="headerlink" title="javascript创建对象的几种方式？"></a>javascript创建对象的几种方式？</h2><p> javascript创建对象简单的说,无非就是使用内置对象或各种自定义对象，当然还可以用JSON；但写法有很多种，也能混合使用。</p>
<p> 1、对象字面量的方式</p>
<pre><code>person={firstname:&quot;Mark&quot;,lastname:&quot;Yun&quot;,age:25,eyecolor:&quot;black&quot;};
</code></pre><p> 2、用function来模拟无参的构造函数</p>
<pre><code>function Person(){}
var person=new Person();//定义一个function，如果使用new&quot;实例化&quot;,该function可以看作是一个Class
person.name=&quot;Mark&quot;;
person.age=&quot;25&quot;;
person.work=function(){
alert(person.name+&quot; hello...&quot;);
}
person.work();
</code></pre><p> 3、用function来模拟参构造函数来实现（用this关键字定义构造的上下文属性）</p>
<pre><code>function Pet(name,age,hobby){
   this.name=name;//this作用域：当前对象
   this.age=age;
   this.hobby=hobby;
   this.eat=function(){
      alert(&quot;我叫&quot;+this.name+&quot;,我喜欢&quot;+this.hobby+&quot;,是个程序员&quot;);
   }
}
var maidou =new Pet(&quot;麦兜&quot;,25,&quot;coding&quot;);//实例化、创建对象
maidou.eat();//调用eat方法
</code></pre><p> 4、用工厂方式来创建（内置对象）</p>
<pre><code>var wcDog =new Object();
wcDog.name=&quot;旺财&quot;;
wcDog.age=3;
wcDog.work=function(){
  alert(&quot;我是&quot;+wcDog.name+&quot;,汪汪汪......&quot;);
}
wcDog.work();
</code></pre><p> 5、用原型方式来创建</p>
<pre><code>function Dog(){

 }
 Dog.prototype.name=&quot;旺财&quot;;
 Dog.prototype.eat=function(){
 alert(this.name+&quot;是个吃货&quot;);
 }
 var wangcai =new Dog();
 wangcai.eat();
</code></pre><p> 5、用混合方式来创建</p>
<pre><code>function Car(name,price){
  this.name=name;
  this.price=price;
}
 Car.prototype.sell=function(){
   alert(&quot;我是&quot;+this.name+&quot;，我现在卖&quot;+this.price+&quot;万元&quot;);
  }
var camry =new Car(&quot;凯美瑞&quot;,27);
camry.sell();
</code></pre><hr>
<h2 id="JavaScript有几种类型的值？，你能画一下他们的内存图吗？"><a href="#JavaScript有几种类型的值？，你能画一下他们的内存图吗？" class="headerlink" title="JavaScript有几种类型的值？，你能画一下他们的内存图吗？"></a>JavaScript有几种类型的值？，你能画一下他们的内存图吗？</h2><p> 栈：原始数据类型（Undefined，Null，Boolean，Number、String）<br> 堆：引用数据类型（对象、数组和函数）</p>
<p> 两种类型的区别是：存储位置不同；<br> 原始数据类型直接存储在栈(stack)中的简单数据段，占据空间小、大小固定，属于被频繁使用数据，所以放入栈中存储；<br> 引用数据类型存储在堆(heap)中的对象,占据空间大、大小不固定。如果存储在栈中，将会影响程序运行的性能；引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2377897-f0c90cfaba1aabac.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<hr>
<h2 id="说几条写JavaScript的基本规范？"><a href="#说几条写JavaScript的基本规范？" class="headerlink" title="说几条写JavaScript的基本规范？"></a>说几条写JavaScript的基本规范？</h2><p> 1.不要在同一行声明多个变量。<br> 2.请使用 ===/!==来比较true/false或者数值<br> 3.使用对象字面量替代new Array这种形式<br> 4.不要使用全局函数。<br> 5.Switch语句必须带有default分支<br> 6.函数不应该有时候有返回值，有时候没有返回值。<br> 7.For循环必须使用大括号<br> 8.If语句必须使用大括号<br> 9.for-in循环中的变量 应该使用var关键字明确限定作用域，从而避免作用域污染。</p>
<hr>
<h1 id="ES6"><a href="#ES6" class="headerlink" title="ES6"></a>ES6</h1><h2 id="项目中常用的有哪些"><a href="#项目中常用的有哪些" class="headerlink" title="项目中常用的有哪些"></a>项目中常用的有哪些</h2><p>模块化 import export<br><a href="http://m.blog.csdn.net/Dong_PT/article/details/52701184" target="_blank" rel="external">http://m.blog.csdn.net/Dong_PT/article/details/52701184</a></p>
<h2 id="promise"><a href="#promise" class="headerlink" title="promise"></a>promise</h2><ul>
<li>如何解决回调问题？<br>目的是为异步操作提供统一接口，它使得异步操作具备同步操作的接口，使得程序具备正常的同步运行的流程，回调函数不必再一层层嵌套。</li>
<li>Promise些缺点。<ul>
<li>无法取消Promise<br>一旦新建它就会立即执行，无法中途取消。</li>
<li>必须设置回调函数<br>其次，如果不设置回调函数，Promise内部抛出的错误，不会反应到外部。</li>
<li>处于Pending不知阶段<br>当处于Pending状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。</li>
</ul>
</li>
<li>Promise对象只有三种状态:<br>未完成：pending<br>已完成：resolved(也称fulfilled)<br>失败：rejected<br>以上三种状态只有以下两种变化,一旦当前状态变为“resolved”或“rejected”，就意味着不会再有新的状态变化<br>1、pending-&gt;resolved （reslove()）<br>2、pending-&gt;rejected   ( reject()  )<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line">function Promise(executor) &#123;</span><br><span class="line">  var _this = this</span><br><span class="line">  _this.status = &apos;pending&apos; // Promise当前的状态</span><br><span class="line">  _this.data = undefined  // Promise的值</span><br><span class="line">  _this.onResolvedCallback = [] // Promise resolve时的回调函数集，因为在Promise结束之前有可能有多个回调添加到它上面</span><br><span class="line">  _this.onRejectedCallback = [] // Promise reject时的回调函数集，因为在Promise结束之前有可能有多个回调添加到它上面</span><br><span class="line"></span><br><span class="line">//resolve</span><br><span class="line">  function resolve(value)&#123;</span><br><span class="line">    setTimeout(function()&#123; //异步执行</span><br><span class="line">      if(_this.status == &apos;pending&apos;)&#123;</span><br><span class="line">          _this.status = &apos;resolved&apos;;</span><br><span class="line">          _this.data = value;</span><br><span class="line">      &#125;</span><br><span class="line">    for(var i=0;i&lt; _this.onResolvedCallback.length;i++)&#123;</span><br><span class="line">      _this. _this.onResolvedCallback[i](value);</span><br><span class="line">    &#125;</span><br><span class="line">   &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  //reject</span><br><span class="line">  function reject(reason)&#123;</span><br><span class="line">    setTimeout(function()&#123; //异步</span><br><span class="line">      if(_this.status == &apos;pending&apos;)&#123;</span><br><span class="line">          _this.status =&apos;rejected&apos;;</span><br><span class="line">          _this.data = reason;</span><br><span class="line">      &#125;</span><br><span class="line">      for(var i=0;i&lt; _this.onRejectedCallback.length;i++)&#123;</span><br><span class="line">        _this.onRejectedCallback[i](reason);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  try &#123;</span><br><span class="line">      executor(resolve, reject) // 执行executor并传入相应的参数</span><br><span class="line">  &#125;catch(e)&#123;</span><br><span class="line">      reject(e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;//end</span><br><span class="line">// then方法接收两个参数，onResolved，onRejected，分别为Promise成功或失败后的回调</span><br><span class="line"></span><br><span class="line">Promise.prototype.then = function(onResolved,onRejected)&#123;</span><br><span class="line">  var _this = this;</span><br><span class="line">  var promise2;</span><br><span class="line">   // 根据标准，如果then的参数不是function，则我们需要忽略它，此处以如下方式处理   实参留空 且让值可以穿透到后面</span><br><span class="line">  onResolved = typeof onResolved === &apos;function&apos; ? onResolved : function(value) &#123;return value;&#125;</span><br><span class="line">  onRejected = typeof onRejected === &apos;function&apos; ? onRejected : function(reason) &#123;return reason;&#125;</span><br><span class="line"></span><br><span class="line">  //Promise 里面有三种状态，我们分三个if来处理，在里面分别返回一个new Promise。</span><br><span class="line">  //根据标准我们知道，promise2的值取决于then里面函数的返回值。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   if (_this.status === &apos;resolved&apos;) &#123;</span><br><span class="line">      //此时this的状态已经是resolved ，所以我们这里执行onResolved</span><br><span class="line">      return promise2 = new Promise(function(resolve, reject) &#123;</span><br><span class="line">         try&#123;</span><br><span class="line">           var x = onResolved(_this.data)</span><br><span class="line">           if (x instanceof Promise) &#123; </span><br><span class="line">            // 如果onResolved的返回值是一个Promise对象，</span><br><span class="line">            //直接取它的结果做为promise2的结果</span><br><span class="line">                x.then(resolve, reject)</span><br><span class="line">            &#125;</span><br><span class="line">            resolve(x) // 否则，以它的返回值做为promise2的结果</span><br><span class="line">        &#125;catch(e)&#123;</span><br><span class="line">            // 如果出错，以捕获到的错误做为promise2的结果</span><br><span class="line">           reject(e) ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  if (_this.status === &apos;rejected&apos;) &#123;</span><br><span class="line">      //此时this的状态已经是rejected ，所以我们这里执行onRejected</span><br><span class="line">     return promise2 = new Promise(function(resolve, reject) &#123;</span><br><span class="line">          try &#123;</span><br><span class="line">              var x = onRejected(self.data)</span><br><span class="line">              if (x instanceof Promise) &#123;</span><br><span class="line">                  x.then(resolve, reject)</span><br><span class="line">              &#125;</span><br><span class="line">          &#125; catch (e) &#123;</span><br><span class="line">              reject(e)</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  if (_this.status === &apos;pending&apos;) &#123;</span><br><span class="line">   // 如果当前的Promise还处于pending状态，我们并不能确定调用onResolved还是onRejected，</span><br><span class="line">   // 只能等到Promise的状态确定后，才能确实如何处理。</span><br><span class="line">  // 所以我们需要把我们的**两种情况**的处理逻辑做为callback放入this的回调数组里</span><br><span class="line">    return promise2 = new Promise(function(resolve, reject) &#123;</span><br><span class="line"></span><br><span class="line">          _this.onResolvedCallback.push(function(value) &#123;</span><br><span class="line">              try &#123;</span><br><span class="line">                var x = onResolved(_this.data)</span><br><span class="line">                if (x instanceof Promise) &#123;</span><br><span class="line">                    x.then(resolve, reject)</span><br><span class="line">                &#125;</span><br><span class="line">              &#125; catch (e) &#123;</span><br><span class="line">                 reject(e)</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;);</span><br><span class="line"></span><br><span class="line">         _this. onRejectedCallback.push(function(resaon) &#123;</span><br><span class="line">              try &#123;</span><br><span class="line">                var x = onRejected(_this.data)</span><br><span class="line">                if (x instanceof Promise) &#123;</span><br><span class="line">                    x.then(resolve, reject)</span><br><span class="line">                &#125;</span><br><span class="line">              &#125; catch (e) &#123;</span><br><span class="line">                 reject(e)</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;);</span><br><span class="line"></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h2 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h2><p><a href="http://blog.csdn.net/yangbingbinga/article/details/61424363" target="_blank" rel="external">http://blog.csdn.net/yangbingbinga/article/details/61424363</a></p>
<h3 id="箭头函数中的this"><a href="#箭头函数中的this" class="headerlink" title="箭头函数中的this"></a><strong>箭头函数中的this</strong></h3><p>箭头函数中的this默认指向在定义它时,它所处的对象,而不是执行时的对象, 定义它的时候,可能环境是window<br>下面通过一些例子来研究一下 this的一些使用场景[ 使用最新版 chrome<a href="http://lib.csdn.net/base/softwaretest" target="_blank" rel="external">测试</a> ]</p>
<h3 id="一层箭头函数-：箭头函数中的-this指向，箭头函数存在的对象"><a href="#一层箭头函数-：箭头函数中的-this指向，箭头函数存在的对象" class="headerlink" title="一层箭头函数 ：箭头函数中的 this指向，箭头函数存在的对象"></a>一层箭头函数 ：箭头函数中的 this指向，箭头函数存在的对象</h3> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  var obj = &#123;</span><br><span class="line">    say: function () &#123;</span><br><span class="line">      setTimeout(() =&gt; &#123;</span><br><span class="line">        console.log(this)</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  obj.say(); // obj</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>此时的 this指的是定义它的对象, obj,而不是 window</p>
<h3 id="多层嵌套的箭头函数-：箭头函数中的this都指向外层箭头函数所处的对象"><a href="#多层嵌套的箭头函数-：箭头函数中的this都指向外层箭头函数所处的对象" class="headerlink" title="多层嵌套的箭头函数 ：箭头函数中的this都指向外层箭头函数所处的对象"></a>多层嵌套的箭头函数 ：箭头函数中的this都指向外层箭头函数所处的对象</h3><p>因为f1定义时所处的函数 中的 this是指的 obj所以不管有多层嵌套,都是 obj<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  var obj = &#123;</span><br><span class="line">    say: function () &#123;</span><br><span class="line">      var f1 = () =&gt; &#123;</span><br><span class="line">        console.log(this); // obj</span><br><span class="line">        setTimeout(() =&gt; &#123;</span><br><span class="line">          console.log(this); // obj</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">      f1();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  obj.say()</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>
<h3 id="普通函数和箭头函数混杂嵌套，箭头函数this指向都是-window"><a href="#普通函数和箭头函数混杂嵌套，箭头函数this指向都是-window" class="headerlink" title="普通函数和箭头函数混杂嵌套，箭头函数this指向都是 window,"></a>普通函数和箭头函数混杂嵌套，箭头函数this指向都是 window,</h3><p>都是 window,因为 箭头函数在定义的时候它所处的环境相当于是window所以在箭头函数内部的this函数window<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  var obj = &#123;</span><br><span class="line">    say: function () &#123;</span><br><span class="line">      var f1 = function () &#123;</span><br><span class="line">        console.log(this);    // window, f1调用时,没有宿主对象,默认是window</span><br><span class="line">        setTimeout(() =&gt; &#123;</span><br><span class="line">          console.log(this); // window</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;;</span><br><span class="line">      f1();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  obj.say()</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>
<h3 id="严格模式下"><a href="#严格模式下" class="headerlink" title="严格模式下"></a>严格模式下</h3><p> 严格模式下,没有宿主调用的函数中的this是undefined!!!所以箭头函数中的也是undefined!</p>
<h2 id="es6扩充的api"><a href="#es6扩充的api" class="headerlink" title="es6扩充的api"></a>es6扩充的api</h2><ul>
<li>作用域let,const<ul>
<li>有了块级作用域</li>
<li>不存在变量提升</li>
<li>let变量所在作用域，先声明后使用</li>
<li>let不允许在相同作用域内，重复声明同一个变量<br>（不能在函数内部重新声明参数。）</li>
<li>不再需要立即执行函数模拟块级作用域</li>
<li>const一旦声明变量，就必须立即初始化，不能留到以后赋值。(区分let)</li>
</ul>
</li>
<li>map<br>因为原生js中的 obj={},obj的key只能是字符串，为了扩展这一功能 实现新的数据类型Map。</li>
<li>set<br>set和map一样，但是set中的obj不能重复</li>
</ul>
<hr>
<h2 id="es5中的filter-forEach-map"><a href="#es5中的filter-forEach-map" class="headerlink" title="es5中的filter,forEach,map"></a>es5中的filter,forEach,map</h2><h3 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h3><p>filter(callback,thisArg)<br>thisArg可选。执行 callback 时的用于 this 的值。<br> 为数组中的每个元素调用一次 callback<br> 函数，并利用所有使得 callback<br> 返回 true 或 的元素创建一个新数组。</p>
<p>callback<br> 只会在已经赋值的索引上被调用，对于那些已经被删除或者从未被赋值的索引    不会被调用。那些没有通过 callback<br>测试的元素会被跳过，不会被包含在新数组中。</p>
<p>callback 被调用时传入三个参数：<br>元素的值<br>元素的索引<br>被遍历的数组</p>
<h3 id="forEach与map-each"><a href="#forEach与map-each" class="headerlink" title="forEach与map,$().each"></a>forEach与map,$().each</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//forEach</span><br><span class="line">array.forEach(callback(currentValue, index, array)&#123;</span><br><span class="line">    //do something</span><br><span class="line">&#125;)　　</span><br><span class="line"> </span><br><span class="line">//map:</span><br><span class="line">var new_array = arr.map(callback[, thisArg])　</span><br><span class="line"> </span><br><span class="line">//$.each()</span><br><span class="line">$(selector).each(function(index,element))</span><br></pre></td></tr></table></figure>
<p>二、区别</p>
<p>2.1、forEach()返回值是undefined，不可以链式调用。</p>
<p>2.2、map()返回一个新数组，原数组不会改变。</p>
<p>2.3、没有办法终止或者跳出forEach()循环，除非抛出异常，所以想执行一个数组是否满足什么条件，返回布尔值，可以用一般的for循环实现，或者用Array.every()或者Array.some();</p>
<p>2.4、$.each()方法规定为每个匹配元素规定运行的函数，可以返回 false 可用于及早停止循环。</p>
<hr>
<h2 id="slice，splice的区别"><a href="#slice，splice的区别" class="headerlink" title="slice，splice的区别"></a>slice，splice的区别</h2><p>slice :获得新数组，不改变原来数组<br>splice( para1,para2 ) : 删除数组中任意数量的项(改变数组以及长度)<br>从para1开始的para2项。注意的是用splice删除数组中的值会直接将某几项从数组中完全删除，会导致数组length值的改变</p>
<hr>
<h2 id="es7中的aysnc-await"><a href="#es7中的aysnc-await" class="headerlink" title="es7中的aysnc await"></a>es7中的aysnc await</h2><hr>
<h2 id="除了promise-还有其他的异步方式？"><a href="#除了promise-还有其他的异步方式？" class="headerlink" title="除了promise,还有其他的异步方式？"></a>除了promise,还有其他的异步方式？</h2><p><a href="http://www.jianshu.com/p/78dfb38ac3d7?winzoom=1" target="_blank" rel="external">http://www.jianshu.com/p/78dfb38ac3d7?winzoom=1</a></p>
<ul>
<li>promise</li>
<li>generator,可中断</li>
<li>async,await;<h3 id="async"><a href="#async" class="headerlink" title="async"></a>async</h3>async函数声明定义了异步函数，它会返回一个AsyncFunction对象。和普通函数一样，你也可以定义一个异步函数表达式。</li>
</ul>
<p>调用异步函数时会返回一个promise对象。当这个异步函数成功返回一个值时，将会使用promise的resolve方法来处理这个返回值，当异步函数抛出的是异常或者非法值时，将会使用promise的reject方法来处理这个异常值。</p>
<p>异步函数可能会包括await表达式，这将会使异步函数暂停执行并等待promise解析传值后，继续执行异步函数并返回解析值。</p>
<p>注意：await只能用在async函数中。</p>
<p>前面依次读取两个文件的代码写成async函数如下：<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var asyncReadFile = async function ()&#123;</span><br><span class="line">  var f1 = await readFile(&apos;/etc/fstab&apos;)</span><br><span class="line">  var f2 = await readFile(&apos;/etc/shells&apos;)</span><br><span class="line">  console.log(f1.toString())</span><br><span class="line">  console.log(f2.toString())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="angular"><a href="#angular" class="headerlink" title="angular"></a>angular</h1><h2 id="Angular、Vue、React"><a href="#Angular、Vue、React" class="headerlink" title="Angular、Vue、React"></a>Angular、Vue、React</h2><p>Angular、Vue、React，因为这些库或者框架都是基于现有端的业务体系，基于用户体验和开发者体验演进出来技术方案，并没有什么优劣之分，各有各的长处。而在整个前端演进过程中，只是一块很小的内容。<br>Angular 约束多，擅长复杂中后台场景和多人协作或者复杂业务处理。<br>Vue 灵活，适用于简单业务快速迭代（当然也有 Vue 做中后台的）。<br>React 组件化设计的好，可以实现比较好的组件生态进行复用。<br>对于这些框架，只需要基于现有的业务体系和开发者经验，做好最佳的技术方案选型。<br>在某些场景下甚至 jQuery 反而是更好的技术选型。<br>哪个库或者框架适合你的业务形态，可以给你带来稳定的系统和好的用户体验，让你有高效的开发效率，当然就选哪个了<br>使用什么框架不重要，重要的是特定业务的解决思想和方案</p>
<h2 id="项目中应用知识点"><a href="#项目中应用知识点" class="headerlink" title="项目中应用知识点"></a>项目中应用知识点</h2><h3 id="自定义指令"><a href="#自定义指令" class="headerlink" title="自定义指令"></a>自定义指令</h3><p><a href="http://www.cnblogs.com/ermu-learn/p/5913760.html" target="_blank" rel="external">http://www.cnblogs.com/ermu-learn/p/5913760.html</a><br><a href="http://blog.csdn.net/qq_27626333/article/details/52261409" target="_blank" rel="external">http://blog.csdn.net/qq_27626333/article/details/52261409</a></p>
<h2 id="常见问题-http-www-jianshu-com-p-df5c12d45acf"><a href="#常见问题-http-www-jianshu-com-p-df5c12d45acf" class="headerlink" title="常见问题 http://www.jianshu.com/p/df5c12d45acf"></a>常见问题 <a href="http://www.jianshu.com/p/df5c12d45acf" target="_blank" rel="external">http://www.jianshu.com/p/df5c12d45acf</a></h2><hr>
<h2 id="1：双向数据绑定的原理"><a href="#1：双向数据绑定的原理" class="headerlink" title="1：双向数据绑定的原理"></a>1：双向数据绑定的原理</h2><p><a href="http://www.jianshu.com/p/0ce33902a7b7" target="_blank" rel="external">http://www.jianshu.com/p/0ce33902a7b7</a><br><a href="http://blog.csdn.net/tanglei6636/article/details/52183758" target="_blank" rel="external">http://blog.csdn.net/tanglei6636/article/details/52183758</a></p>
<p>angualr数据绑定基于脏检查机制(dirty-checking)：</p>
<hr>
<h3 id="三个概念"><a href="#三个概念" class="headerlink" title="三个概念"></a>三个概念</h3><ul>
<li>$digest()：脏值检查循环</li>
<li>$watch：添加监听</li>
<li>$apply：提供上下文执行表达式,进入digest<h3 id="触发脏检测的事件"><a href="#触发脏检测的事件" class="headerlink" title="触发脏检测的事件"></a>触发脏检测的事件</h3>DOM事件，譬如用户输入文本，点击按钮等。(ng-click)<br>XHR响应事件 ($http)<br>浏览器Location变更事件 ($location)<br>Timer事件($timeout, $interval)<br>执行$digest()或$apply()<h3 id="【脏检查过程】"><a href="#【脏检查过程】" class="headerlink" title="【脏检查过程】"></a>【脏检查过程】</h3><ul>
<li>Model UI ，监听<br>绑定数据到UI会有watch监听（$watch就是那个可以检测它监视的model里时候有变化的东西）</li>
<li>触发脏检查digest<br>（angular对，常用的dom事件，xhr事件等做了封装， 在里面触发进入angular的digest流程）</li>
<li>间接调用$digest<br>ng实际调用$scope.apply() ，再调用 $rootScope.$digest(),一轮$digest循环在$rootScope开始，随后会访问到所有的children scope中的watchers.</li>
<li>watcher检查<br>每个watcher检查scope中的当前model值和上一次计算得到的model值是否相同</li>
<li>若不同，那么$watch()对应的回调函数会被执行，回调函数的执行结果为新的数据。</li>
<li>它会强制再执行一次$digest循环，若没检测到变化，则更新view。</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>angualr不存在定时脏检测，angular对，常用的dom事件，xhr事件等做了封装， 在里面触发进入angular的digest流程。在digest流程里面， 会从rootscope开始遍历， 检查所有的watcher。</li>
<li>当写下表达式,在scope模型上设置一个watcher，用来监听数据发生变化的时候更新view</li>
<li>每次你绑定一些东西到你的UI上时你就会往$watch队列里插入一条$watch。想象一下$watch就是那个可以检测它监视的model里时候有变化的东西。</li>
<li>$digest会检查scope模型数据是否变化。ng实际调用$scope.apply() ，再调用 $rootScope.$digest(),一轮$digest循环在$rootScope开始，随后会访问到所有的children scope中的watchers。</li>
<li>每个watcher检查scope中的当前model值和上一次计算得到的model值是否不同,</li>
<li>不同，那么$watch()对应的回调函数会被执行，回调函数的执行结果为新的数据。</li>
<li>它会强制再执行一次$digest循环，若没检测到变化，则更新view</li>
</ul>
<hr>
<h3 id="脏检查机制的弊端"><a href="#脏检查机制的弊端" class="headerlink" title="脏检查机制的弊端"></a>脏检查机制的弊端</h3><p>一直都要触发脏检查<br>使得笨重，性能降低</p>
<hr>
<h2 id="angualr1一次性数据绑定"><a href="#angualr1一次性数据绑定" class="headerlink" title="angualr1一次性数据绑定"></a>angualr1一次性数据绑定</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;Hello &#123;&#123;::name&#125;&#125;!&lt;/p&gt;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="Angular2数据绑定"><a href="#Angular2数据绑定" class="headerlink" title="Angular2数据绑定"></a>Angular2数据绑定</h2><p>在Angular2里面，绑定的数据的监听是通过zone.js或者说代理模式实现。<br>通俗来讲，zone给所有有可能更新数据的方法加了一个补丁。每当这些更新数据的方法被调用的时候，就会触发另一个方法，告诉Angular有数据修改，Angular再去判断变量是否修改，如果有修改，就更新DOM。</p>
<h2 id="MVC与MVVM的区别"><a href="#MVC与MVVM的区别" class="headerlink" title="MVC与MVVM的区别"></a>MVC与MVVM的区别</h2><h3 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h3><p>MVC所有的通信都是单向的；<br>v-&gt;C,C-&gt;M,M-&gt;V</p>
<h3 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">M----&gt; model 模型层（一般用于数据存储，存储一些业务逻辑），也就是我们说的数据模型。</span><br><span class="line">V-----&gt; view 视图层（界面），用来展示数据。</span><br><span class="line">VM--&gt; ViewModel（视图模型） 也就是$scope。</span><br><span class="line">M和与VM之间的通信的双向的</span><br></pre></td></tr></table></figure>
<p><img src="http://upload-images.jianshu.io/upload_images/2377897-1be36cea38a0d7e4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<hr>
<h2 id="使用angular的优缺点"><a href="#使用angular的优缺点" class="headerlink" title="使用angular的优缺点"></a>使用angular的优缺点</h2><h3 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h3><ol>
<li>模板功能强大丰富，并且是声明式的，自带了丰富的Angular指令；</li>
<li>是一个比较完善的前端MV*框架，包含模板，数据双向绑定，路由，模块化，服务，过滤器等所有功能；</li>
<li>自定义Directive，比jQuery插件还灵活，但是需要深入了解Directive的一些特性，简单的封装容易，复杂一点官方没有提供详细的介绍文档，我们可以通过阅读源代码来找到某些我们需要的东西，如：在directive使用 $parse；</li>
<li>ng模块化比较大胆的引入了Java的一些东西（依赖注入），能够很容易的写出可复用的代码，对于敏捷开发的团队来说非常有帮助，我们的项目从上线到目前，UI变化很大，在摸索中迭代产品，但是js的代码基本上很少改动。</li>
<li>补充：Angular支持单元测试和e2e-testing。<h3 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h3></li>
<li>Angular 太笨重了，没有让用户选择一个轻量级的版本，当然1.2.X后，Angular也在做一些更改，比如把route，animate等模块独立出去，让用户自己去选择。</li>
<li>ngView只能有一个，不能嵌套多个视图，虽然有 <a href="https://link.zhihu.com/?target=https%3A//github.com/angular-ui/ui-router" target="_blank" rel="external">angular-ui/ui-router · GitHub**</a> 解决，但是貌似ui-router 对于URL的控制不是很灵活，必须是嵌套式的（也许我没有深入了解或者新版本有改进）；</li>
</ol>
<p>当然使用的人多才会暴露更多的问题，一起为这些问题寻找解决方案是一个社区的良性趋势，选择Angular，的确使我们的开发效率大大提高。</p>
<hr>
<h1 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h1><h2 id="说一下有哪些常用的模块化方案，各自有哪些使用场景和区别"><a href="#说一下有哪些常用的模块化方案，各自有哪些使用场景和区别" class="headerlink" title="说一下有哪些常用的模块化方案，各自有哪些使用场景和区别"></a>说一下有哪些常用的模块化方案，各自有哪些使用场景和区别</h2><h3 id="require-js-AMD"><a href="#require-js-AMD" class="headerlink" title="require.js -AMD"></a>require.js -AMD</h3><ul>
<li>异步</li>
<li>发展：<br>Require.JS在发展成浏览器端的模块加载器的同时向 Rhino / Node 等环境的模块加载器发展<h3 id="sea-js-CMD"><a href="#sea-js-CMD" class="headerlink" title="sea.js - CMD"></a>sea.js - CMD</h3></li>
<li>异步</li>
<li>发展：<br>Sea.js 专门发展 Web 浏览器端<h3 id="CommonJS"><a href="#CommonJS" class="headerlink" title="CommonJS"></a>CommonJS</h3></li>
<li>同步，使用在服务器端</li>
<li>优点：<br>服务器端便于重用<br>简单并容易使用</li>
<li>缺点：<br>同步的模块方式不适合在浏览器环境中，同步意味着阻塞加载，浏览器资源是异步加载的<br>不能非阻塞的并行加载多个模块</li>
</ul>
<blockquote>
<p>A.js文件中调用另一个B.js文件，一定要在A.js中引入B.js<br>   require(“B.js”);<br>   另一个被调用的js，也就是B.js一定要对外提供接口。<br>   module.exports=b</p>
</blockquote>
<h3 id="es6模块化"><a href="#es6模块化" class="headerlink" title="es6模块化"></a>es6模块化</h3><p>ECMAScript 6 模块化的目标是创建一种 CommonJS 和 AMD 使用者都乐意接受的方式：</p>
<ul>
<li><ol>
<li>类似 CommonJS，拥有简洁的语法，倾向于单一的接口并且支持循环依赖。</li>
</ol>
</li>
<li><ol>
<li>类似 AMD，直接支持异步加载和配置模块加载。</li>
</ol>
</li>
</ul>
<p>内置语言允许 ES6 模块化超出 CommonJS 和 AMD 规范（之后会详细介绍）：</p>
<ul>
<li><ol>
<li>语法将比 CommonJS 的更简洁。</li>
</ol>
</li>
<li><ol>
<li>比 CommonJS 做的更好的循环依赖。</li>
</ol>
</li>
<li><ol>
<li>结构可以做静态分析（静态检测，优化等）。</li>
</ol>
<p>ES6 模块化标准包括两部分：</p>
</li>
<li><ol>
<li>声明语法（引入与导出）。</li>
</ol>
</li>
<li><ol>
<li>编程式加载接口：用来配置如何加载模块和按条件加载模块。</li>
</ol>
</li>
<li>它能够更加精确地定义模块间哪些需要被 exposed/imported </li>
<li>使得在编译时就能确定模块的依赖关系，同时使得前端在复杂项目时可以更好的分工和规范。</li>
</ul>
<hr>
<h3 id="UMD"><a href="#UMD" class="headerlink" title="UMD"></a>UMD</h3><p>UMD是AMD和CommonJS的糅合</p>
<p>AMD模块以浏览器第一的原则发展，异步加载模块。<br>CommonJS模块以服务器第一原则发展，选择同步加载，它的模块无需包装<br>这迫使人们又想出另一个更通用的模式UMD ,希望解决跨平台的解决方案。 UMD先判断是否支持Node.js的模块（exports）是否存在，存在则使用Node.js模块模式。<br>在判断是否支持AMD（define是否存在），存在则使用AMD方式加载模块。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">(function (window, factory) &#123;</span><br><span class="line">    if (typeof exports === &apos;object&apos;) &#123;</span><br><span class="line">     </span><br><span class="line">        module.exports = factory();</span><br><span class="line">    &#125; else if (typeof define === &apos;function&apos; &amp;&amp; define.amd) &#123;</span><br><span class="line">     </span><br><span class="line">        define(factory);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">     </span><br><span class="line">        window.eventUtil = factory();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)(this, function () &#123;</span><br><span class="line">    //module ...</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<hr>
<h3 id="require-js-与sea-js"><a href="#require-js-与sea-js" class="headerlink" title="require.js 与sea.js"></a>require.js 与sea.js</h3><ul>
<li>都是异步模块加载</li>
<li>对依赖模块的执行时机处理所不同<ul>
<li>AMD推崇依赖前置，在定义模块的时候就要声明其依赖的模块<ul>
<li>define(id?, dependencies?, factory);</li>
<li>js可以方便知道依赖模块是谁，立即加载</li>
<li>AMD在加载模块完成后就会执行改模块，所有模块都加载执行完后会进入require的回调函数，执行主逻辑，这样的效果就是依赖模块的执行顺序和书写顺序不一定一致，看网络速度，哪个先下载下来，哪个先执行，但是主逻辑一定在所有依赖加载完成后才执行</li>
</ul>
</li>
<li>CMD推崇就近依赖，什么时候用到什么时候加载<ul>
<li>需要使用把模块变为字符串解析一遍才知道依赖了那些模块</li>
<li>CMD加载完某个依赖模块后并不执行，只是下载而已，在所有依赖模块加载完成后进入主逻辑，遇到require语句的时候才执行对应的模块，这样模块的执行顺序和书写顺序是完全一致的</li>
</ul>
</li>
<li>这也是很多人说AMD用户体验好，因为没有延迟，依赖模块提前执行了，CMD性能好，因为只有用户需要的时候才执行的原因<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">//AMD</span><br><span class="line">define([&apos;./a&apos;,&apos;./b&apos;], function (a, b) &#123;</span><br><span class="line"> </span><br><span class="line">    //依赖一开始就写好</span><br><span class="line">    a.test();</span><br><span class="line">    b.test();</span><br><span class="line">&#125;);</span><br><span class="line"> </span><br><span class="line">//CMD</span><br><span class="line">define(function (requie, exports, module) &#123;</span><br><span class="line">     </span><br><span class="line">    //依赖可以就近书写</span><br><span class="line">    var a = require(&apos;./a&apos;);</span><br><span class="line">    a.test();</span><br><span class="line">     </span><br><span class="line">    ...</span><br><span class="line">    //软依赖</span><br><span class="line">    if (status) &#123;</span><br><span class="line">     </span><br><span class="line">        var b = requie(&apos;./b&apos;);</span><br><span class="line">        b.test();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h3 id="gulp-模块化"><a href="#gulp-模块化" class="headerlink" title="gulp 模块化"></a>gulp 模块化</h3><p>在gulpfile里编写任务实现模块化<br>gulpfile.js<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//基本模块引入</span><br><span class="line">var gulp = require(&apos;gulp&apos;);</span><br><span class="line">var brow = require(&apos;browerify&apos;);</span><br><span class="line">var source = require(&apos;vinyl-source-stream&apos;);</span><br><span class="line">//任务编写</span><br><span class="line">gulp.task(&apos;bundle&apos;, function() &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   //将任务交付给browserify</span><br><span class="line">   //browerify读取入口文件后，能自动查找相互之间有依赖的关系的模块</span><br><span class="line">   return brow(&apos;./entry.js&apos;)</span><br><span class="line">  .bundle()//输出一个文件流变量（gulp的工作机制）</span><br><span class="line">  .pipe(source(&apos;bundle.js&apos;))//将文件流变量输出为文件</span><br><span class="line">  .pipe(gulp.dest(&apos;js&apos;));//将文件最终输出</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<p><img src="http://upload-images.jianshu.io/upload_images/2377897-ff8c9d3c45a31e50.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="20170111164714676.jpg"></p>
<h2 id="你了解的模块化"><a href="#你了解的模块化" class="headerlink" title="你了解的模块化"></a>你了解的模块化</h2><p><a href="http://www.jianshu.com/p/042dd3576508" target="_blank" rel="external">http://www.jianshu.com/p/042dd3576508</a><br><a href="http://www.jianshu.com/p/9171c5496c8e" target="_blank" rel="external">http://www.jianshu.com/p/9171c5496c8e</a><br><a href="https://segmentfault.com/a/1190000006215047" target="_blank" rel="external">https://segmentfault.com/a/1190000006215047</a></p>
<h2 id="commonjs"><a href="#commonjs" class="headerlink" title="commonjs"></a>commonjs</h2><ul>
<li>①模块化：指的就是遵守commonjs规范，解决不同js模块之间相互调用问题</li>
<li>②CommonJS：<br>A.js文件中调用另一个B.js文件，一定要在A.js中引入B.js<br>require(“B.js”);<br>另一个被调用的js，也就是B.js一定要对外提供接口。<br>module.exports=b</li>
<li>common:可以定义变量的作用域，还可以定义模块之间的依赖。<br>可惜这是专为 Node 设计的，不支持在浏览器运行，也不能异步加载模块<br>。但是，它可以在前端app使用，借助 Browserify 或者其他工具来转换，就可以让它在浏览器运行了。</li>
</ul>
<hr>
<h3 id="require-js-使用-AMD-异步模块声明-define-require"><a href="#require-js-使用-AMD-异步模块声明-define-require" class="headerlink" title="require.js 使用 AMD  异步模块声明(define + require)"></a>require.js 使用 AMD  异步模块声明(define + require)</h3><ul>
<li>效率高，可惜有点冗长，而且不能在 Node.js 本地运行。</li>
</ul>
<p>define(‘myModule’, [‘dep1’, ‘dep2’], function (dep1, dep2){<br>        // JavaScript chunk, with a potential deferred loading<br>        return {hello: () =&gt; console.log(‘hello from myModule’)};<br>    });<br>    // anywhere else<br>    require([‘myModule’], function (myModule) {<br>        myModule.hello() // display ‘hello form myModule’<br>    });</p>
<hr>
<h3 id="sea-js-使用-CMD-公共模块声明-exports-require"><a href="#sea-js-使用-CMD-公共模块声明-exports-require" class="headerlink" title="sea.js  使用 CMD 公共模块声明(exports + require)"></a>sea.js  使用 CMD 公共模块声明(exports + require)</h3><p>   define  定义一个模块<br>    require  加载一个模块<br>    export  暴露一个模块<br>    module  模块<br>sea.js、require.js中每个模块是单独的一个文件。每个模块都是define函数中设置暴露的功能。每个模块都是一个单独的作用域。</p>
<hr>
<h3 id="sea-对比require"><a href="#sea-对比require" class="headerlink" title="sea 对比require"></a>sea 对比require</h3><p>Sea.js与Require.js发展方向有差异，Require.JS在发展成浏览器端的模块加载器的同时向 Rhino / Node 等环境的模块加载器发展。Sea.js 专门发展 Web 浏览器端，同时通过 Node 扩展的方式也可以 在Node 环境中使用。</p>
<hr>
<h3 id="es6模块化-UMD-AMD-和-CommonJS"><a href="#es6模块化-UMD-AMD-和-CommonJS" class="headerlink" title="es6模块化 UMD(AMD 和 CommonJS)"></a>es6模块化 UMD(AMD 和 CommonJS)</h3><ul>
<li>ES6的模块化的基本规则或特点， 欢迎补充：<br>　1：每一个模块只加载一次， 每一个JS只执行一次， 如果下次再去加载同目录下同文件，直接从内存中读取。 一个模块就是一个单例，或者说就是一个对象；<br>　2：每一个模块内声明的变量都是局部变量， 不会污染全局作用域；<br>　3：模块内部的变量或者函数可以通过export导出；<br>　4：一个模块可以导入别的模块</li>
</ul>
<p>//lib.js<br>//导出常量<br>export const sqrt = Math.sqrt;<br>//导出函数<br>export function square(x) {<br>    return x * x;<br>}<br>//导出函数<br>export function diag(x, y) {<br>    return sqrt(square(x) + square(y));<br>}</p>
<p>//main.js<br>import { square, diag } from ‘./lib’;<br>console.log(square(11)); // 121<br>console.log(diag(4, 3)); // 5</p>
<hr>
<h2 id="使用模块化的好处？模块化可以解决的问题？"><a href="#使用模块化的好处？模块化可以解决的问题？" class="headerlink" title="使用模块化的好处？模块化可以解决的问题？"></a>使用模块化的好处？模块化可以解决的问题？</h2><p><a href="https://github.com/seajs/seajs/issues/547" target="_blank" rel="external">https://github.com/seajs/seajs/issues/547</a></p>
<ul>
<li>恼人的命名冲突<br>若将复用部分 提取到一个util.js文件中，自己定义的js中的函数名可能跟util.js中的函数重复</li>
<li><p>烦琐的文件依赖<br>我想在基于 util.js，其中有一个最被大家喜欢的组件是 dialog.js，使用方式很简单。<br>在 dialog.js 前没有引入 util.js，因此 dialog.js 无法正常工作。同样不要以为我上面的故事是虚构的，在我待过的公司里，至今依旧有类似的脚本报错，特别是在各种快速制作的营销页面中。</p>
</li>
<li><p>总：</p>
<ul>
<li>模块间相互调用，协同工作，实现某特定功能。</li>
<li>模块化的核心价值：模块化最核心的价值在于解决不同文件之间的分工和调用问题，即依赖关系。</li>
<li>模块的版本管理。通过别名等配置，配合构建工具，可以比较轻松地实现模块的版本管理。</li>
<li>提高可维护性。模块化可以让每个文件的职责单一，非常有利于代码的维护。</li>
<li>前端性能优化。Sea.js 通过异步加载模块，这对页面性能非常有益。Sea.js 还提供了 combo、flush 等插件，配合服务端，可以很好地对页面性能进行调优。</li>
<li>跨环境共享模块。CMD 模块定义规范与 Node.js 的模块规范非常相近。通过 Sea.js 的 Node.js 版本，可以很方便实现模块的跨服务器和浏览器共享。</li>
</ul>
</li>
</ul>
<hr>
<h1 id="Ajax"><a href="#Ajax" class="headerlink" title="Ajax"></a>Ajax</h1><h2 id="自己封装Ajax"><a href="#自己封装Ajax" class="headerlink" title="自己封装Ajax"></a>自己封装Ajax</h2><h3 id="基本步骤"><a href="#基本步骤" class="headerlink" title="基本步骤"></a>基本步骤</h3><h4 id="１-发送请求："><a href="#１-发送请求：" class="headerlink" title="１.发送请求："></a>１.发送请求：</h4><ul>
<li>var xhr=new XMLHttpRequest();</li>
<li>xhr.open(“GET”,”test1.txt”,true)：规定请求的类型、URL 以及是否异步处理请求。     </li>
<li>xhr.send()<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">xhr.open(method,url,async)&gt;</span><br><span class="line">     method：请求的类型；GET 或 POST</span><br><span class="line">      url：文件在服务器上的位置</span><br><span class="line">      async：true（异步）或 false（同步）</span><br><span class="line">      xhr.send()&gt;</span><br><span class="line">     send(string): 将请求发送到服务器。</span><br><span class="line">      string：仅用于 POST 请求</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="２-判断响应是否成功（获得响应数据）："><a href="#２-判断响应是否成功（获得响应数据）：" class="headerlink" title="２.判断响应是否成功（获得响应数据）："></a>２.判断响应是否成功（获得响应数据）：</h4><ul>
<li>知晓请求的状态 xhr.readyState==4,每次状态改变都会触发onreadystatechange<blockquote>
<p>0:请求未初始化<br> 1:与服务器连接已经建立<br> 2:服务器已经接收到请求<br> 3:服务器正在处理请求<br> 4:请求已经完成，且响应已经就绪
　</p>
<ul>
<li>监听服务器的状态码xhr.status == 200<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">xhr.onreadystatechange=function()&#123;</span><br><span class="line">            if(xhr.readyState==4 &amp;&amp;xhr.status==200 )&#123;</span><br><span class="line">                //执行响应数据 </span><br><span class="line">            &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</blockquote>
</li>
</ul>
<h4 id="注意：Ajax中get-post处理方式不一样"><a href="#注意：Ajax中get-post处理方式不一样" class="headerlink" title="注意：Ajax中get post处理方式不一样"></a>注意：Ajax中get post处理方式不一样</h4><ul>
<li>请求url不同<br>get: 请求数据会出现在url中：opt.url + ‘?’ + postData<br>post: opt.url</li>
<li>post需要设置请求头<br>这个请求头是告诉服务器怎么去解析请求的正文部分。</li>
<li>xhr.send<br>post: xhr.send(postData);<br>get: xmlHttp.send(null);</li>
</ul>
<h4 id="ajax实现完整代码"><a href="#ajax实现完整代码" class="headerlink" title="ajax实现完整代码"></a>ajax实现完整代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">/* 封装ajax函数</span><br><span class="line"> * @param &#123;string&#125;opt.type http连接的方式，包括POST和GET两种方式</span><br><span class="line"> * @param &#123;string&#125;opt.url 发送请求的url</span><br><span class="line"> * @param &#123;boolean&#125;opt.async 是否为异步请求，true为异步的，false为同步的</span><br><span class="line"> * @param &#123;object&#125;opt.data 发送的参数，格式为对象类型</span><br><span class="line"> * @param &#123;function&#125;opt.success ajax发送并接收成功调用的回调函数</span><br><span class="line"> */</span><br><span class="line">    function ajax(opt) &#123;</span><br><span class="line">        opt = opt || &#123;&#125;;</span><br><span class="line">        opt.method = opt.method.toUpperCase() || &apos;POST&apos;;</span><br><span class="line">        opt.url = opt.url || &apos;&apos;;</span><br><span class="line">        opt.async = opt.async || true;</span><br><span class="line">        opt.data = opt.data || null;</span><br><span class="line">        opt.success = opt.success || function () &#123;&#125;;</span><br><span class="line">        var xmlHttp = null;</span><br><span class="line">        if (XMLHttpRequest) &#123;</span><br><span class="line">            xmlHttp = new XMLHttpRequest();</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            xmlHttp = new ActiveXObject(&apos;Microsoft.XMLHTTP&apos;);</span><br><span class="line">        &#125;var params = [];</span><br><span class="line">        for (var key in opt.data)&#123;</span><br><span class="line">            params.push(key + &apos;=&apos; + opt.data[key]);</span><br><span class="line">        &#125;</span><br><span class="line">        var postData = params.join(&apos;&amp;&apos;);</span><br><span class="line">        if (opt.method.toUpperCase() === &apos;POST&apos;) &#123;</span><br><span class="line">            xmlHttp.open(opt.method, opt.url, opt.async);</span><br><span class="line">            xmlHttp.setRequestHeader(&apos;Content-Type&apos;, &apos;application/x-www-form-urlencoded;charset=utf-8&apos;);</span><br><span class="line">            xmlHttp.send(postData);</span><br><span class="line">        &#125;</span><br><span class="line">        else if (opt.method.toUpperCase() === &apos;GET&apos;) &#123;</span><br><span class="line">            xmlHttp.open(opt.method, opt.url + &apos;?&apos; + postData, opt.async);</span><br><span class="line">            xmlHttp.send(null);</span><br><span class="line">        &#125; </span><br><span class="line">        xmlHttp.onreadystatechange = function () &#123;</span><br><span class="line">            if (xmlHttp.readyState == 4 &amp;&amp; xmlHttp.status == 200) &#123;</span><br><span class="line">                opt.success(xmlHttp.responseText);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">//执行</span><br><span class="line">ajax(&#123;</span><br><span class="line">    method: &apos;POST&apos;,</span><br><span class="line">    url: &apos;test.php&apos;,</span><br><span class="line">    data: &#123;</span><br><span class="line">        name1: &apos;value1&apos;,</span><br><span class="line">        name2: &apos;value2&apos;</span><br><span class="line">    &#125;,</span><br><span class="line">    success: function (response) &#123;</span><br><span class="line">       console.log(response)；</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><a href="http://www.cnblogs.com/a757956132/p/5603176.html" target="_blank" rel="external">封装</a><br><a href="http://blog.csdn.net/u011032902/article/details/54728710?utm_source=itdadao&amp;utm_medium=referral" target="_blank" rel="external">实现原理</a></p>
<hr>
<h2 id="get-post方式的区别："><a href="#get-post方式的区别：" class="headerlink" title="get post方式的区别："></a>get post方式的区别：</h2><ul>
<li>GET：一般用来获取数据  ，POST：一般用来修改数据</li>
<li>get是把参数数据队列加到提交表单的ACTION属性所指的URL中，值和表单内各个字段一一对应，在URL中可以看到。post是通过HTTP post机制，将表单内各个字段与其内容放置在HTML HEADER内一起传送到ACTION属性所指的URL地址。用户看不到这个过程。</li>
<li>大部分浏览器对GET url有长度限制2k，post传送的数据量较大，一般被默认为不受限制。但理论上，IIS4中最大量为80KB，IIS5中为100KB。</li>
<li>缓存的问题。GET 请求默认在ajax环境下是会被缓存的 ，这样就会减轻服务器端的压力。但是post请求是不会被缓存的。</li>
<li>对于get方式，服务器端用Request.QueryString获取变量的值，对于post方式，服务器端用Request.Form获取提交的数据。</li>
<li>GET/POST使用场景有区别<ul>
<li>用get:<br>请求中的URL可以被手动输入<br>请求中的URL可以被存在书签里，或者历史里，或者快速拨号里面，或者分享给别人。<br>请求中的URL可以被缓存。GET 请求默认在ajax环境下是会被缓存的 ，这样就会减轻服务器端的压力。但是post请求是不会被缓存的。<br> 用GET： 可以重复的交互，比如取个数据，跳个页面</li>
<li>post:<br>表单数据，数据库内添加新的数据行，用POST, 因为POST不能被缓存，所以浏览器不会多次提交。</li>
</ul>
</li>
<li>延伸<br>http:get 获取数据 post:修改数据 put:增加数据 delete：删除数据</li>
</ul>
<hr>
<h2 id="如何判断ajax数据加载完毕？"><a href="#如何判断ajax数据加载完毕？" class="headerlink" title="如何判断ajax数据加载完毕？"></a>如何判断ajax数据加载完毕？</h2><ul>
<li>ajax请求设置为同步（同步慎用-项目中的这种办法）<br>在$(ajax)中，的async:false，变为同步，也就是说，先请求并将数据写入表格以后，再执行排序的代码.<br>但是建议：同步请求慎用，在数据量比较大的时候，用户缺一直在等待数据加载出来，很痛苦</li>
<li>ajax异步请求，判断数据加载完毕<ul>
<li>设置定时器监测</li>
<li>promise（fetch）</li>
</ul>
</li>
</ul>
<hr>
<h1 id="Node-amp-Express"><a href="#Node-amp-Express" class="headerlink" title="Node&amp;Express"></a>Node&amp;Express</h1><ul>
<li>基于node的其他web开发框架</li>
<li>node 有关的知识点</li>
</ul>
<hr>
<h2 id="express"><a href="#express" class="headerlink" title="express"></a>express</h2><p>Express 是一个基于 Node的极简灵活的web 应用开发框架。Express是在Node之上扩展了 Web 应用所需的基本功能。<br>Express完全是由中间件构成一个的 web 开发框架：从本质上来说，一个 Express 应用就是在调用各种中间件。</p>
<h3 id="中间件含义"><a href="#中间件含义" class="headerlink" title="中间件含义"></a>中间件含义</h3><p>是一个函数或功能，（err,res,rep,next），是封装在程序中处理请求的功能。后台的请求分为一部分一部分，每一部分都有中间件来完成,之道响应完毕</p>
<h3 id="Express-几种中间件："><a href="#Express-几种中间件：" class="headerlink" title="Express 几种中间件："></a>Express 几种中间件：</h3><p>应用级中间件<br>绑定到app 对象使用 app.use()和 app.METHOD()， 其中， METHOD 是需要处理的 HTTP 请求的方法，例如 GET, PUT, POST 等等</p>
<p>路由级中间件<br>绑定的对象为 express.Router()。路由级使用 router.use() 加载</p>
<p>错误处理中间件<br>4 个参数，而不是 3 个，其签名如下： (err, req, res, next)。</p>
<p>内置的中间件<br>express.static是 Express 唯一内置的中间件。负责在 Express 应用中托管静态资源。</p>
<p>第三方中间件<br>例如 cookie-parser</p>
<hr>
<h1 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h1><p> 对前端安全有什么看法？<br>是否了解Web注入攻击，说下原理，最常见的两种攻击（XSS 和 CSRF）了解到什么程度？</p>
<p>1, XSS(cross-site scripting跨域脚本攻击)是一种经常出现在web应用中的计算机安全漏洞，它允许恶意web用户将代码植入到提供给其它用户使用的页面中。 其实在web前端方面，可以简单的理解为一种javascript代码注入。 解决方法：将前端输出数据都进行转义（$lt,$gt）</p>
<p>2, CSRF（cross-site request forgery），翻译为跨站请求伪造，与XSS非常相似，但XSS是利用用户对当前网站的信任来发起攻击，而CSRF是利用网站对用户的信任来发起攻击(即模拟请求攻击)。</p>
<p>对于CSRF攻击，我们所能做的可以有：</p>
<p>检查报头中的Referer参数确保请求发自正确的网站（但XHR请求可调用setRequestHeader方法来修改Referer报头）；<br>对于任何重要的请求都需要重新验证用户的身份；<br>创建一个唯一的令牌（Token），将其存在服务端的session中及客户端的cookie中，对任何请求，都检查二者是否一致。</p>
<hr>
<h1 id="网络部分"><a href="#网络部分" class="headerlink" title="网络部分"></a>网络部分</h1><h2 id="一个页面从输入-URL-到页面加载显示完成，这个过程中都发生了什么？（流程说的越详细越好）"><a href="#一个页面从输入-URL-到页面加载显示完成，这个过程中都发生了什么？（流程说的越详细越好）" class="headerlink" title="一个页面从输入 URL 到页面加载显示完成，这个过程中都发生了什么？（流程说的越详细越好）"></a>一个页面从输入 URL 到页面加载显示完成，这个过程中都发生了什么？（流程说的越详细越好）</h2><p> 详细版：<br>      1、浏览器会开启一个线程来处理这个请求，对 URL 分析判断如果是 http 协议就按照 Web 方式来处理;<br>      2、调用浏览器内核中的对应方法，比如 WebView 中的 loadUrl 方法;<br>      3、通过DNS解析获取网址的IP地址，设置 UA 等信息发出第二个GET请求;<br>      4、进行HTTP协议会话，客户端发送报头(请求报头);<br>      5、进入到web服务器上的 Web Server，如 Apache、Tomcat、Node.JS 等服务器;<br>      6、进入部署好的后端应用，如 PHP、Java、JavaScript、Python 等，找到对应的请求处理;<br>      7、处理结束回馈报头，此处如果浏览器访问过，缓存上有对应资源，会与服务器最后修改时间对比，一致则返回304;<br>      8、浏览器开始下载html文档(响应报头，状态码200)，同时使用缓存;<br>      9、文档树建立，根据标记请求所需指定MIME类型的文件（比如css、js）,同时设置了cookie;<br>      10、页面开始渲染DOM，JS根据DOM API操作DOM,执行事件绑定等，页面显示完成。</p>
<pre><code>简洁版：
  浏览器根据请求的URL交给DNS域名解析，找到真实IP，向服务器发起请求；
  服务器交给后台处理完成后返回数据，浏览器接收文件（HTML、JS、CSS、图象等）；
  浏览器对加载到的资源（HTML、JS、CSS等）进行语法解析，建立相应的内部数据结构（如HTML的DOM）；
  载入解析到的资源文件，渲染页面，完成。
</code></pre><hr>
<h2 id="页面渲染流程主要分三部分"><a href="#页面渲染流程主要分三部分" class="headerlink" title="页面渲染流程主要分三部分"></a>页面渲染流程主要分三部分</h2><p>HTML文档解析生成DOM树<br>DOM树构建完到Webkit绘制上下文<br>上下文到最终生成的图像 (JavaScript省略为JS)<br>当用户输入URL时候，WebKit调用其资源加载器加载该URL对应的网页。<br>加载器依赖网络模块建立连接，发送请求并接受答复。<br>WebKit收到各种网页或资源的数据，可能是同步或者是异步获取的。<br>网页被交给HTML解释器转换成一系列词语(Token)。<br>解释器根据词语构建节点(Node)，形成DOM树。<br>如果节点是JS，调用JS引擎解释并执行。<br>JS代码修改DOM树的结构<br>如果节点需要依赖其他资源，如图片、css等，调用资源加载器来加载他们，但他们是异步的，不会阻碍当前DOM树的继续构建，如果是JS资源URL(未标记异步)，则需要停止当前DOM数的构建，直到JS引擎执行后才继续构建DOM树。 至此会触发两个事件，一个时DOMConent表示DOM构建完全(和jQuery的$(function(){})()一样),后者是 onload 事件，表示DOM树所依赖的各种图片、css等资源加载完毕，通常这两个事件不是同时发生。<br>接下来是利用CSS和DOM树构建RenderObject树直到绘图上下文。</p>
<p>CSS文件被CSS解释器解释成表示结构。<br>CSS解释器完成工作之后，在DOM树上附加解释后的样式信息，包括布局计算，这就是RenderObject树。<br>RenderObject节点在创建的同时，WebKit会根据网页的层次结构创建RenderLayer树，同时构建一个虚拟的绘图上下文。<br>实际上，DOM树，RenderObject树，RenderLayer树和绘图上下文在关闭浏览器前并不会被销毁。</p>
<p>最后，根据绘图上下文生成最终图像，主要依赖2D和3D图形库。</p>
<p>绘图上下文将每个绘图操作桥接到不同的具体实现类，也就是绘图具体实现类，绘图实现类将2D图形库或者3D图形库绘制的结果保存下来，交给浏览器来显示。</p>
<h2 id="浏览器接收到服务器文件（HTML、JS、CSS、图象等），开始加载资源，对于加载到的资源进行以下操作："><a href="#浏览器接收到服务器文件（HTML、JS、CSS、图象等），开始加载资源，对于加载到的资源进行以下操作：" class="headerlink" title="浏览器接收到服务器文件（HTML、JS、CSS、图象等），开始加载资源，对于加载到的资源进行以下操作："></a>浏览器接收到服务器文件（HTML、JS、CSS、图象等），开始加载资源，对于加载到的资源进行以下操作：</h2><ul>
<li>浏览器解析<ul>
<li>解析html形成 Dom Tree</li>
<li>解析 css 形成 Css Rule Tree</li>
<li>Js通过  DOM API和CSSOM API来操作DOM Tree和CSS Rule Tree</li>
</ul>
</li>
<li>构建Render Tree<ul>
<li>浏览器引擎用Dom Tree 和 Css Rule Tree 构建 Render Tree<ul>
<li>Css Rule Tree对比DOM生成Style Context Tree</li>
</ul>
</li>
</ul>
</li>
<li>绘制网页</li>
</ul>
<hr>
<h2 id="网络有几层，每层有哪些协议"><a href="#网络有几层，每层有哪些协议" class="headerlink" title="网络有几层，每层有哪些协议"></a>网络有几层，每层有哪些协议</h2><ul>
<li>OSI分层（7层）：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层。</li>
<li>TCP/IP分层（4层）：网络接口层、网际层、运输层、应用层。</li>
<li>五层协议（5层）：物理层、数据链路层、网络层、运输层、应用层。<br>tcp,udp在运输层<br>http,ftp 在应用层<br>ip在网络层<h2 id="UDP-TCP-的区别，什么时候用哪个-哪个是可靠的？"><a href="#UDP-TCP-的区别，什么时候用哪个-哪个是可靠的？" class="headerlink" title="UDP TCP 的区别，什么时候用哪个,哪个是可靠的？"></a>UDP TCP 的区别，什么时候用哪个,哪个是可靠的？</h2></li>
<li>1、TCP面向连接;UDP是无连接的，即发送数据之前不需要建立连接</li>
<li>2、TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达（ack）;UDP尽最大努力交付，即不保证可靠交付</li>
<li>3、TCP面向字节流，实际上是TCP把数据看成一连串无结构的字节流;UDP是面向报文的<br>UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如IP电话，实时视频会议等）</li>
<li>4、每一条TCP连接只能是点到点的;UDP支持一对一，一对多，多对一和多对多的交互通信</li>
<li>5、TCP首部开销20字节;UDP的首部开销小，只有8个字节</li>
<li>6、TCP的逻辑通信信道是全双工的可靠信道，UDP则是不可靠信道</li>
</ul>
<h2 id="http-中get和post的区别"><a href="#http-中get和post的区别" class="headerlink" title="http 中get和post的区别"></a>http 中get和post的区别</h2><ul>
<li>GET：一般用来获取数据  ，POST：一般用来修改数据</li>
<li>发送值：<br>　<em> geturl参数可见。
　</em> post是通过HTTP post机制，将数据放到 头传过去</li>
<li>长度限制：<ul>
<li>大部分浏览器对GET url有长度限制2k</li>
<li>post传送的数据量较大，一般被默认为不受限制。80KB-100KB。</li>
</ul>
</li>
<li>缓存:<ul>
<li>GET 请求默认在ajax环境下是会被缓存的 ，这样就会减轻服务器端的压力。<ul>
<li>但是post请求是不会被缓存的。</li>
</ul>
</li>
</ul>
</li>
<li>GET/POST使用场景有区别<ul>
<li>用get:<br>请求中的URL可以被手动输入<br>请求中的URL可以被存在书签里，或者历史里，或者快速拨号里面，或者分享给别人。<br>请求中的URL可以被缓存。GET 请求默认在ajax环境下是会被缓存的 ，这样就会减轻服务器端的压力。但是post请求是不会被缓存的。<br> 用GET： 可以重复的交互，比如取个数据，跳个页面</li>
<li>post:<br>表单数据，数据库内添加新的数据行，用POST, 因为POST不能被缓存，所以浏览器不会多次提交。</li>
</ul>
</li>
<li>延伸<br>http:get 获取数据 post:修改数据 put:增加数据 delete：删除数据<h2 id="为什么get方式有限制是2kb-，出于什么原因？"><a href="#为什么get方式有限制是2kb-，出于什么原因？" class="headerlink" title="为什么get方式有限制是2kb.，出于什么原因？"></a>为什么get方式有限制是2kb.，出于什么原因？</h2></li>
<li>不同<strong>的</strong>浏览器对于URL是有限制<strong>的</strong>，比如IE浏览器对于URL<strong>的</strong>限制为<strong>2KB</strong>，而Chrome，FireFox浏览器理论上对于URL是没有限制<strong>的</strong>，它真正<strong>的</strong>限制取决于操作系统本身</li>
<li>服务器最多处理64K大小的url。超过的部分，恕不处理。<h2 id="知道post请求发几个包？，知道某个名词吗"><a href="#知道post请求发几个包？，知道某个名词吗" class="headerlink" title="知道post请求发几个包？，知道某个名词吗?"></a>知道post请求发几个包？，知道某个名词吗?</h2>GET和POST还有一个重大区别是：GET产生一个TCP数据包，而POST产生两个TCP数据包(但又不是绝对)</li>
<li><p>1、对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200(返回数据);</p>
</li>
<li><p>2、而对于POST，浏览器先发送header，服务器响应100(客户端应当继续发送请求) continue，浏览器再发送data，服务器响应200 ok(返回数据)。</p>
</li>
<li><p>3、也就是说，GET只需要汽车跑一趟就把货送到了，而POST得跑两趟，第一趟，先去和服务器打个招呼“嗨，我等下要送一批货来，你们打开门迎接我”，然后再回头把货送过去。</p>
</li>
<li>4、因为POST需要两步，时间上消耗的要多一点，看起来GET比POST更有效。因此Yahoo团队有推荐用GET替换POST来优化网站性能。但这是一个坑!跳入需谨慎。为什么?</li>
<li>6、 据研究，在网络环境好的情况下，发一次包的时间和发两次包的时间差别基本可以无视。而在网络环境差的情况下，两次包的TCP在验证数据包完整性上，有非常大的优点。</li>
<li>7、但并不是所有浏览器都会在POST中发送两次包，Firefox就只发送一次。<h2 id="握手挥手"><a href="#握手挥手" class="headerlink" title="握手挥手"></a>握手挥手</h2><h3 id="握手"><a href="#握手" class="headerlink" title="握手"></a>握手</h3>三次握手过程：<br>客户端向服务器发送一个SYN（包含了SYN，SEQ）。<br>当服务器会向客户端发送一个SYN+ACK的数据包<br>当客户端向服务器发送ACK的数据包，此时ACK数据包中的ack值等于上一次SYN中的seq+syn。<br>如果某个阶段莫名中断，TCP会再次以相同的顺序发送相同的数据包。<h4 id="三次握手的目的："><a href="#三次握手的目的：" class="headerlink" title="三次握手的目的："></a>三次握手的目的：</h4>防止已过期的连接请求报文突然又传送到服务器，因而产生错误。<h3 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h3>第一次挥手：主动关闭方A发送一个FIN，用来A到被动关闭方B对的数据传送，也就是A不再给B发数据了，但是A还可以接收数据</li>
</ul>
<p>第二次挥手：B收到FIN包后，发一个ACK给对方，确认序号为收到序号+1。（一个FIN占用一个序号）</p>
<p>第三次挥手：B发送一个FIN，用来关闭B到A的数据传送</p>
<p>第四次挥手：A收到FIN后，发送一个ACK给B，确认序号为收到序号+1。完成四次挥手。</p>
<h2 id="为什么挥手比握手多了一个次？"><a href="#为什么挥手比握手多了一个次？" class="headerlink" title="为什么挥手比握手多了一个次？"></a>为什么挥手比握手多了一个次？</h2><p>但关闭连接时，当收到对方的FIN报文通知时，它仅仅表示对方没有数据发送给你了；但未必你所有的数据都全部发送给对方了，所以它这里的ACK报文和FIN报文分开发送的。</p>
<h2 id="http的缓存机制（cookie）"><a href="#http的缓存机制（cookie）" class="headerlink" title="http的缓存机制（cookie）"></a>http的缓存机制（cookie）</h2><p><a href="http://www.jianshu.com/p/0c31b58dbccb" target="_blank" rel="external">http://www.jianshu.com/p/0c31b58dbccb</a><br><a href="https://segmentfault.com/a/1190000010775131" target="_blank" rel="external">https://segmentfault.com/a/1190000010775131</a></p>
<p><img src="http://upload-images.jianshu.io/upload_images/2377897-3e3258c0ab144bfd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/2377897-870aaa08f5c962a7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<hr>
<h2 id="http请求是有状态的嘛？websocket区别"><a href="#http请求是有状态的嘛？websocket区别" class="headerlink" title="http请求是有状态的嘛？websocket区别"></a>http请求是有状态的嘛？websocket区别</h2><h3 id="http"><a href="#http" class="headerlink" title="http"></a>http</h3><ul>
<li>http基于tcp</li>
<li>http为非状态协议，每次发送数据都要重新请求连接</li>
<li>被动性：服务器不能主动发送请求，只能等待响应<h3 id="websocket"><a href="#websocket" class="headerlink" title="websocket"></a>websocket</h3><ul>
<li>基于tcp,为了实现实时 通信而产生的。</li>
<li>特点：<ul>
<li>服务器可以主动发送请求</li>
<li>节约带宽</li>
<li>持久连接<h2 id="Http与https"><a href="#Http与https" class="headerlink" title="Http与https"></a>Http与https</h2>HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全。<br>HTTPS和HTTP的区别主要如下：</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>　　1、https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用。</p>
<p>　　2、http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。</p>
<p>　　3、http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。</p>
<p>　　4、http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。</p>
<hr>
<h2 id="HTTP请求报文与响应报文格式"><a href="#HTTP请求报文与响应报文格式" class="headerlink" title="HTTP请求报文与响应报文格式"></a>HTTP请求报文与响应报文格式</h2><h3 id="请求报文包含三部分："><a href="#请求报文包含三部分：" class="headerlink" title="请求报文包含三部分："></a>请求报文包含三部分：</h3><p>a、请求行：包含请求方法、URI、HTTP版本信息<br>b、请求首部字段<br>c、请求内容实体</p>
<h3 id="响应报文包含三部分："><a href="#响应报文包含三部分：" class="headerlink" title="响应报文包含三部分："></a>响应报文包含三部分：</h3><p>a、状态行：包含HTTP版本、状态码、状态码的原因短语<br>b、响应首部字段<br>c、响应内容实体</p>
<hr>
<h2 id="常见HTTP首部字段"><a href="#常见HTTP首部字段" class="headerlink" title="常见HTTP首部字段"></a>常见HTTP首部字段</h2><p>###　a、通用首部字段（请求报文与响应报文都会使用的首部字段）<br>Date：创建报文时间<br>Connection：连接的管理<br>Cache-Control：缓存的控制<br>Transfer-Encoding：报文主体的传输编码方式</p>
<h3 id="b、请求首部字段（请求报文会使用的首部字段）"><a href="#b、请求首部字段（请求报文会使用的首部字段）" class="headerlink" title="b、请求首部字段（请求报文会使用的首部字段）"></a>b、请求首部字段（请求报文会使用的首部字段）</h3><p>Host：请求资源所在服务器<br>Accept：可处理的媒体类型<br>Accept-Charset：可接收的字符集<br>Accept-Encoding：可接受的内容编码<br>Accept-Language：可接受的自然语言</p>
<h3 id="c、响应首部字段（响应报文会使用的首部字段）"><a href="#c、响应首部字段（响应报文会使用的首部字段）" class="headerlink" title="c、响应首部字段（响应报文会使用的首部字段）"></a>c、响应首部字段（响应报文会使用的首部字段）</h3><p>Accept-Ranges：可接受的字节范围<br>Location：令客户端重新定向到的URI<br>Server：HTTP服务器的安装信息</p>
<h3 id="d、实体首部字段（请求报文与响应报文的的实体部分使用的首部字段）"><a href="#d、实体首部字段（请求报文与响应报文的的实体部分使用的首部字段）" class="headerlink" title="d、实体首部字段（请求报文与响应报文的的实体部分使用的首部字段）"></a>d、实体首部字段（请求报文与响应报文的的实体部分使用的首部字段）</h3><p>Allow：资源可支持的HTTP方法<br>Content-Type：实体主类的类型<br>Content-Encoding：实体主体适用的编码方式<br>Content-Language：实体主体的自然语言<br>Content-Length：实体主体的的字节数<br>Content-Range：实体主体的位置范围，一般用于发出部分请求时使用</p>
<hr>
<h3 id="Http状态码-常用的"><a href="#Http状态码-常用的" class="headerlink" title="Http状态码 常用的"></a>Http状态码 常用的</h3><p>成功的状态码：<br>200 – 服务器成功返回网页<br>304 – 未修改<br>失败的状态码：<br>404 – 请求的网页不存在<br>503 – 服务器暂时不可用<br>500 – 服务器内部错误  </p>
<h2 id="http状态码有那些？分别代表是什么意思？"><a href="#http状态码有那些？分别代表是什么意思？" class="headerlink" title="http状态码有那些？分别代表是什么意思？"></a>http状态码有那些？分别代表是什么意思？</h2><h3 id="简单版"><a href="#简单版" class="headerlink" title="简单版"></a>简单版</h3><pre><code>[
    100  Continue    继续，一般在发送post请求时，已发送了http header之后服务端将返回此信息，表示确认，之后发送具体参数信息
    200  OK         正常返回信息
    201  Created      请求成功并且服务器创建了新的资源
    202  Accepted     服务器已接受请求，但尚未处理
    301  Moved Permanently  请求的网页已永久移动到新位置。
    302 Found          临时性重定向。
    303 See Other      临时性重定向，且总是使用 GET 请求新的 URI。
    304  Not Modified 自从上次请求后，请求的网页未修改过。

    400 Bad Request  服务器无法理解请求的格式，客户端不应当尝试再次使用相同的内容发起请求。
    401 Unauthorized 请求未授权。
    403 Forbidden      禁止访问。
    404 Not Found      找不到如何与 URI 相匹配的资源。

    500 Internal Server Error  最常见的服务器端错误。
    503 Service Unavailable 服务器端暂时无法处理请求（可能是过载或维护）。
]
</code></pre><h3 id="完整版"><a href="#完整版" class="headerlink" title="完整版"></a>完整版</h3><h4 id="1-信息类-：表示接收到请求并且继续处理"><a href="#1-信息类-：表示接收到请求并且继续处理" class="headerlink" title="1**(信息类)：表示接收到请求并且继续处理"></a>1**(信息类)：表示接收到请求并且继续处理</h4><pre><code>100——客户必须继续发出请求
101——客户要求服务器根据请求转换HTTP协议版本
</code></pre><h4 id="2-响应成功-：表示动作被成功接收、理解和接受"><a href="#2-响应成功-：表示动作被成功接收、理解和接受" class="headerlink" title="2**(响应成功)：表示动作被成功接收、理解和接受"></a>2**(响应成功)：表示动作被成功接收、理解和接受</h4><pre><code>200——表明该请求被成功地完成，所请求的资源发送回客户端
201——提示知道新文件的URL
202——接受和处理、但处理未完成
203——返回信息不确定或不完整
204——请求收到，但返回信息为空
205——服务器完成了请求，用户代理必须复位当前已经浏览过的文件
206——服务器已经完成了部分用户的GET请求
</code></pre><h4 id="3-重定向类-：为了完成指定的动作，必须接受进一步处理"><a href="#3-重定向类-：为了完成指定的动作，必须接受进一步处理" class="headerlink" title="3**(重定向类)：为了完成指定的动作，必须接受进一步处理"></a>3**(重定向类)：为了完成指定的动作，必须接受进一步处理</h4><pre><code>300——请求的资源可在多处得到
301——本网页被永久性转移到另一个URL
302——请求的网页被转移到一个新的地址，但客户访问仍继续通过原始URL地址，重定向，新的URL会在response中的Location中返回，浏览器将会使用新的URL发出新的Request。
303——建议客户访问其他URL或访问方式
304——自从上次请求后，请求的网页未修改过，服务器返回此响应时，不会返回网页内容，代表上次的文档已经被缓存了，还可以继续使用
305——请求的资源必须从服务器指定的地址得到
306——前一版本HTTP中使用的代码，现行版本中不再使用
307——申明请求的资源临时性删除
</code></pre><h4 id="4-客户端错误类-：请求包含错误语法或不能正确执行"><a href="#4-客户端错误类-：请求包含错误语法或不能正确执行" class="headerlink" title="4**(客户端错误类)：请求包含错误语法或不能正确执行"></a>4**(客户端错误类)：请求包含错误语法或不能正确执行</h4><pre><code>400——客户端请求有语法错误，不能被服务器所理解
401——请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用
HTTP 401.1 - 未授权：登录失败
　　HTTP 401.2 - 未授权：服务器配置问题导致登录失败
　　HTTP 401.3 - ACL 禁止访问资源
　　HTTP 401.4 - 未授权：授权被筛选器拒绝
HTTP 401.5 - 未授权：ISAPI 或 CGI 授权失败
402——保留有效ChargeTo头响应
403——禁止访问，服务器收到请求，但是拒绝提供服务
HTTP 403.1 禁止访问：禁止可执行访问
　　HTTP 403.2 - 禁止访问：禁止读访问
　　HTTP 403.3 - 禁止访问：禁止写访问
　　HTTP 403.4 - 禁止访问：要求 SSL
　　HTTP 403.5 - 禁止访问：要求 SSL 128
　　HTTP 403.6 - 禁止访问：IP 地址被拒绝
　　HTTP 403.7 - 禁止访问：要求客户证书
　　HTTP 403.8 - 禁止访问：禁止站点访问
　　HTTP 403.9 - 禁止访问：连接的用户过多
　　HTTP 403.10 - 禁止访问：配置无效
　　HTTP 403.11 - 禁止访问：密码更改
　　HTTP 403.12 - 禁止访问：映射器拒绝访问
　　HTTP 403.13 - 禁止访问：客户证书已被吊销
　　HTTP 403.15 - 禁止访问：客户访问许可过多
　　HTTP 403.16 - 禁止访问：客户证书不可信或者无效
HTTP 403.17 - 禁止访问：客户证书已经到期或者尚未生效
404——一个404错误表明可连接服务器，但服务器无法取得所请求的网页，请求资源不存在。eg：输入了错误的URL
405——用户在Request-Line字段定义的方法不允许
406——根据用户发送的Accept拖，请求资源不可访问
407——类似401，用户必须首先在代理服务器上得到授权
408——客户端没有在用户指定的饿时间内完成请求
409——对当前资源状态，请求不能完成
410——服务器上不再有此资源且无进一步的参考地址
411——服务器拒绝用户定义的Content-Length属性请求
412——一个或多个请求头字段在当前请求中错误
413——请求的资源大于服务器允许的大小
414——请求的资源URL长于服务器允许的长度
415——请求资源不支持请求项目格式
416——请求中包含Range请求头字段，在当前请求资源范围内没有range指示值，请求也不包含If-Range请求头字段
417——服务器不满足请求Expect头字段指定的期望值，如果是代理服务器，可能是下一级服务器不能满足请求长。
</code></pre><h4 id="5-服务端错误类-：服务器不能正确执行一个正确的请求"><a href="#5-服务端错误类-：服务器不能正确执行一个正确的请求" class="headerlink" title="5**(服务端错误类)：服务器不能正确执行一个正确的请求"></a>5**(服务端错误类)：服务器不能正确执行一个正确的请求</h4><pre><code>  HTTP 500 - 服务器遇到错误，无法完成请求
  　　HTTP 500.100 - 内部服务器错误 - ASP 错误
  　　HTTP 500-11 服务器关闭
  　　HTTP 500-12 应用程序重新启动
  　　HTTP 500-13 - 服务器太忙
  　　HTTP 500-14 - 应用程序无效
  　　HTTP 500-15 - 不允许请求 global.asa
  　　Error 501 - 未实现
HTTP 502 - 网关错误
HTTP 503：由于超载或停机维护，服务器目前无法使用，一段时间后可能恢复正常
</code></pre><hr>
<h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><h2 id="什么是事务？"><a href="#什么是事务？" class="headerlink" title="什么是事务？"></a>什么是事务？</h2><ul>
<li>事务就是被绑定在一起作为一个逻辑工作单元的SQL语句分组，如果任何一个语句操作失败那么整个操作就被失败，以后操作就会回滚到操作前状态，或者是上有个节点。为了确保要么执行，要么不执行，就可以使用事务。要将有组语句作为事务考虑，就需要通过ACID测试，即原子性，一致性，隔离性和持久性。<h2 id="数据库有哪几种事务"><a href="#数据库有哪几种事务" class="headerlink" title="数据库有哪几种事务"></a>数据库有哪几种事务</h2><h2 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h2>答：视图是一种虚拟的表，具有和物理表相同的功能。可以对视图进行增，改，查，操作，视图通常是有一个表或者多个表的行或列的子集。对视图的修改不影响基本表。它使得我们获取数据更容易，相比多表查询<h2 id="mysql的left-join，inner-join，right-join"><a href="#mysql的left-join，inner-join，right-join" class="headerlink" title="mysql的left join，inner join，right join;"></a>mysql的left join，inner join，right join;</h2></li>
<li>Inner Join:内连接是最常见的一种连接，只连接匹配的行。它又分为等值连接（连接条件运算符为”=”）和不等值连接（连接条件运算符不为”=”，例如between…and）。</li>
<li>Outer Join：它除了显示符合连接条件的记录以外，还会显示所有左表中的记录（右外连接就是所有右表中的记录）<ul>
<li>A FULL OUTER JOIN B：产生A和B的并集<br>*A Left Outer Join B：产生表A的完全集，而B表中匹配的则有值，没有匹配的则以null值取代。</li>
<li>A Right Outer Join B：是后面的表为基础<h2 id="mysql的索引"><a href="#mysql的索引" class="headerlink" title="mysql的索引;"></a>mysql的索引;</h2><h2 id="索引的作用？和它的优点缺点是什么？"><a href="#索引的作用？和它的优点缺点是什么？" class="headerlink" title="索引的作用？和它的优点缺点是什么？"></a>索引的作用？和它的优点缺点是什么？</h2>答：索引就一种特殊的查询表，数据库的搜索引擎可以利用它加速对数据的检索。它很类似与现实生活中书的目录，不需要查询整本书内容就可以找到想要的数据。索引可以是唯一的，创建索引允许指定单个列或者是多个列。缺点是它减慢了数据录入的速度，同时也增加了数据库的尺寸大小。<h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><h2 id="进程和线程有什么区别？"><a href="#进程和线程有什么区别？" class="headerlink" title="进程和线程有什么区别？"></a>进程和线程有什么区别？</h2></li>
</ul>
</li>
<li>进程和线程都是CPU工作时间段的描述。</li>
<li>进程是cpu资源分配的最小单位，线程是cpu调度的最小单位</li>
<li>线程的划分尺度小于进程，使得多线程程序的并发性高。</li>
<li>线程执行开销小，但不利于资源的管理和保护；</li>
<li>一个进程可以有多个线程</li>
<li>进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路径。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个线程死掉就等于整个进程死掉，所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要差一些.<h2 id="什么是死锁，死锁产生的4个条件"><a href="#什么是死锁，死锁产生的4个条件" class="headerlink" title="什么是死锁，死锁产生的4个条件"></a>什么是死锁，死锁产生的4个条件</h2><h3 id="死锁定义："><a href="#死锁定义：" class="headerlink" title="死锁定义："></a>死锁定义：</h3>　在两个或多个并发进程中，如果每个进程持有某种资源而又都等待别的进程释放它或它们现在保持着的资源，在未改变这种状态之前都不能向前推进，称这一组进程产生了死锁。通俗地讲，就是两个或多个进程被无限期地阻塞、相互等待的一种状态。<h3 id="产生条件："><a href="#产生条件：" class="headerlink" title="产生条件："></a>产生条件：</h3></li>
<li>1：互斥条件        – 一个资源一次只能被一个进程使用</li>
<li>2：请求保持条件 – 一个进程因请求资源而阻塞时，对已经获得资源保持不放 </li>
<li>3：不可抢占条件 – 进程已获得的资源在未使用完之前不能强行剥夺</li>
<li>4：循环等待条件 – 若干进程之间形成一种头尾相接的循环等待资源的关系</li>
</ul>
<h2 id="预防避免死锁的方法"><a href="#预防避免死锁的方法" class="headerlink" title="预防避免死锁的方法"></a>预防避免死锁的方法</h2><ul>
<li>1：破坏“请求和保持”条件：规定所有进程在开始运行之前，都必须一次性的申请其在整个运行过程所需要的全部资源。<ul>
<li>优点：简单，安全。 <ul>
<li>缺点：资源严重浪费，恶化了系统的利用率；</li>
</ul>
</li>
</ul>
</li>
<li>2：破坏“不剥夺”条件：进程逐个的提出资源请求，当一个已经保持了某些资源的进程，再提出新的资源请求而不能立即得到满足时，必须释放它已经保持了的所有资源，待以后需要时再重新申请。<ul>
<li>缺点：实现复杂，代价大，反复地申请和释放资源，而使进程的执行无限的推迟、延长了进程的周转时间增加系统开销、降低系统吞吐量。</li>
</ul>
</li>
<li>3：破坏“环路等待”条件：将所有的资源按类型进行线性排队，并赋予不同的序号。所有进程请求资源必须按照资源递增的次序提出，防止出现环路。 <ul>
<li>缺点：<ul>
<li>1、序号必须相对稳定，限制了新设备类型的增加</li>
<li>2、作业（进程）使用资源顺序和系统规定的顺序不同而造成资源的浪费</li>
<li>3、限制了用户编程 </li>
</ul>
</li>
</ul>
</li>
</ul>
<p>　　注意：由于互斥条件是非共享设备所必需的，不能改变</p>
<hr>
<h1 id="JQUERY"><a href="#JQUERY" class="headerlink" title="JQUERY"></a>JQUERY</h1><h2 id="1-你在公司是怎么用jquery的？"><a href="#1-你在公司是怎么用jquery的？" class="headerlink" title="1 你在公司是怎么用jquery的？"></a>1 你在公司是怎么用jquery的？</h2><p>答：在项目中是怎么用的是看看你有没有项目经验(根据自己的实际情况来回答) 你用过的选择器啊，复选框啊，表单啊，ajax啊，事件等配置<a href="http://lib.csdn.net/base/jquery" target="_blank" rel="external">jQuery</a>环境 下载jquery类库 在jsp页面引用jquery类库即可</p>
<p><script type="text/[JavaScript](http://lib.csdn.net/base/javascript)" src="jquery/jquery-1.7.2.min.js">接下来通过在<script> $(function(){ }); </script></p>
<h2 id="2-你为什么要使用jquery？"><a href="#2-你为什么要使用jquery？" class="headerlink" title="2 你为什么要使用jquery？"></a>2 你为什么要使用jquery？</h2><p>答：因为jQuery是轻量级的框架，大小不到30kb,它有强大的选择器，出色的DOM操作的封装，有可靠的事件处理机制(jQuery在处理事件绑定的时候相当的可靠)，完善的ajax(它的ajax封装的非常的好，不需要考虑复杂浏览器的兼容性和XMLHttpRequest对象的创建和使用的问题。) 出色的浏览器的兼容性。 而且支持链式操作，隐式迭代。行为层和结构层的分离，还支持丰富的插件，jquery的文档也非常的丰富。</p>
<h2 id="3-你觉得jquery有哪些好处？-答案同上"><a href="#3-你觉得jquery有哪些好处？-答案同上" class="headerlink" title="3 你觉得jquery有哪些好处？ 答案同上"></a>3 你觉得jquery有哪些好处？ 答案同上</h2><h2 id="4-你使用jquery遇到过哪些问题，你是怎么解决的？"><a href="#4-你使用jquery遇到过哪些问题，你是怎么解决的？" class="headerlink" title="4 你使用jquery遇到过哪些问题，你是怎么解决的？"></a>4 你使用jquery遇到过哪些问题，你是怎么解决的？</h2><p>答：这个答案是开发的，看你是否有相关的项目经验。例前台拿不到值，JSON 可是出现的错误(多了一个空格等)这编译是不会报错的 jquery库与其他库冲突：1&gt;如果其他库在jquery库之前导入的话1.我们可以通过jquery.noconflict()将变量的$的控制权过度给其他库2.自定义快捷键,用一个变量接住jquery.noconflict()3.通过函数传参2&gt;如果jquery库在其他库之前导入就直接使用jquery今天在处理一个数据问题时，发现jQuery.ajax()方法返回的值一直有问题，清除缓存后数据无误，多次<a href="http://lib.csdn.net/base/softwaretest" target="_blank" rel="external">测试</a>后发现返回的值都是之前的值，并且一直未执行url(后台为<a href="http://lib.csdn.net/base/javase" target="_blank" rel="external">Java</a>，设置断点一直未进入)。在网上查找下,发现是未设置type的原因。 如果没设置jQuery.ajax的type=”Post”，那么ajax就会默认type=”Get”，这就会导致之前数据被缓存起来。加上type=”Post”，问题解决！</p>
<h2 id="5-你知道jquery中的选择器吗，请讲一下有哪些选择器？"><a href="#5-你知道jquery中的选择器吗，请讲一下有哪些选择器？" class="headerlink" title="5 你知道jquery中的选择器吗，请讲一下有哪些选择器？"></a>5 你知道jquery中的选择器吗，请讲一下有哪些选择器？</h2><p>答 ：jQuery中的选择器大致分为:基本选择器，层次选择器，过滤选择器，表单选择器</p>
<h2 id="6-jquery中的选择器-和-css中的选择器有区别吗？"><a href="#6-jquery中的选择器-和-css中的选择器有区别吗？" class="headerlink" title="6 jquery中的选择器 和 css中的选择器有区别吗？"></a>6 jquery中的选择器 和 css中的选择器有区别吗？</h2><p>答：jQuery选择器支持CSS里的选择器，jQuery选择器可用来添加样式和添加相应的行为CSS 中的选择器是只能添加相应的样式</p>
<h2 id="7-你觉得jquery中的选择器有什么优势？"><a href="#7-你觉得jquery中的选择器有什么优势？" class="headerlink" title="7 你觉得jquery中的选择器有什么优势？"></a>7 你觉得jquery中的选择器有什么优势？</h2><p>答：简单的写法 $(‘ID’) 来代替 document.getElementById()函数支持CSS1 到<a href="http://lib.csdn.net/base/css3" target="_blank" rel="external">CSS3</a> 选择器完善的处理机制(就算写错了id也不会报错)</p>
<h2 id="8-你在使用选择器的时候有有没有什么觉得要注意的地方？"><a href="#8-你在使用选择器的时候有有没有什么觉得要注意的地方？" class="headerlink" title="8 你在使用选择器的时候有有没有什么觉得要注意的地方？"></a>8 你在使用选择器的时候有有没有什么觉得要注意的地方？</h2><p>答: 1 选择器中含有”.”,”#”,”[“ 等特殊字符的时候需要进行转译2 属性选择器的引号问题3 选择器中含有空格的注意事项</p>
<h2 id="9-jquery对象和dom对象是怎样转换的？"><a href="#9-jquery对象和dom对象是怎样转换的？" class="headerlink" title="9 jquery对象和dom对象是怎样转换的？"></a>9 jquery对象和dom对象是怎样转换的？</h2><p>答 ：jquery转DOM对象:jQuery 对象是一个数组对象，可以通过[index]的丰富得到相应的DOM对象还可以通过get[index]去得到相应的DOM对象。DOM对象转jQuery对象:$(DOM对象)</p>
<h2 id="10-你是如何使用jquery中的ajax的？"><a href="#10-你是如何使用jquery中的ajax的？" class="headerlink" title="10 你是如何使用jquery中的ajax的？"></a>10 你是如何使用jquery中的ajax的？</h2><p>答: 如果是一些常规的ajax程序的话，使用load(),$.get(),$.post(),就可以搞定了，一般我会使用的是$.post() 方法。如果需要设定beforeSend(提交前回调函数),error(失败后处理),success(成功后处理)及complete(请求完成后处理)回调函数等，这个时候我会使用$.ajax()</p>
<h2 id="11-你觉得jquery中的ajax好用吗，为什么？"><a href="#11-你觉得jquery中的ajax好用吗，为什么？" class="headerlink" title="11 你觉得jquery中的ajax好用吗，为什么？"></a>11 你觉得jquery中的ajax好用吗，为什么？</h2><p>答: 好用的。 因为jQuery提供了一些日常开发中夙瑶的快捷操作，例 load，ajax，get，post等等，所以使用jQuery开发ajax将变得极其简单，我们就可以集中精力在业务和用户的体验上，不需要去理会那些繁琐的XMLHttpRequest对象了。</p>
<h2 id="12-jquery中-get-提交和-post-提交有区别吗？"><a href="#12-jquery中-get-提交和-post-提交有区别吗？" class="headerlink" title="12 jquery中$.get()提交和$.post()提交有区别吗？"></a>12 jquery中$.get()提交和$.post()提交有区别吗？</h2><p>答: 1 $.get() 方法使用GET方法来进行异步请求的。$.post() 方法使用POST方法来进行异步请求的。2 get请求会将参数跟在URL后进行传递，而POST请求则是作为HTTP消息的实体内容发送给Web服务器的，这种传递是对用户不可见的。3 get方式传输的数据大小不能超过2KB 而POST要大的多4 GET 方式请求的数据会被浏览器缓存起来，因此有安全问题。</p>
<h2 id="13-jquery中的load方法一般怎么用的？"><a href="#13-jquery中的load方法一般怎么用的？" class="headerlink" title="13 jquery中的load方法一般怎么用的？"></a>13 jquery中的load方法一般怎么用的？</h2><p>答：load方法一般在 载入远程HTML 代码并插入到DOM中的时候用，通常用来从Web服务器上获取静态的数据文件。如果要传递参数的话，可以使用$.get() 或 $.post()。</p>
<h2 id="14-在jquery中你是如何去操作样式的？"><a href="#14-在jquery中你是如何去操作样式的？" class="headerlink" title="14 在jquery中你是如何去操作样式的？"></a>14 在jquery中你是如何去操作样式的？</h2><p>答: addClass() 来追加样式 ，removeClass() 来删除样式，toggle() 来切换样式</p>
<h2 id="15-简单的讲叙一下jquery是怎么处理事件的，你用过哪些事件？"><a href="#15-简单的讲叙一下jquery是怎么处理事件的，你用过哪些事件？" class="headerlink" title="15 简单的讲叙一下jquery是怎么处理事件的，你用过哪些事件？"></a>15 简单的讲叙一下jquery是怎么处理事件的，你用过哪些事件？</h2><p>答: 首先去装载文档，在页面家在完毕后，浏览器会通过javascript 为DOM元素添加事件。</p>
<h2 id="16-你使用过jquery中的动画吗，是怎样用的？"><a href="#16-你使用过jquery中的动画吗，是怎样用的？" class="headerlink" title="16 你使用过jquery中的动画吗，是怎样用的？"></a>16 你使用过jquery中的动画吗，是怎样用的？</h2><p>答:使用过。hide() 和 show() 同时修改多个样式属性。像高度，宽度，不透明度。 fadeIn() 和fadeOut() fadeTo() 只改变不透明度slideUp() 和 slideDown() slideToggle() 只改变高度animate() 属于自定义动画的方法.</p>
<h2 id="17-你使用过jquery中的插件吗？-答-看个人的实力和经验来回答了。"><a href="#17-你使用过jquery中的插件吗？-答-看个人的实力和经验来回答了。" class="headerlink" title="17 你使用过jquery中的插件吗？ 答:看个人的实力和经验来回答了。"></a>17 你使用过jquery中的插件吗？ 答:看个人的实力和经验来回答了。</h2><h2 id="18-你一般用什么去提交数据，为什么？"><a href="#18-你一般用什么去提交数据，为什么？" class="headerlink" title="18 你一般用什么去提交数据，为什么？"></a>18 你一般用什么去提交数据，为什么？</h2><p>答:一般我会使用的是$.post() 方法。如果需要设定beforeSend(提交前回调函数),error(失败后处理),success(成功后处理及complete(请求完成后处理)回调函数等，这个时候我会使用$.ajax()</p>
<h2 id="19-在jquery中引入css有几种方式？"><a href="#19-在jquery中引入css有几种方式？" class="headerlink" title="19 在jquery中引入css有几种方式？"></a>19 在jquery中引入css有几种方式？</h2><p>答:四种 行内式，内嵌式，导入式，链接式</p>
<h2 id="20-你在jquery中使用过哪些插入节点的方法，它们的区别是什么？"><a href="#20-你在jquery中使用过哪些插入节点的方法，它们的区别是什么？" class="headerlink" title="20 你在jquery中使用过哪些插入节点的方法，它们的区别是什么？"></a>20 你在jquery中使用过哪些插入节点的方法，它们的区别是什么？</h2><p>答:append(),appendTo(),prepend(),prependTo(),after(),insertAfter()，before(),insertBefore() 大致可以分为 内部追加和外部追加append() 表式向每个元素内部追加内容。appendTo()表示 讲所有的元素追加到指定的元素中。例$(A)appendTo(B) 是将A追加到B中下面的方法解释类似。</p>
<h2 id="21-你使用过包裹节点的方法吗，包裹节点有方法有什么好处？"><a href="#21-你使用过包裹节点的方法吗，包裹节点有方法有什么好处？" class="headerlink" title="21 你使用过包裹节点的方法吗，包裹节点有方法有什么好处？"></a>21 你使用过包裹节点的方法吗，包裹节点有方法有什么好处？</h2><p>答: wrapAll(),wrap(), wrapInner() 需要在文档中插入额外的结构化标记的时候可以使用这些包裹的方法应为它不会帛画原始文档的语义</p>
<h2 id="22-jquery中如何来获取或和设置属性？"><a href="#22-jquery中如何来获取或和设置属性？" class="headerlink" title="22 jquery中如何来获取或和设置属性？"></a>22 jquery中如何来获取或和设置属性？</h2><p>jQuery中可以用attr()方法来获取和设置元素属性removeAttr() 方法来删除元素属性</p>
<h2 id="23-如何来设置和获取HTML-和文本的值？"><a href="#23-如何来设置和获取HTML-和文本的值？" class="headerlink" title="23 如何来设置和获取HTML 和文本的值？"></a>23 如何来设置和获取HTML 和文本的值？</h2><p>答：html()方法 类似于innerHTML属性 可以用来读取或者设置某个元素中的HTML内容注意：html() 可以用于xhtml文档 不能用于xml文档text() 类似于innerText属性 可以用来读取或设置某个元素中文本内容。val() 可以用来设置和获取元素的值</p>
<h2 id="24-你jquery中有哪些方法可以遍历节点？"><a href="#24-你jquery中有哪些方法可以遍历节点？" class="headerlink" title="24 你jquery中有哪些方法可以遍历节点？"></a>24 你jquery中有哪些方法可以遍历节点？</h2><p>答 ：children() 取得匹配元素的子元素集合,只考虑子元素不考虑后代元素 next() 取得匹配元素后面紧邻的同辈元素prev() 取得匹配元素前面紧邻的同辈元素siblings() 取得匹配元素前后的所有同辈元素closest() 取得最近的匹配元素find() 取得匹配元素中的元素集合 包括子代和后代</p>
<h2 id="25-子元素选择器-和后代选择器元素有什么区别？"><a href="#25-子元素选择器-和后代选择器元素有什么区别？" class="headerlink" title="25 子元素选择器 和后代选择器元素有什么区别？"></a>25 子元素选择器 和后代选择器元素有什么区别？</h2><p>答:子代元素是找子节点下的所有元素,后代元素是找子节点或子节点的子节点中的元素</p>
<h2 id="26-在jquery中可以替换节点吗？"><a href="#26-在jquery中可以替换节点吗？" class="headerlink" title="26 在jquery中可以替换节点吗？"></a>26 在jquery中可以替换节点吗？</h2><p>答：可以 在jQuery中有两者替换节点的方式 replaceWith() 和 replaceAll()例如在</p><p title="hao are you">hao are you</p>替换成<strong>I am fine</strong>$(‘p’).replaceWith(‘<strong>I am fine</strong>‘); replaceAll 与replaceWith的用法前后调换一下即可。<em>**</em><p></p>
<h2 id="27-你觉得beforeSend方法有什么用？"><a href="#27-你觉得beforeSend方法有什么用？" class="headerlink" title="27 你觉得beforeSend方法有什么用？"></a>27 你觉得beforeSend方法有什么用？</h2><p>答：发送请求前可以修改XMLHttpRequest对象的函数，在beforeSend中如果返回false 可以取消本次的Ajax请求。XMLHttpRequest对象是唯一的参数所以在这个方法里可以做验证</p>
<h2 id="28-siblings-方法-和-‘prev-div’-选择器是一样的嘛？"><a href="#28-siblings-方法-和-‘prev-div’-选择器是一样的嘛？" class="headerlink" title="28 siblings() 方法 和 $(‘prev~div’)选择器是一样的嘛？"></a>28 siblings() 方法 和 $(‘prev~div’)选择器是一样的嘛？</h2><p>答: $(‘prev~div’) 只能选择’#prev’元素后面的同辈<div>元素而siblings()方法与前后的文职无关，只要是同辈节点就都能匹配。</div></p>
<h2 id="29-你在ajax中使用过JSON吗，你是如何用的？"><a href="#29-你在ajax中使用过JSON吗，你是如何用的？" class="headerlink" title="29 你在ajax中使用过JSON吗，你是如何用的？"></a>29 你在ajax中使用过JSON吗，你是如何用的？</h2><p>答:使用过，在$.getJSON() 方法的时候就是。因为 $.getJSON() 就是用于加载JSON文件的</p>
<h2 id="30-有哪些查询节点的选择器？"><a href="#30-有哪些查询节点的选择器？" class="headerlink" title="30 有哪些查询节点的选择器？"></a>30 有哪些查询节点的选择器？</h2><p>答：我在公司使用过 :first 查询第一个，:last 查询最后一个，:odd查询奇数但是索引从0开始:even 查询偶数，:eq(index)查询相等的 ,:gt(index)查询大于index的 ,:lt查询小于index:header 选取所有的标题等</p>
<h2 id="31-nextAll-能-替代-‘prev-siblindgs’-选择器吗？"><a href="#31-nextAll-能-替代-‘prev-siblindgs’-选择器吗？" class="headerlink" title="31 nextAll() 能 替代$(‘prev~siblindgs’)选择器吗？"></a>31 nextAll() 能 替代$(‘prev~siblindgs’)选择器吗？</h2><p>答:能。 使用nextAll() 和使用$(‘prev~siblindgs’) 是一样的</p>
<h2 id="32-jQuery中有几种方法可以来设置和获取样式"><a href="#32-jQuery中有几种方法可以来设置和获取样式" class="headerlink" title="32 jQuery中有几种方法可以来设置和获取样式"></a>32 jQuery中有几种方法可以来设置和获取样式</h2><p>答 ：addClass() 方法，attr() 方法</p>
<h2 id="33-document-ready-方法和window-onload有什么区别？"><a href="#33-document-ready-方法和window-onload有什么区别？" class="headerlink" title="33 $(document).ready()方法和window.onload有什么区别？"></a>33 $(document).ready()方法和window.onload有什么区别？</h2><p>答: 两个方法有相似的功能，但是在实行时机方面是有区别的。 1window.onload方法是在网页中所有的元素(包括元素的所有关联文件)完全加载到浏览器后才执行的。2 $(document).ready() 方法可以在DOM载入就绪时就对其进行操纵，并调用执行绑定的函数。</p>
<h2 id="34-jQuery是如何处理缓存的？"><a href="#34-jQuery是如何处理缓存的？" class="headerlink" title="34 jQuery是如何处理缓存的？"></a>34 jQuery是如何处理缓存的？</h2><p>答 ：要处理缓存就是禁用缓存.1 通过$.post() 方法来获取数据，那么默认就是禁用缓存的。2 通过$.get()方法 来获取数据，可以通过设置时间戳来避免缓存。可以在URL后面加上+(+new Date)例 $.get(‘ajax.xml?’+(+new Date),function () { //内容 }); 3 通过$.ajax 方法来获取数据，只要设置cache:false即可。</p>
<h2 id="35-getScript-方法-和-getJson-方法有什么区别？"><a href="#35-getScript-方法-和-getJson-方法有什么区别？" class="headerlink" title="35 $.getScript()方法 和 $.getJson() 方法有什么区别？"></a>35 $.getScript()方法 和 $.getJson() 方法有什么区别？</h2><p>答: 1 $.getScript() 方法可以直接加载.js文件，并且不需要对javascript文件进行处理，javascript文件会自动执行。2 $.getJson() 是用于加载JSON 文件的 ，用法和$.getScript()</p>
]]></content>
    </entry>
    
  
  
</search>
